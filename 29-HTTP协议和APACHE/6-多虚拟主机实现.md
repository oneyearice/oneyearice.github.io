# 第6节. 多虚拟主机实现



## 目录访问的别名



别名在welcome.conf里也见过的，上一篇将/.noindex.html的时候就遇到过👇

![image-20231008173934545](6-多虚拟主机实现.assets/image-20231008173934545.png)



开始实验

``` 
mkdir /app/forum
echo 'thisi is /app/forum/' > /app/forum/index.html

```

用户通过 curl 192.168.126.130/bbs/      访问到/app/forum/

当然你说用**跳转**，没必要，这里用alias别名

当你还还说用**软连接**，没必要，这用别名

![image-20231008175354158](6-多虚拟主机实现.assets/image-20231008175354158.png)







光写别名还不行，👆还需要补上别名的那个目标地址的访问权限。

问题来了①我待会使用curl 192.168.126.130/bbs/去访问，/bbs这个文件夹我感觉不用存在，感觉正确。

②/app/forum在os层面也是需要apache可读的。

 ![image-20231008180742329](6-多虚拟主机实现.assets/image-20231008180742329.png)

![image-20231008180618767](6-多虚拟主机实现.assets/image-20231008180618767.png)





### 总结，页面URL里的路径不一定在DocumentRoot下

curl http://192.168.126.130/dir100，实际上就是打开dir100/index.html页面

①这个dir100文件夹确实在DocumentRoot下，且apache配置文件里有给到访问权限。

②软连接，不过软连接所在的路径应该也需要在配置文件里给到访问权限

③别名，就是上文的alias，这个种dir100文件夹 都无需创建。

④跳转应该也算一个，具体见上一篇文章。





## 基于用户名密码方式控制访问

之前上一篇讲了基于源IP地址来控制访问已经实现了，这里接着讲基于用户名密码

<img src="6-多虚拟主机实现.assets/image-20231009091958620.png" alt="image-20231009091958620" style="zoom:40%;" />

要支持用户名密码方式控制访问，需要确认开启auth_basic模块，当然默认就开启了

<img src="6-多虚拟主机实现.assets/image-20231009092111393.png" alt="image-20231009092111393" style="zoom:50%;" /> 



### 要实现的目标：用户访问页面的时候，弹出对话框让其输入用户名密码。

```
cd /data/www
mkdir admin
echo 'this is /data/www/admin/index.html ...' > admin/index.html

```

![image-20231009093930931](6-多虚拟主机实现.assets/image-20231009093930931.png)

![image-20231009094209032](6-多虚拟主机实现.assets/image-20231009094209032.png)

### 需求：访问主站点无需验证，访问admin/index.html的时候要验证。

比如admin里放的是后台管理的页面，所以需要验证才能访问。

而用户名密码肯定不是系统的用户，而是httpd服务的，这种用户就称之为**虚拟用户**。不是真实的OS的用户。

这种虚拟用户，在不同的服务里都存在，除了这里的HTTP，还有FTP，等，都是服务自身的用户认证，无关于系统用户。

使用htpasswd来创建http的用户名密码，第一次敲这个命令的时候需要-c指定存放用户名密码的文件的。后续不能使用-c，否则原来的文件就被覆盖了。

![image-20231009095302744](6-多虚拟主机实现.assets/image-20231009095302744.png)

由于http页面认证的用户名密码也算是一种配置，所以就放到/etc/httpd/conf.d/配置文件路径下。



<img src="6-多虚拟主机实现.assets/image-20231009122337889.png" alt="image-20231009122337889" style="zoom:33%;" />



找出下图👇错误之处

![image-20231009095938801](6-多虚拟主机实现.assets/image-20231009095938801.png)

当然第二次别加-c就对了，然后 ①   <font color=red>.httpuser</font>前面的.就是好习惯，用户名密码文件用隐藏的就很不错

②就是交互式的密码2次就很不爽，找一下👇

![image-20231009100437085](6-多虚拟主机实现.assets/image-20231009100437085.png)

好创建三个用户吧，重新来一遍

```
htpasswd -c .httpuser user1
   ...  输入密码
   ...  再次输入密码
htpasswd .httpuser user2
   ...  输入密码
   ...  再次输入密码
echo 'cisco' | htpasswd -i .httpuser user3  # 非交互式类似于echo 'cisco' | passwd --stdin user1

```

![image-20231009101245617](6-多虚拟主机实现.assets/image-20231009101245617.png)

果然和passwd很像，同样也加了盐，所以一样的密码，hash值就不一样了👆。apr1可能是类似哈希算法的类型。后面一段$xxxxx$应该就是盐，$分割除了3段，最后一段就是加了盐一起的哈希结果。





这样用户名密码就有了，下面就是在配置文件里写上 调用验证，然后到指定的文件认证就行了。

### 使用.httpuser密码文件的方法1：写到配置文件

<img src="6-多虚拟主机实现.assets/image-20231009122909363.png" alt="image-20231009122909363" style="zoom:33%;" />



<img src="6-多虚拟主机实现.assets/image-20231009123003706.png" alt="image-20231009123003706" style="zoom:40%;" />



![image-20231009133858922](6-多虚拟主机实现.assets/image-20231009133858922.png)

主站无需认证👇

![image-20231009133917058](6-多虚拟主机实现.assets/image-20231009133917058.png)

admin路径需要认证

![image-20231009133934869](6-多虚拟主机实现.assets/image-20231009133934869.png)

上图没有体现出来AuthName "xxxxx" 内容。估计现在没几个浏览器支持这种显示了。

只有输入Require user 里指定的 admin用户名密码才行

![image-20231009134020942](6-多虚拟主机实现.assets/image-20231009134020942.png)

<img src="6-多虚拟主机实现.assets/image-20231009134040515.png" alt="image-20231009134040515" style="zoom:44%;" />





![image-20231009134923483](6-多虚拟主机实现.assets/image-20231009134923483.png)

👆上图一共3条记录，前两条是弹窗用户名密码输错了的记录401就是未授权的意思，第三条是正确的用户名的记录而且在记录的开头有显示具体的用户名。

另外curl也支持输入用户名密码的方式，不过就不是交互式的了👇

![image-20231009135458222](6-多虚拟主机实现.assets/image-20231009135458222.png)



**针对 .httpuser里的所有用户都可以访问这个文件夹**

![image-20231009135920825](6-多虚拟主机实现.assets/image-20231009135920825.png)



### 使用.httpuser密码文件的方法2：.htaccess

**进一步复习下上一篇的.htaccess文件，就是上述配置可以移到这个文件里**

<img src="6-多虚拟主机实现.assets/image-20231009140243104.png" alt="image-20231009140243104" style="zoom:33%;" />



先去配置文件里 允许.htaccess覆盖，当然这里选择仅覆盖authconfig就是认证相关的；

然后再将原来配置文件里的4行配置删除，配置到访问路径--也就是需要认证文件夹下

![image-20231009140648400](6-多虚拟主机实现.assets/image-20231009140648400.png)

上图修正下，既然已经在这个路径下了，肯定就不需要写Directory了，

![image-20231009141101540](6-多虚拟主机实现.assets/image-20231009141101540.png)

修改这些路径下的文件，无需重启服务，验证OK👇

![image-20231009141123020](6-多虚拟主机实现.assets/image-20231009141123020.png)



![image-20231009141147032](6-多虚拟主机实现.assets/image-20231009141147032.png)



### 用户组授权的配置

<img src="6-多虚拟主机实现.assets/image-20231009142604997.png" alt="image-20231009142604997" style="zoom:50%;" /> 



![image-20231009142518964](6-多虚拟主机实现.assets/image-20231009142518964.png)



![image-20231009142726849](6-多虚拟主机实现.assets/image-20231009142726849.png)



![image-20231009142830895](6-多虚拟主机实现.assets/image-20231009142830895.png)

上图👆有错误，httpd -t也检查不出来；①漏掉了AuthUserfile XXXX 路径指定；②随后一行少了group参数。![image-20231009143641903](6-多虚拟主机实现.assets/image-20231009143641903.png)

修改👇

![image-20231009143620172](6-多虚拟主机实现.assets/image-20231009143620172.png)

验证效果，符合按组授权👇

![image-20231009143732677](6-多虚拟主机实现.assets/image-20231009143732677.png)



前面就介绍了http的访问控制里的基于IP和基于用户名密码的控制，下面学习一下两种方式的选择组合

### 远程客户端IP和用户验证的控制



<img src="6-多虚拟主机实现.assets/image-20231009145820146.png" alt="image-20231009145820146" style="zoom:38%;" /> 

浅测一下👇

1、首先我打算把配置都写道页面资源的路径下的.htaccess里  

2、于是我就要去到配置文件里去写上"允许覆盖"的参数

![image-20231009150443768](6-多虚拟主机实现.assets/image-20231009150443768.png)

3、然后去页面资源路径下编辑.htaccess文件

![image-20231009150646418](6-多虚拟主机实现.assets/image-20231009150646418.png)

有点问题，就是Satisfy All没有生效！没有做到 双重验证。就是输入用户名后就能访问了，理论上是要备ip 禁止访问的。



这里就会担心这个.htaccess里是否可以这么写，查查官网发现.htaccess支持Satisfy All的

<img src="6-多虚拟主机实现.assets/image-20231009155844263.png" alt="image-20231009155844263" style="zoom:40%;" /> 

context的意思就是配置在哪里，

![image-20231009160024760](6-多虚拟主机实现.assets/image-20231009160024760.png)

不过写法有点变化

![image-20231009160243291](6-多虚拟主机实现.assets/image-20231009160243291.png)

IP控制用的是Allow，自然有deny。

然后呢发现

![image-20231009161323447](6-多虚拟主机实现.assets/image-20231009161323447.png)



然后发现

![image-20231009161429043](6-多虚拟主机实现.assets/image-20231009161429043.png)

结论：

①all确实是 用户认证  + IP acl  都要满足；any就是任一个满足就行。

②原来那套配置\<RequireAll\>XXXXX\</RequireAll\>  在这里貌似不行。

③尝试写一个白名单出来

![image-20231009162058542](6-多虚拟主机实现.assets/image-20231009162058542.png)



![image-20231009162217210](6-多虚拟主机实现.assets/image-20231009162217210.png)

OK~



![image-20231009163443518](6-多虚拟主机实现.assets/image-20231009163443518.png)







## 实现用户家目录的http共享也就是web访问

同样要支持家目录的web访问，要有模块预加载

![](6-多虚拟主机实现.assets/image-20231009164431895.png)

关于模块加载，见前文👇

![image-20231009164558705](6-多虚拟主机实现.assets/image-20231009164558705.png)



**下面就是将 用户的 家目录分享出来**

![image-20231009170151942](6-多虚拟主机实现.assets/image-20231009170151942.png)

修改权限也没用

![image-20231009170625013](6-多虚拟主机实现.assets/image-20231009170625013.png)

恢复原来的权限700👆后继续实验👇

----------

待会使用这个ming1的家目录

![image-20231009164833170](6-多虚拟主机实现.assets/image-20231009164833170.png)

找到配置文件userdir.conf

![image-20231009164920328](6-多虚拟主机实现.assets/image-20231009164920328.png)

修改对应内容

![image-20231009164957373](6-多虚拟主机实现.assets/image-20231009164957373.png)

修改如下

![image-20231009165150441](6-多虚拟主机实现.assets/image-20231009165150441.png)

这样就①开启了userdir的共享；②家目录共享不是说所有文件，而是要指定家目录下的某个文件夹共享，如上图的public_html共享。![image-20231009165425926](6-多虚拟主机实现.assets/image-20231009165425926.png)

![image-20231009165750015](6-多虚拟主机实现.assets/image-20231009165750015.png)



重启服务后，浏览器访问http://192.168.126.130/~ming/即可

![image-20231009171305535](6-多虚拟主机实现.assets/image-20231009171305535.png)

这里要记得修改/home/ming1的权限，只要通过facl给到apache就行了，因为用户访问文件夹，其实是通过httpd服务进程区访问的，而httpd都是apache用户运行的。

<img src="6-多虚拟主机实现.assets/image-20231009171429301.png" alt="image-20231009171429301" style="zoom:33%;" />

修改权限

![image-20231009171523176](6-多虚拟主机实现.assets/image-20231009171523176.png)



![image-20231009172150428](6-多虚拟主机实现.assets/image-20231009172150428.png)

给了apache进入ming1家目录的权限就行了

同样注意一点就是facl设置以后的ll 

![image-20231009172229357](6-多虚拟主机实现.assets/image-20231009172229357.png)



**注意 必须是/~userDir/的写法**

<img src="6-多虚拟主机实现.assets/image-20231009172344391.png" alt="image-20231009172344391" style="zoom:33%;" />

<img src="6-多虚拟主机实现.assets/image-20231009172357262.png" alt="image-20231009172357262" style="zoom:33%;" />



加一个验证

![image-20231009173014590](6-多虚拟主机实现.assets/image-20231009173014590.png)

**👇注意：缓冲会导致弹不出验证窗口：①常规浏览器需要清缓存才能弹；②无痕需要 关闭所有无痕再打开新的无痕才能保证没有缓存；如果有一个无痕没关，则缓存还在。**

![image-20231009173029770](../27-MYSQL数据05/image-20231009173029770.png)

![image-20231009173041722](6-多虚拟主机实现.assets/image-20231009173041722.png)

其实写一个.htaccess就要有一个习惯思维--就是是否可以写进去，如果不行就写道directory里。啥意思

![image-20231009173328880](6-多虚拟主机实现.assets/image-20231009173328880.png)



![image-20231009173348966](6-多虚拟主机实现.assets/image-20231009173348966.png)



上下文可以写的地方有👇

![image-20231009173439294](6-多虚拟主机实现.assets/image-20231009173439294.png)

像有的配置就写在别的地方👇

![image-20231009173459810](6-多虚拟主机实现.assets/image-20231009173459810.png)



再一个

![image-20231009174415500](6-多虚拟主机实现.assets/image-20231009174415500.png)



这样试试看

![image-20231009174611792](6-多虚拟主机实现.assets/image-20231009174611792.png)

结果也是正常的👇并没有说上面的授权全放就全放了，下面没有不起作用。挺好~

![image-20231009174746740](6-多虚拟主机实现.assets/image-20231009174746740.png)





![image-20231009175608805](6-多虚拟主机实现.assets/image-20231009175608805.png)



要实现这种哪哪都生效的效果，是不是 代码里 ①将所有配置合并②找出最严格的配置③类似rib里的最长匹配。



## ServerSignatrue

![image-20231009180248410](6-多虚拟主机实现.assets/image-20231009180248410.png)

和结合serverToken一起梳理知识点

![image-20231009180427548](6-多虚拟主机实现.assets/image-20231009180427548.png)





浅测一下

![image-20231009180633763](6-多虚拟主机实现.assets/image-20231009180633763.png)

再删掉.htacess做一下放心对比动作



![image-20231009180715920](6-多虚拟主机实现.assets/image-20231009180715920.png)



我感觉.htaccess挺好，因为它不是配置文件，无需重启服务就能生效；但是它又能做配置文件里的配置，就很香了。





### status页面

<img src="6-多虚拟主机实现.assets/image-20231009180856347.png" alt="image-20231009180856347" style="zoom:35%;" />



依赖于这个模块👇

![image-20231009181204972](6-多虚拟主机实现.assets/image-20231009181204972.png)

干嘛的呢，就是获取apache的工作状态，默认关闭的。

![image-20231009182627028](6-多虚拟主机实现.assets/image-20231009182627028.png)

又可以塞到.htaccess里了，哈哈，开心

![image-20231009182834622](6-多虚拟主机实现.assets/image-20231009182834622.png)



当然，你要用directory一样的效果，不过要配置，同样DocumentRoot下的.htaccess或者配置文件里配置：

![image-20231009182948921](6-多虚拟主机实现.assets/image-20231009182948921.png)



![image-20231009183117346](6-多虚拟主机实现.assets/image-20231009183117346.png)



