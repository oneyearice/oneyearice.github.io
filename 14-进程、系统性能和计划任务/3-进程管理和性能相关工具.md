# 第3节. 进程管理和性能相关工具

<img src="3-进程管理和性能相关工具.assets/image-20220801163254648.png" alt="image-20220801163254648" style="zoom:80%;" />  





查看某个终端tty下的进程

<img src="3-进程管理和性能相关工具.assets/image-20220801163759712.png" alt="image-20220801163759712" style="zoom:80%;" /> 



![image-20220801163830800](3-进程管理和性能相关工具.assets/image-20220801163830800.png) 

![image-20220801163910574](3-进程管理和性能相关工具.assets/image-20220801163910574.png) 

区分u和U，这个ps命令，上一篇里也有。



pgrep还支持正则

![image-20220801164425547](3-进程管理和性能相关工具.assets/image-20220801164425547.png) 

![image-20220801164521110](3-进程管理和性能相关工具.assets/image-20220801164521110.png) 

![image-20220801164541878](3-进程管理和性能相关工具.assets/image-20220801164541878.png) 

![image-20220801164614007](3-进程管理和性能相关工具.assets/image-20220801164614007.png) 

加上-l或者-a显示进程



pidof

![image-20220801164928934](3-进程管理和性能相关工具.assets/image-20220801164928934.png) 

虽然是软链接，但是功能不一样，也就是说，可以创建多个软链接指向同一个文件，但是每个软链接的功能不一样。



uptime

dd if=/dev/zero of=/dev/null来消耗CPU然后uptime观察看下

![image-20220801165353046](3-进程管理和性能相关工具.assets/image-20220801165353046.png) 

![image-20220801165621362](3-进程管理和性能相关工具.assets/image-20220801165621362.png) 

load average这个数值也是进程数量的意思。

![image-20220801171208422](3-进程管理和性能相关工具.assets/image-20220801171208422.png) 

一个内核，一搬load average不大于3，所以24是可接受范围以内。

超过24就认为每个内核有3个以上的进程在排队，系统就非常慢了。



uptime一个是命令，一个是proc/uptime文件

![image-20220801171603017](3-进程管理和性能相关工具.assets/image-20220801171603017.png)

单位都是秒，一个系统启动时长，一个是空闲进程总时长(按总CPU数计算的)。

![image-20220801171909822](3-进程管理和性能相关工具.assets/image-20220801171909822.png) 

平均下来每个CPU的空闲时间就是/8，7717秒空闲，8604s开机时间，所以大部分时候是闲着的。



w 命令和uptime也是重叠的

![image-20220801172206860](3-进程管理和性能相关工具.assets/image-20220801172206860.png) 



top的一行也是uptime

![image-20220801172335270](3-进程管理和性能相关工具.assets/image-20220801172335270.png) 

所有进程个数是223个， 2个运行的，220睡眠的，0个停止，0个僵尸态。

cpus的分配情况，us用户空间占用了2.1%，sy内核空间占用了10%

![image-20220801172600929](3-进程管理和性能相关工具.assets/image-20220801172600929.png) 

其实us用户空间占用高才是好的，因为这代表着应用程序占用内核率高，而应用程序代表着生产力。

各种软件都是工作在用户空间的

从这个CPU的两个值就可以看出来，你的系统忙不忙，合不合理。

![image-20220801173004039](3-进程管理和性能相关工具.assets/image-20220801173004039.png)

ni是进程的优先级调整

id是空闲，100就是cpu100%空闲，没事干。

wa是wait等待时间，有些进程需要等待资源的访问，准备好了才能运行。

hi是硬终端

si是软中断

st是被盗取的时间片

中断，就是打断了CPU的正常工作。中断什么时候发生呢？





看下用户空间-内核-硬件的模型图，

<img src="3-进程管理和性能相关工具.assets/image-20220801173544353.png" alt="image-20220801173544353" style="zoom:50%;" />

![image-20220801173620079](3-进程管理和性能相关工具.assets/image-20220801173620079.png) 



![image-20220801173718159](3-进程管理和性能相关工具.assets/image-20220801173718159.png)

内核kernel和硬件的沟通就是通过 中断，比如键盘按一个键，内核就会捕获这个操作，用中断方式响应用户的请求。

当你每次在键盘上按下一个按键后，CPU 会被中断以使得 PC 读取用户键盘的输入。这就是硬中断，还有软中断，比如程序的异常 

![image-20220801174801731](3-进程管理和性能相关工具.assets/image-20220801174801731.png) 



st：steal，被盗取

早期的计算机操作系统，不支持不理解虚拟机里运行的进程，

windows任务管理器打开，看到当前进程，这些进程只是windwos里的进程，然后VMwareWorkStation里跑的进程占用的时间片，就被称为ST-被盗取的时间。

![image-20220801181246063](3-进程管理和性能相关工具.assets/image-20220801181246063.png)

后面会讲KVM，类似于windows的VMwareWorkStation。



![image-20220801182236956](3-进程管理和性能相关工具.assets/image-20220801182236956.png) 

内存，总的、空闲、用了多少、被buff/cache占用了多少



然后top下面的主体部分

![image-20220801182405525](3-进程管理和性能相关工具.assets/image-20220801182405525.png)

3s默认的刷新间隔，可改按s建后改。

默认是按CPU利用率高到低，显示的，测试，跑个dd ，top里就看到第一个了。

![image-20220801182916589](3-进程管理和性能相关工具.assets/image-20220801182916589.png)

PID、用户名、优先级PR--这个PR是TOP的PR，它在linux优先级里的情况如下

<img src="3-进程管理和性能相关工具.assets/image-20220801183010938.png" alt="image-20220801183010938" style="zoom: 67%;" /> 

NI就是nice优先级

VIRT是系统承若的内存、RES是实际使用的物理内存、SHR是共享内存

TIME+是总的CPU分配时长



![image-20220801191805459](3-进程管理和性能相关工具.assets/image-20220801191805459.png) 

OOM：out of memory内存泄漏

一般某个进程的内存不断在涨，就认为可能发生了OOM了。



<img src="3-进程管理和性能相关工具.assets/image-20220801194341877.png" alt="image-20220801194341877" style="zoom:67%;" /> 

![image-20220801194357546](3-进程管理和性能相关工具.assets/image-20220801194357546.png) 



-H显示这个进程下面打开的线程

使用pstree -p 找个多线程的进程PID

<img src="3-进程管理和性能相关工具.assets/image-20220801194901641.png" alt="image-20220801194901641" style="zoom:80%;" /> 

花括号就是多线程

![image-20220801194955742](3-进程管理和性能相关工具.assets/image-20220801194955742.png)

![image-20220801195530029](3-进程管理和性能相关工具.assets/image-20220801195530029.png) 

这就打开了某个进程里的线程。

 

top -H -p \`pidof xxx\`  # 这个pid会不会pidof xxx取出来多个啊？就会出错

![image-20220801195322595](3-进程管理和性能相关工具.assets/image-20220801195322595.png) 





free看内存

centos6和7不一样

![image-20220801200531606](3-进程管理和性能相关工具.assets/image-20220801200531606.png) 

![image-20220801200554055](3-进程管理和性能相关工具.assets/image-20220801200554055.png) 

6的buffer和cache是分开的，7是合二为一的

buffer是写，改一个文件后，要写数据， 要先放入buffer缓冲区的，然后buffer里按一定的队列次序写入磁盘。可能就是改一个字符不会给你存盘 就是放在buffer里，等你改了很多字符后才会统一从buffer里给你写入磁盘。这样能提供效率。

cache是读，数据的读取，放入缓存里，下次读取直接从缓存里读取就行了。

默认是KB单位

![image-20220801201124153](3-进程管理和性能相关工具.assets/image-20220801201124153.png)



![image-20220802095803861](3-进程管理和性能相关工具.assets/image-20220802095803861.png) 

cp一样会增大cached

![image-20220802100007576](3-进程管理和性能相关工具.assets/image-20220802100007576.png) 



看下内存使用情况的计算

![image-20220802101730028](3-进程管理和性能相关工具.assets/image-20220802101730028.png) 

![image-20220802101746687](3-进程管理和性能相关工具.assets/image-20220802101746687.png) 

used - buffers - cached = 真正使用的内存空间

![image-20220802101905486](3-进程管理和性能相关工具.assets/image-20220802101905486.png)

free + buffers + cached = 真正可用的内存空间

但其实你用echo 3 > /proc/sys/vm/drop_caches释放也不可能将buffers和cached全部释放掉的，所以也没有上面说的那么富裕。

下面是centos7的内存计算方式

![image-20220802102938094](3-进程管理和性能相关工具.assets/image-20220802102938094.png) 

total = used + free + buff/cache

available 是系统自动给你算的，它不是简单的free + 部分buff/cache，你看上图的available就小于free，这看起来就不科学，因为空闲的竟然不是全部可用的。之所以出现free < available，十有八九是你刚刚做了清缓存的动作，这样会释放出很多作为free，但是系统自己知道这些释放出来的也有一些很快会还回去再次被使用，所以不可能全部就作为available可用空间，这个时候你reboot一下就会发现free就恢复正常了，所谓正常就是free < available

![image-20220802104040170](3-进程管理和性能相关工具.assets/image-20220802104040170.png) 



注意-g的使用 不会四舍五入

![image-20220802104223886](3-进程管理和性能相关工具.assets/image-20220802104223886.png)





1s刷一次，有助于动态观察

![image-20220802104328913](3-进程管理和性能相关工具.assets/image-20220802104328913.png)



图形界面是很占用内存的

![image-20220802104428727](3-进程管理和性能相关工具.assets/image-20220802104428727.png)

上面的gnome-shell,gnome-software,X,gnome-terminal都是属于图形界面的应用。

通过init 3关闭图形界面后，free大大地增加

![image-20220802104630630](3-进程管理和性能相关工具.assets/image-20220802104630630.png)

所以工作中一般不开图形





![image-20220802110436040](3-进程管理和性能相关工具.assets/image-20220802110436040.png) 



![image-20220802110548379](3-进程管理和性能相关工具.assets/image-20220802110548379.png) 

解释上图

procs列：r b,1 0,这些地意思，r是运行或者可运行的进程数，b是可中断睡眠态的进程数存在阻塞了，这是被阻塞的队列的长度。1 0，1个，0个，这些是动态变化的，不是固定的。

-----memory----

swpd：被交换的内存空间

free：空闲的内存空间

buff和cache：上图buff空间小，cache空间多，说明数据上目前没有什么写操作。



----swap-----

si：进，数据进swap，就是说把内存中暂时不用的数据放到swap里，对于swap来讲是进，对于内存来讲是出。

​		可惜我们通常字面意思的理解就错了，这里的swap和后面的---io---都是以内存为参照物的in和out



so：出



测试下si so值，构建一个大内存的使用情况，超出内存，然后才会使用swap

![image-20220802112426020](3-进程管理和性能相关工具.assets/image-20220802112426020.png)

![image-20220802112602876](3-进程管理和性能相关工具.assets/image-20220802112602876.png)

此时内存不够用了，就会将内存中不用的数据往swap里写，so就会增长

![image-20220802112646156](3-进程管理和性能相关工具.assets/image-20220802112646156.png) 

如图，内存不够用，一开始就是so暴涨，到后面就有进有出了就。



-----io-----

io理论上也是磁盘的io，其对应的bi和bo理论上都是说的磁盘的in和out，但这里就不是，这就是统一指的内存的in和out。

![image-20220802113909579](3-进程管理和性能相关工具.assets/image-20220802113909579.png)

如图从硬盘上读数据，表现在vmstat的bi暴涨：因为读数据时先读入内存

![image-20220802114140121](3-进程管理和性能相关工具.assets/image-20220802114140121.png) 



如果从内存中读数据，/dev/zero是个内存数据，写道硬盘上，此时---io---里就是bo暴涨

![image-20220802114250103](3-进程管理和性能相关工具.assets/image-20220802114250103.png) 

![image-20220802114322332](3-进程管理和性能相关工具.assets/image-20220802114322332.png) 

这个命令一会就能把硬盘打满。测试的时候要小心。



----system------

<img src="3-进程管理和性能相关工具.assets/image-20220802114643387.png" alt="image-20220802114643387" style="zoom:80%;" />  

进程切换过多会影响效率的



----cpu----

这里的us  sy   id  wa  st和top里的一个意思

![image-20220802114726758](3-进程管理和性能相关工具.assets/image-20220802114726758.png) 





![image-20220802120135641](3-进程管理和性能相关工具.assets/image-20220802120135641.png) 





![image-20220802120125804](3-进程管理和性能相关工具.assets/image-20220802120125804.png)







