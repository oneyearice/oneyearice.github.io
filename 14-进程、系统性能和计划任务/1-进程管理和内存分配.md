# 第1节. 进程管理和内存分配



## 进程概念

进程，正在进行的程序，正在内存中运行的程序；若没有运行，只是安装的系统中的一个软件而已。

![image-20220325140114243](1-进程管理和内存分配.assets/image-20220325140114243.png)

ls如果不运行，只是一个文件；当输入ls回车的时候，就会把这个文件读入到内存中，通过CPU读取ls程序里的一条条指令进行执行，最终命令执行完毕，结果输出，程序退出，程序在内存中占用的空间就释放，这个进程也就结束了，所以进程的启动、运行、终止，就是进程的生命周期。



此外有些程序是随着计算机开启后就自动运行的，这种进程一般叫做守护进程，表现为随着计算机启动而运行，随着计算机关闭而终止执行。也可以人为通过工具干涉自动的行为。



进程，不管是普通的进程还是守护进程，本质上都是消耗系统资源的一个单元。

此外还有线程、协程。



每个进程都会分配相应的资源：

①分配独立的内存空间

②操作系统分配唯一的编号PID进程ID

③其他属性，比如哪个用户运行的此进程



![image-20220325141833443](1-进程管理和内存分配.assets/image-20220325141833443.png)

task struct ，进程运行的时候，系统会给他分配一个task struct任务结构表，这个表里存放了进程的PID、谁运行的、占用了哪些内存空间等其他信息。



task list，任务列表，就是多个相关联的task struct互相调用吧



第一进程，centos6上市initd，centos7上是systemd了

![image-20220325142819912](1-进程管理和内存分配.assets/image-20220325142819912.png)

![image-20220325142756247](1-进程管理和内存分配.assets/image-20220325142756247.png)





![image-20220325142904282](1-进程管理和内存分配.assets/image-20220325142904282.png)

systemd不在PATH路径中，是在👇这个路径下

![image-20220325142921159](1-进程管理和内存分配.assets/image-20220325142921159.png)

centos7上的init其实没了，只是systemd的软连接

![image-20220325145022551](1-进程管理和内存分配.assets/image-20220325145022551.png)

而centos6就是真实的init

![image-20220325145058139](1-进程管理和内存分配.assets/image-20220325145058139.png)



第一进程开启之后，然后子进程一般都是fork()函数创建，clone()很少用；创建子进程后，一般采用CoW写时复制机制。



所谓CoW写时复制机制就是

1、父进程已经分配了一定的资源，当创建子进程的时候不会立即给这个子进程分配内存空间，也就是说👇两个父子进程都采用的相同的内存空间 。

<img src="1-进程管理和内存分配.assets/image-20220325150516659.png" alt="image-20220325150516659" style="zoom:50%;" /> 

2、当子进程涉及到数据修改的时候，就会立即复制父进程的内存空间，然后将子进程指向这块新的内存空间

<img src="1-进程管理和内存分配.assets/image-20220325150851943.png" alt="image-20220325150851943" style="zoom:50%;" /> 

这就是CoW(copy on write)，只有数据发生变化的时候才会产生复制的行为。

这样就比较节约内存空间。



在cp命令的说明中有提到CoW

![image-20220325151052329](1-进程管理和内存分配.assets/image-20220325151052329.png)





## 进程、线程、协程

![image-20220325151224543](1-进程管理和内存分配.assets/image-20220325151224543.png)

进程时独立占用资源的单位，进程A占用的资源和进程B占用的资源时不相干的。

进程相当于项目小组；

线程相当于完成项目的人，所以进程里至少得有一个人--线程。项目复杂了就需要多个人来完成工作，进程里就有多个线程了。

一个进程的任务切成多个小任务，每个任务由单个线程来完成。



线程从哪里可以看到，pstree -p可见

![image-20220325152302038](1-进程管理和内存分配.assets/image-20220325152302038.png) 

花括号就是线程，其实花不花括号无所谓，一个线程也是线程，如下：

![image-20220325152358752](1-进程管理和内存分配.assets/image-20220325152358752.png)

这种就没有线程，因为进程下面就一个线程，所以没有花括号。



进程、线程的资源分配都是由操作系统来完成的。

协程和开发语言相关，有的就没有协程的概念，python里有。

协程相当于线程里独立执行的一个语句块；协程的之间的调度由程序员来控制的。

▲进程和线程的控制由操作系统来完成的；协程的控制是由程序员来完成的。



进程运行必然要分配内存空间，而内存空间的分配是以页page为单位进行分配的。

之前学习文件系统的时候，磁盘上保存文件的最小单位也是4K，那里也有一个最小单元。4K是默认值，额可以修改，一般不改。

内存中给进程分配内存大小，也有一个最小单元，也就是page=4K。这个页最小单元不能改。

▲磁盘给文件分配磁盘空间是4k4k的给；内存给进程分配内存空间也是4k4k的给。





进程在运行的时候以为自己拥有所有计算机的内存空间，它并不知道还有别的程序在运行。

![image-20220325163249010](1-进程管理和内存分配.assets/image-20220325163249010.png)

**MMU**是CPU里的一个固件单元，就是CPU的一部分咯，复制计算虚拟内存和物理内的映射关系，而这个关系要存下来方便快速取用的，**TLB**就是这个存下来的映射表。

在一个进程看来，使用的是系统所有的内存就是那么多；而实际上只是物理内存里的一部分，这一部分可能是连续的 可能是离散。所以虚拟内存空间自然也是线性的连续的空间了。虚拟内存空间也叫线性内存空间。



![image-20220325164402173](1-进程管理和内存分配.assets/image-20220325164402173.png)

1、用户空间3个G、内核空间1个G

2、用户空间就是给应用程序用的，每个进程都使用的是虚拟地址空间

3、每个进程的虚拟空间又可分为：

​		①代码段：比如ls二进制程序代码，放在这里；

​		②数据段：比如程序运行需要的变量，放这个空间；

​		③BSS:Block Started by Symbol segment: 也是存放变量，不过是一些没有初始化过的变量，比如申明了int或者flat的变量，但是没有赋值。

![image-20220325171506761](1-进程管理和内存分配.assets/image-20220325171506761.png) 这个变量n就放在BSS里 

![image-20220325171523224](1-进程管理和内存分配.assets/image-20220325171523224.png) 这个n就放在数据段里

很好记，有值了就是有数据了，就放在数据段里了。

4、堆：存放系统中需要使用到的一部分内存空间，该空间可动态调整，算是公用的空间；需要时分配，不需要是释放。比如某些进程比如排序类的就比较占用内存，就需要分配一些堆的空间，大概这个意思咯。

5、栈：函数里用到的变量，和堆head不同在于--看下面这段吧，讲的看起还不错

```
程序的运行场所是内存，栈和堆是进程的虚拟内存中的两部分区域。

当程序被执行时，程序代码，你所创建的变量、常量等都会被压入栈空间里，栈是程序代码的执行区域。栈的内存地址是连续的且被一一记录，所以说当你创建了一个变量(比如int var = 1)，我们就可以通过var这个变量来访问变量的内容。在这里，var就存放在栈中，它的地址已经默认被编译器计算好了，调用过程也不需要你涉及到有关地址的操作。更直观的感受是数组，数组里的元素在栈里面是连续排放的，相邻两个元素的地址相差1。

而堆是不同于栈的另一部分区域，系统会给每个程序分配一部分栈空间让他们能够运行起来，问题就是栈空间必然存在不够用的问题，而堆不属于程序，堆是独立的，是公用的。只要你new，就可以得到相应一部分的堆空间。

有栈，为什么用堆？

栈里面的东西有生命周期，说俗点就是变量作用域，你在函数内部创建一个变量，函数调用结束这个变量就没了。而堆里面的东西独立于你的程序，new之后，除非你delete掉，否则一直存在。

有什么要注意？

堆里面申请的东西，是随机分配的，不像栈里面的地址都已经计算好了。所以申请了堆空间之后一定要创建一个指针保存你所申请到的堆空间的地址。不然就找不到你申请的空间了。

堆空间的东西申请好，在用完之后一定要delete掉，以防止堆溢出。
————————————————
原文链接：https://blog.csdn.net/u012460314/article/details/52355668
```



![image-20220325183121964](1-进程管理和内存分配.assets/image-20220325183121964.png)

1、创建：fork()函数创建一个程序，先进入了就绪态(ready)；

2、就绪态ready：就是进程需要的资源都准备好了比如内存空间、文件、变量、代码等，准备好了CPU就可以来执行这个程序了。

3、执行态：如果进程执行时间较长，多个进程之间就存在 进程调度 ，而每个进程会分配时间片，时间片用完就回到就绪态，等待下一个时间片的分配。因为时间片特别短，所以即使是单核CPU给人的感觉也是多个程序同时跑的。

​		时间片用完，没有执行完，进程就得停止(注意这里不是阻塞哦 不要理解错了，然后这里的停止不是普通意义上的停止就是不断地保存现场和继续执行地过程)，就需要保存现场--将执行的状态保存下来，待会下一次时间片分配了继续执行。这存在一个状态切换的过程，就会带来一点资源的损耗，比如CPU的寄存器的值的存储和清空以及再次读入。

4、阻塞态：进程执行中如果涉及磁盘IO，磁盘IO的耗时远远大于CPU的，所以这个进程就停在这--阻塞态，等磁盘IO的结果出来 再继续执行。

​		注意阻塞态完了后 也就是得到结果了 I/O完成了，程序是进入就绪态，才能得到时间片继续运行，所以说阻塞态的进程停在那，实际上也就是现场保存在那，等I/O的结果在继续要时间分片。所以阻塞态必然是进程停止的--这个停止不是kill也不是systemctl stop xxx，而是不要时间片的保存现场，I/0有了结果才会去进入就绪态去要时间片去继续执行程序。

5、终止：此时程序执行完毕，所有占用的资源得以释放，比如内存、占用的文件等。



![image-20220325183151592](1-进程管理和内存分配.assets/image-20220325183151592.png)



![image-20220325183202981](1-进程管理和内存分配.assets/image-20220325183202981.png)



