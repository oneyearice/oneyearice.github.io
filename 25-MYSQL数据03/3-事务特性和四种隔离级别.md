# 第3节. 事务特性和四种隔离级别



## 事务的概念

事务Transactions：一组原子性的SQL语句，或一个独立工作单元
事务日志：记录事务信息，实现undo,redo等故障恢复功能
ACID特性：
A：atomicity原子性；整个事务中的所有操作要么全部成功执行，要么全部 失败后回滚

C：consistency一致性；数据库总是从一个一致性状态转换为另一个一致性 状态

I：Isolation隔离性；一个事务所做出的操作在提交之前，是不能为其它事务 所见；隔离有多种隔离级别，实现并发。

​		隔离有隔离级别：一个修改事务过程中，另一个事务能否看到是取决于隔离级别的，比如你你修改1000未1100，别人不一定能看到1100。

​		一个事务没有结束，中间过程的数据就叫做“脏数据”。

D：durability持久性；一旦事务提交，其所做的修改会永久保存于数据库中



撤销叫做回滚，commit就确定了就永久保存在数据库中了。



### 事务日志类似于ext3的文件系统日志



1、100变成200，200变成300，然后还没来得及commit就停电了

![image-20230703172340287](3-事务特性和四种隔离级别.assets/image-20230703172340287.png)

此时后面来电mysql起来后，会对这个100->200,200->300的 事务日志 做undo撤销动作。

1、2、3本来只是完成到事务的日志记录，实际上并未提交

![image-20230703171401191](3-事务特性和四种隔离级别.assets/image-20230703171401191.png)

此时就是100大不了没有改成300，就是100不变。





![image-20230703181216268](3-事务特性和四种隔离级别.assets/image-20230703181216268.png)

事务日志已经commit提交的是一个完整的事务，就redo--在数据库里重新执行一遍写进数据文件里，没有的undo撤销。

所以事务日志里有redo日志和undo日志。





### 事务的执行过程

<img src="3-事务特性和四种隔离级别.assets/image-20230703182120895.png" alt="image-20230703182120895" style="zoom:50%;" />



1、刚开始数据库是初始化状态

2、开始一个事务，事务开始的标志是：人工手动，或者 隐式的开始

3、事务中：增、删、改；查应该不算在是事务里了，看来不是说算不算的问题，而是你放不放的问题，你手动制动select就是事务里的，就是啦，隐式估计不放吧。

<img src="3-事务特性和四种隔离级别.assets/image-20230703182602275.png" alt="image-20230703182602275" style="zoom:33%;" />

<img src="3-事务特性和四种隔离级别.assets/image-20230703182722786.png" alt="image-20230703182722786" style="zoom:33%;" />

4、commit，如果事务确定要提交了也就是结束了，就是commit。相当于订单提交，不过也可能是加入购入车哈哈。

​		一旦提交就进了新的数据状态了。

5、rollback，回到原来状态。



## 事务的CLI

自动提交：回车就默认commit了



![image-20230704092749478](3-事务特性和四种隔离级别.assets/image-20230704092749478.png)

同样我的测试

![image-20230704095159972](3-事务特性和四种隔离级别.assets/image-20230704095159972.png)



主键就是理解成主键索引，同理唯一键也是等价于唯一键索引，比如你创建一个唯一键，其实就是默认创建了唯一键索引

![image-20230704093411969](3-事务特性和四种隔离级别.assets/image-20230704093411969.png)

<img src="3-事务特性和四种隔离级别.assets/image-20230704093426607.png" alt="image-20230704093426607" style="zoom: 33%;" /> 

drop index uni_age on testlog;删除唯一键，就可以使用存储过程插入了。

![image-20230704095001799](3-事务特性和四种隔离级别.assets/image-20230704095001799.png)

10万条记录，所以耗时13.74

看看我自己的测试

![image-20230704095614792](3-事务特性和四种隔离级别.assets/image-20230704095614792.png)

这个call执行完就是自动提交了，而且可能还是一行行的提交的，因为10万行嘛

你也可以改成像orcale一样的方式--默认不自动提交。

<img src="3-事务特性和四种隔离级别.assets/image-20230704100050642.png" alt="image-20230704100050642" style="zoom:50%;" />

可以修改为不自动提交。

<img src="3-事务特性和四种隔离级别.assets/image-20230704100235656.png" alt="image-20230704100235656" style="zoom:33%;" />

![image-20230704100445607](3-事务特性和四种隔离级别.assets/image-20230704100445607.png)

然后删除一行记录看看

![image-20230704100626384](3-事务特性和四种隔离级别.assets/image-20230704100626384.png)

删掉后，自己看确实删掉了

![image-20230704101221245](3-事务特性和四种隔离级别.assets/image-20230704101221245.png)

但是别人看--另外开一个终端ssh去看👇还在：

![image-20230704101304827](3-事务特性和四种隔离级别.assets/image-20230704101304827.png)



所以

1、修改autocommit自动提交为OFF

2、自己删除一行，自己看得到；但是属于事务中间状态的数据，

3、别人看不到；如果别人看到就是脏数据。

4、能不能看到和隔离级别有关，默认是看不到的。

这就是事务的隔离性，你没commit就不是一个完整的事务。

5、把shell窗口关掉，模拟事务没有提交的异常断开效果，看看undo效果

![image-20230704101922258](3-事务特性和四种隔离级别.assets/image-20230704101922258.png)

肯定的啊，这个动作不就等价于别人看嘛，还验证个啥哦。不过这里和别人看不到是两回事，这里涉及一个undo也就是rollback。

6、commit后别人所见不变；这还是   事务的隔离性，事务的隔离性后面讲，一共有4种。

![image-20230704102452117](3-事务特性和四种隔离级别.assets/image-20230704102452117.png)

自己删除25行后，提交后，别人还能看到25行





### 人为的起止事务

##### 启动事务：下面3个cli照抄就行就是事务开始的cli

BEGIN

BEGIN WORK

START TRANSACTION

##### 结束事务：

COMMIT：提交 ROLLBACK: 回滚

注意：只有事务型存储引擎中的DML语句方能支持此类操作

![image-20230704104828081](3-事务特性和四种隔离级别.assets/image-20230704104828081.png)

再加一条

![image-20230704104947651](3-事务特性和四种隔离级别.assets/image-20230704104947651.png)

撤销

![image-20230704105022695](3-事务特性和四种隔离级别.assets/image-20230704105022695.png)

一旦提交，就真的把数据库文件改了

![image-20230704105159366](3-事务特性和四种隔离级别.assets/image-20230704105159366.png)





![image-20230704110646817](3-事务特性和四种隔离级别.assets/image-20230704110646817.png)

但是我这边没做出来，奇了怪了，难道是mariadb版本太高了？

![image-20230704110721350](3-事务特性和四种隔离级别.assets/image-20230704110721350.png)





![image-20230704122729852](3-事务特性和四种隔离级别.assets/image-20230704122729852.png)

我靠，什么时候改掉了，默认不应该是InnoDB吗

![image-20230704122713964](3-事务特性和四种隔离级别.assets/image-20230704122713964.png)

![image-20230704122805048](3-事务特性和四种隔离级别.assets/image-20230704122805048.png)

靠，删掉，重来一遍看看效果

![image-20230704122831476](3-事务特性和四种隔离级别.assets/image-20230704122831476.png)

![image-20230704122959494](3-事务特性和四种隔离级别.assets/image-20230704122959494.png)

emmm，删表，重建

![image-20230704123114133](3-事务特性和四种隔离级别.assets/image-20230704123114133.png)

![image-20230704123304436](3-事务特性和四种隔离级别.assets/image-20230704123304436.png)

![image-20230704123326074](3-事务特性和四种隔离级别.assets/image-20230704123326074.png)

好了，再试试call pro_testlog；的手动begin，整体事务的方式

1、直接call就是存储过程里的没一行都会默认自动提交，就会很慢

而且可见innodb的这个调用10w行的存储过程要比MyISAM慢的多的多，可能是MyISAM没有事务，也就没有事务日志，所以快？

感觉下面begin可能时间也是和MyISAM一样，因为整个call xx就是一个事务，感觉相当于MyISAM的没有事务了。



2、其实innodb手动指定事务还是要比没有事务的MyISAM要快一半的时间。

![image-20230704123723128](3-事务特性和四种隔离级别.assets/image-20230704123723128.png)



3、结论innodb 调用10万行的存储过程，使用整体一个事务的方式，耗时也是要比MyISAM要快的，我的机器配置是4s的7s。当然老师的就是更快了，看前面的图1.55s。



以上就验证了![image-20230704135250972](3-事务特性和四种隔离级别.assets/image-20230704135250972.png)

同样drop table这种DDL语言，不是DML语句，也不会支持rollback操作

![image-20230704135451340](3-事务特性和四种隔离级别.assets/image-20230704135451340.png) 

![image-20230704135524323](3-事务特性和四种隔离级别.assets/image-20230704135524323.png)

发现DDL(drop create alter)语句是没法rollback的，这些是和select一样会记录到事务里，但是不是DML(INSERT UDDATE DELETE)，不支持rollback，自然也不需要commit。





### 事务支持保存点：savepoint 

SAVEPOINT identifier              # 定义保存点

ROLLBACK [WORK] TO [SAVEPOINT] identifier   		# 回到对应的保存点

RELEASE SAVEPOINT identifier

就是在事务执行的过程种，在某个节点打标签，将来rollback到对应的savepoint。

![image-20230704140533736](3-事务特性和四种隔离级别.assets/image-20230704140533736.png)

现在表里加了3条记录

![image-20230704140555318](3-事务特性和四种隔离级别.assets/image-20230704140555318.png)



1、直接rollback就全部撤销了

2、rollback to  aa_tran

![image-20230704140805749](3-事务特性和四种隔离级别.assets/image-20230704140805749.png)

3、撤销过了，一些savepoint没了就没了，bb_tran整个保存点也就没了。

![image-20230704140832308](3-事务特性和四种隔离级别.assets/image-20230704140832308.png)





## 事务的隔离级别

##### 事务隔离级别：从上至下更加严格

### READ UNCOMMITTED 

可读取到未提交数据，产生脏读。



### READ COMMITTED 

可读取到提交数据，但未提交数据不可读，产生<font color=red>不可重复读</font>，即可读取到多个提交数据，导致每次读取数据不一致

<img src="3-事务特性和四种隔离级别.assets/image-20230704203024113.png" alt="image-20230704203024113" style="zoom:50%;" />

A分别在事务t1修改100为200，又子事务t2修改200为300，

B在一个大的事务t3中，两次时间节点看到的值不同，前面是200，后面又变成了300。

B就在一个事务中读取到了多个不同的值，这就是产生了 不可以重复读的结果，因为重复读数据不同了。

### REPEATABLE READ 

可重复读，多次读取数据都一致，产生幻读，即 读取过程中，即使有其它提交的事务修改数据，仍只能读取到未修改 前的旧数据。此为MySQL默认设置

<img src="3-事务特性和四种隔离级别.assets/image-20230704204147631.png" alt="image-20230704204147631" style="zoom:33%;" />

说明repeatable read可重复读，就是B在整个事务t3的执行期间，每次读取的数据都是一样的。从结果上来讲就是可以重复的去读数据，数据是一致的。

​	但是！数据早就改掉了，甚至删掉了，结果B还是一直认为数据还是原来的样子，这就是幻读。

​	结论：虽然可能存在幻读，但是恰恰就是保证数据一致性了，所以这个就是mysql的默认机制--mysql默认事务隔离级别为“可重复读”。

​	举例：备份期间，如果以事务开始，就是备份的前敲一个begin的意思了，无论备份执行多久，数据就是一开始时候的样子，是不变的，哪怕别的用户提交了修改数据，在备份的这个事务期间都是不变的，带来的好处就是：数据的一致性，就是在以事务方式进行的备份中，数据都是一个时间节点的数据。

### SERIALIZABILE 

可串行化，未提交的读事务阻塞修改事务，或者未 提交的修改事务阻塞读事务。导致并发性能差





### MVCC

多版本并发控制，和事务级别相关
