# 第1节. 软件管理基础





![img](1-软件管理基础.assets/clip_image002.jpg)

ABI 应用程序二进制接口，API是开发接口

这里补一个ABI API的理解

WINE，让linux上跑windows的软件

Cygwin，windows上跑linux的软件

![img](1-软件管理基础.assets/clip_image004.jpg)

预处理：去掉注释、打上行号、引用的文件(include代码)等放进来，等

编译：语法分析，错误，转成汇编代码

汇编：汇编代码还是文本，汇编之后就是机器码了，还要把库连接起来。这些库有静态和动态之分

静态：把库和二进制结合在一起，合成一个文件；

动态：程序运行的时候再寻找依赖库；不合并。



## .so是shareobject

![img](1-软件管理基础.assets/clip_image006.jpg)

共享对象，好多程序会共用这个库

ldd可以看用的哪些库，不仅仅cat依赖这个库，ls也依赖。共同依赖的库

![img](1-软件管理基础.assets/clip_image008.jpg)

![img](1-软件管理基础.assets/clip_image009.png)

共用的库

![img](1-软件管理基础.assets/clip_image011.jpg)

.c**源代码**C语言写的---用gcc**预处理**成.i后缀---compilation**编译**成汇编语言assembly----**汇编成**二进制.o对象文件----link**链接**.a静态库----生成最终的一个文件。

 <img src="1-软件管理基础.assets/image-20220211181721592.png" alt="image-20220211181721592" style="zoom:50%;" />





### 动静优缺点



<img src="1-软件管理基础.assets/clip_image013.jpg" alt="img" style="zoom:67%;" />

 应用案例：注意通常我们都是动态链接的库，所以把一个二进制程序复制过去别的电脑上需要考虑把依赖的库文件也一并找出来复制过去。

![img](1-软件管理基础.assets/clip_image015.jpg)

 

![img](1-软件管理基础.assets/clip_image017.jpg)

 

![img](1-软件管理基础.assets/clip_image019.jpg)

 JAVA号称一次编译，到处运行的底层思路：

1、存在本质上的两次编译

2、第1次编译，是编译成标准字节码文件

3、然后再各个系统上面预装了JVM java虚拟机，当字节码在这些JVM上运行的时候 就会再次编译一次。



<img src="1-软件管理基础.assets/image-20220211184231669.png" alt="image-20220211184231669" style="zoom:67%;" />



需求产生了，降低使用开源软件的难度，直接给C，编译困难，就出来了debian版本

三大主流linux分支debian、redhat、slackware。

debian就率先考虑的需求，就帮你编译好，打好包，让你使用的时候自动的解包，dpkg

debian package管理器，Ubuntu就是debian咯。

![image-20220211184305130](1-软件管理基础.assets/image-20220211184305130.png)





![img](1-软件管理基础.assets/clip_image021.jpg)

![img](1-软件管理基础.assets/clip_image023.jpg)

 

![img](1-软件管理基础.assets/clip_image025.jpg)

 

![img](1-软件管理基础.assets/clip_image027.jpg)

 

![img](1-软件管理基础.assets/clip_image029.jpg)

![img](1-软件管理基础.assets/clip_image031.jpg)

![img](1-软件管理基础.assets/clip_image032.png)

![img](1-软件管理基础.assets/clip_image033.png)

![img](1-软件管理基础.assets/clip_image034.png)

![img](1-软件管理基础.assets/clip_image035.png)

 

用sed来弄

![img](1-软件管理基础.assets/clip_image037.jpg)

![img](1-软件管理基础.assets/clip_image039.jpg)

![img](1-软件管理基础.assets/clip_image041.jpg)

 

 

==============================================================================================

 

![img](1-软件管理基础.assets/clip_image042.png)

 

![img](1-软件管理基础.assets/clip_image043.png)

![img](1-软件管理基础.assets/clip_image045.jpg)

![img](1-软件管理基础.assets/clip_image046.png)

 

![img](1-软件管理基础.assets/clip_image047.png)

 

 

![img](1-软件管理基础.assets/clip_image049.jpg)

 

![img](1-软件管理基础.assets/clip_image051.jpg)

 

![img](1-软件管理基础.assets/clip_image053.jpg)

![img](1-软件管理基础.assets/clip_image055.jpg)

这就是拆包分类

![img](1-软件管理基础.assets/clip_image056.png)

 

\---------------------------

 

![img](1-软件管理基础.assets/clip_image058.jpg)

 

![img](1-软件管理基础.assets/clip_image060.jpg)

思考是不是cat命令就是用的/bin/cat文件，还是后面调用了C语言的库呢？

![img](1-软件管理基础.assets/clip_image062.jpg)

再者so就是share object

![img](1-软件管理基础.assets/clip_image064.jpg)

很多二进制文件都是依赖一些共同的so库

![img](1-软件管理基础.assets/clip_image066.jpg)

可惜mv也是依赖这个库

![img](1-软件管理基础.assets/clip_image068.jpg)

然后图形界面也死掉了

![img](1-软件管理基础.assets/clip_image069.png)

修复要么快照，或者借助光盘

![img](1-软件管理基础.assets/clip_image071.jpg)

上面的关闭客户机这些本质上还是调系统的命令，下面的重置才是按电源重启。

重启也起不来了

重试救援光盘来解决

1、插入光盘，连着的

2、进度条出来后果断esc

![img](1-软件管理基础.assets/clip_image072.png)

3、选择3 CD-ROM启动

![img](1-软件管理基础.assets/clip_image074.jpg)

4、选择troubleshooting

![img](1-软件管理基础.assets/clip_image076.jpg)

5、救援系统

![img](1-软件管理基础.assets/clip_image078.jpg)

就是类似windows的pe，交换机路由器的RMON，类似这种最小操作系统。

 

6、进入后界面

![img](1-软件管理基础.assets/clip_image080.jpg)

因为是从光盘启动，所根不再是/了，而是/mnt/sysimage/

![img](1-软件管理基础.assets/clip_image082.jpg)

你的系统被挂载到了/mnt/sysimage。你看到的文件系统是/mnt/sysimage这套

上图system写错了改成sysimage。

![img](1-软件管理基础.assets/clip_image084.jpg)

![img](1-软件管理基础.assets/clip_image086.jpg)

而我们要找的文件就在：

![img](1-软件管理基础.assets/clip_image088.jpg)

思考此时mv能用吗？

![img](1-软件管理基础.assets/clip_image090.jpg)

因为用的是光盘里的mv，不是硬盘里的mv。所以是可以用的。

![img](1-软件管理基础.assets/clip_image092.jpg)

然后exit退出，自动重启就修复好了。

 

 

![img](1-软件管理基础.assets/clip_image094.jpg)

 

 

![img](1-软件管理基础.assets/clip_image096.jpg)

![img](1-软件管理基础.assets/clip_image098.jpg)

 

 

 

![img](1-软件管理基础.assets/clip_image100.jpg)

一个RPM包里可能包含的东西比较多：

![img](1-软件管理基础.assets/clip_image102.jpg)

脚本的意义在于，你安装程序前先给你创建好用户，这样你才有所有者，所有组啊。诸如此类的信息。

前两行都有：

![img](1-软件管理基础.assets/clip_image104.jpg)

第三行的脚本不一定每个RPM包里都有。

 

![img](1-软件管理基础.assets/clip_image106.jpg)

RPM包不是安装好了就行了，还需要处理文件的属性信息存放便于后续查找。

数据库简单说就是文件夹，里面存放了安装rpm包的很多信息。如果没有/var/lib/rpm，你都不知道你安装了那些程序。也不知道哪些文件来自哪个包。

![img](1-软件管理基础.assets/clip_image108.jpg)

![img](1-软件管理基础.assets/clip_image110.jpg)

比如安装软件，如果已经安装过了，就不会安装了，这就是到这里查找的。

 

![img](1-软件管理基础.assets/clip_image112.jpg)

 

有些官网提供了编译好的，有些就是提供源码给你自己编译。

![img](1-软件管理基础.assets/clip_image114.jpg)

![img](1-软件管理基础.assets/clip_image115.png)

![img](1-软件管理基础.assets/clip_image117.jpg)

操作路径

![img](1-软件管理基础.assets/clip_image119.jpg)

![img](1-软件管理基础.assets/clip_image121.jpg)

ppc是powerpc的，不用管

![img](1-软件管理基础.assets/clip_image122.png)

 

\-----

![img](1-软件管理基础.assets/clip_image124.jpg)

![img](1-软件管理基础.assets/clip_image126.jpg)

Fedora是红帽的上游测试版，dnf在Fedora 18版就有了。

然后现在centos-stream要取代centos8变成rehat的上游了。

![img](1-软件管理基础.assets/clip_image127.png)

![img](1-软件管理基础.assets/clip_image129.jpg)

![img](1-软件管理基础.assets/clip_image130.png)

![img](1-软件管理基础.assets/clip_image132.jpg)

 

 

 

\-------

![img](1-软件管理基础.assets/clip_image134.jpg)

 

 

![img](1-软件管理基础.assets/clip_image136.jpg)

配置 > /dev/null就可以实现静默安装。

 

![img](1-软件管理基础.assets/clip_image138.jpg)

其实没问题，是光盘里的，但是这里的告警是说验证来源是没有验证的。

一般warning也是可以了解下的。

signature是来源，其实就是公钥的验证。就是windows里的受信任的证书。

 

![img](1-软件管理基础.assets/clip_image140.jpg)

 

![img](1-软件管理基础.assets/clip_image142.jpg)

 

\---

![img](1-软件管理基础.assets/clip_image144.jpg)

 

![img](1-软件管理基础.assets/clip_image146.jpg)

![img](1-软件管理基础.assets/clip_image148.jpg)

![img](1-软件管理基础.assets/clip_image150.jpg)

选项放前面，这里习惯不好。

 

 

![img](1-软件管理基础.assets/clip_image152.jpg)

![img](1-软件管理基础.assets/clip_image154.jpg)

之前装过了，这里查询的话只要写名称就行了

![img](1-软件管理基础.assets/clip_image156.jpg)

没装是这个样子的

![img](1-软件管理基础.assets/clip_image158.jpg)

![img](1-软件管理基础.assets/clip_image160.jpg)

![img](1-软件管理基础.assets/clip_image162.jpg)

我们-e卸载后再试试

![img](1-软件管理基础.assets/clip_image164.jpg)

 

 

======

![img](1-软件管理基础.assets/clip_image166.jpg)

 

 

![img](1-软件管理基础.assets/clip_image168.jpg)

或者查询某个包里包含哪些文件

![img](1-软件管理基础.assets/clip_image170.jpg)

![img](1-软件管理基础.assets/clip_image172.jpg)

是不是重新安装一些tree就行了

![img](1-软件管理基础.assets/clip_image174.jpg)

因为那个var/lib/rpm里有安装过的信息了，所以不会给你安装了，你说rpm -e卸载呢，不推荐，因为说不定之前都做过一些配置优化了。

![img](1-软件管理基础.assets/clip_image176.jpg)

办法就不是![img](1-软件管理基础.assets/clip_image178.jpg)，这是会全部覆盖的。

![img](1-软件管理基础.assets/clip_image180.jpg)

![img](1-软件管理基础.assets/clip_image182.jpg)

replacepkgs和replacesfiles，就是只覆盖有的，没有的就安装。

 

replacefiles是只覆盖有冲突的文件。一般用在两个包一样但是版本不同，第二个包安装覆盖掉冲突的就是相同的文件就能正常安装第二个包了，同时第一个包的不同版本的软件可以自然可以使用同名的文件。

 

\----

![img](1-软件管理基础.assets/clip_image184.jpg)

查看软件包的信息

上图中的官方站点可以去获取最新的版本

![img](1-软件管理基础.assets/clip_image186.jpg)

![img](1-软件管理基础.assets/clip_image188.jpg)

tgz就是tar.gz

 

![img](1-软件管理基础.assets/clip_image189.jpg)

如何只修复其中一个文件呢

利用cpio来解开rpm

![img](1-软件管理基础.assets/clip_image191.jpg)

![img](1-软件管理基础.assets/clip_image193.jpg)

利用cpio -tv查看文件列表

![img](1-软件管理基础.assets/clip_image195.jpg)

![img](1-软件管理基础.assets/clip_image197.jpg)

不过这样cpio解开的rpm再mv过去，有个问题，文件属性可能还需要注意一下。

 

 

![img](1-软件管理基础.assets/clip_image199.jpg)

![img](1-软件管理基础.assets/clip_image201.jpg)

 

![img](1-软件管理基础.assets/clip_image203.jpg)

默认就不具备完整性校验

 

![img](1-软件管理基础.assets/clip_image205.jpg)

先看下包里有没有脚本

-q --scripts 插已安装的包

-qp --scripts插未安装的包

![img](1-软件管理基础.assets/clip_image207.jpg)

 

![img](1-软件管理基础.assets/clip_image209.jpg)

 

![img](1-软件管理基础.assets/clip_image211.jpg)

将来如果是源码安装，就需要参考这些rpm安装的脚本来自己创建这些用户和组。

 

 

 
