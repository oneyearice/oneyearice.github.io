{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 课程介绍和·小·目标 linxu~PY，-go~>> 目录生成的方法： 打开pycharm里的windows/summary/list/directory_generate.py，运行 将运行结果去头掐尾后，复制到nodepad过滤一遍格式，然后再复制到SUMMARY.md中即可。 然后再gitbook init初始化目录结构。 github 创建项目的提示备忘： …or create a new repository on the command line echo \"# oneyearice.github.io\" >> README.md git init git add README.md git commit -m \"first commit\" git branch -M main git remote add origin https://github.com/oneyearice/oneyearice.github.io.git git push -u origin main …or push an existing repository from the command line git remote add origin https://github.com/oneyearice/oneyearice.github.io.git git branch -M main git push -u origin main …or import code from another repository You can initialize this repository with code from a Subversion, Mercurial, or TFS project. 多终端pull和push注意点： 1、首先pull下来，得到最新的版本，如果是第一次git clone即可 2、复制oneyearice.github.io并重命名为gitbook；如果是git clone的就复制文件夹里的内容到gitbook下，选择替换原文件，得到最新的版本。 注意gitbook是本地编辑目录，oneyearice.gitbhu.io是pull和push目录 3、进入gitbook下运行gitbook install安装插件 3、在gitbook里编辑md文件，也就是主要工作内容 4、运行脚本自动上传 1、进入D盘git clone，如果有Oneyearice.github.io文件夹，进去后git pull 2、将oneyearice.github.io文件夹复制，并改名为gitbook 3、进入gitbook，删除node_module文件夹，cmd在gitbook文件夹下运行gitbook install ---开始编写md文章---完了就👇--- 4、my笔记本需要注释掉book.json里的\"-anchor-navigation-ex\"👈这样注释，运行脚本自动push 后面看心情，可以弄成两个脚本，pull和push，pull就上面的1 2 3，push就是4 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-02-01 15:42:20 "},"序.html":{"url":"序.html","title":"序","keywords":"","body":"一声叹息解千愁 风中再无少年游 华发霜鬓难回首 万般滋味在心头 仰天长笑忆往昔 终究哪般得自由 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-02-01 15:42:20 "},"1-基础知识介绍/1-基础知识介绍.html":{"url":"1-基础知识介绍/1-基础知识介绍.html","title":"第一章 基础知识介绍","keywords":"","body":"第一章 基础知识介绍 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"1-基础知识介绍/1-计算机基础.html":{"url":"1-基础知识介绍/1-计算机基础.html","title":"第1节 计算机基础","keywords":"","body":"第1节. 计算机基础 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"1-基础知识介绍/2-操作系统基础.html":{"url":"1-基础知识介绍/2-操作系统基础.html","title":"第2节 操作系统基础","keywords":"","body":"第2节. 操作系统基础 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"1-基础知识介绍/3-linux介绍.html":{"url":"1-基础知识介绍/3-linux介绍.html","title":"第3节 linux介绍","keywords":"","body":"第3节. linux介绍 https://www.kernel.org/ slackware:SUSE debian:ubuntu redhat:REHEL、CentOS [11:02:17 root@pyConsole ~]#uname -r 4.18.0-193.el8.x86_64 linux只是一个内核，加上GNU工具、附加软件和软件包管理组成的操作系统才是发行版。 CentOS https://wiki.centos.org/Download http://mirrors.aliyun.com http://mirrors.sohu.com http://mirrors.163.com https://mirrors.tuna.tsinghua.edu.cn/centos/ Ubuntu http://cdimage.ubuntu.com/releases/18.04.1/release/?_ga=2.56783850.1533668672.1544323446-1412352718.1543052421 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"2-linux基础和帮助/2-linux基础和帮助.html":{"url":"2-linux基础和帮助/2-linux基础和帮助.html","title":"第二章 linux基础和帮助","keywords":"","body":"第二章 linux基础和帮助 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"2-linux基础和帮助/1-linux安装前准备.html":{"url":"2-linux基础和帮助/1-linux安装前准备.html","title":"第1节 linux安装前准备","keywords":"","body":"第1节. linux安装前准备 1、 在windows是怎么安装的，类比一下， 分区、C盘、D盘，系统、数据文件。 2、 在linux同样类似思路，逻辑卷、raid， 大多数企业选择的是分区方式，而不是逻辑卷和raid。 3、 linux一切皆文件，不同类型的资源都命名为文件了 linux的目录结构 windows的C盘，D盘，里面格式有很多文件夹 C盘的顶级目录 在windows里有几个分区，就有几个顶级目录，或者叫根目录 在linux只有一个根root，而且用的是正斜线，linux不管你是几个分区，它的目录结构都是不变的。 /usr 类似于windows里的C盘下的windows目录，都是存放操作系统文件的。 /root或者/home/xx 类似windows里的C盘下的users目录，都是存放用户自己的文件的。 此外在linux还有/boot目录，存放启动文件，比如linux内核就是放在该目录下的。 日志信息在/var/log，/var本身就是变化的意思。 /tmp存放临时数据的。 /proc是个假目录，是映射成内存数据，就是看到的是内存里的数据。正常的数据是放在磁盘上的，真正的目录都是对应磁盘上的文件夹，里面的数据都是放在磁盘上。这就是一切皆文件。 /etc就是windows里的注册表，注册表并不是单一的某一个文件，是二进制的若干个文件，不是存在在磁盘的某一处的。/etc就是各种配置文件也是文本文件。 linux分区和目录结构无关 linux有个目录叫/dev，存放设备的，包括，硬盘、光盘、u盘等。都是在dev下。比如机器上多块硬盘，linxu自动会出现多个文件。命名方式为，命名硬盘的方式sda,sdb,sdc这是centos6和7的命名方式， 在硬盘上还可划分分区，涉及分区类型，在windows上的分区是用盘符来命名的。分区还有扩展分区和逻辑分区。 分区类型： 1、 分区跟你的硬盘分区策略有关，GPT只支持主分区，暂不做讨论 2、 MBR是传统的分区法，支持主分区、扩展分区、逻辑分区（逻辑驱动器） 主分区，在单块一个硬盘上只能最多四个。如果有两块硬盘，其中一块可以没有主分区。在windows里主分区通常可以安装操作系统。不仅仅存放数据，如果有多个主分区，就有且仅有一个激活的主分区，OS启动的时候会去寻找激活的主分区，一个硬盘上最多有一个。 扩展分区：仅仅是主分区的话最多是4个，所以还需要扩展分区。在一个硬盘上最多一个扩展分区。不能直接存放数据，必须先将其划分成更小的分区-逻辑分区， 逻辑分区，扩展分区里更小的单位，这个小分区才能存数据，逻辑分区的个数可以很多。 3、 一块硬盘，主分区、主分区、大的扩展分区（里面分成若干个小的逻辑分区） 4、 linux一切皆文件，硬盘是有文件的，分区同样也是。分区是有编号的，主分区是1-4，扩展分区也是1-4，主分区+扩展分区一共最多4个，因此都是用1-4来表示的。 主分区的文件名：/dev/sda1 /dev/sda2，这个就是a硬盘上的第一个分区，第2个分区。这是主分区，扩展呢，一样也是1-4，比如/dev/sda3就可能是扩展分区。 5、 逻辑分区的编号，是从5开始编号的，/dev/sda5 /dev/sda6 dev/sda7，这三个就是在/dev/sda3上面的分区的。这个逻辑的序号是自动分配的，不能像主分区和逻辑分区那样可以人为的命名。 6、 扩展分区删除，意味着里面的逻辑分区也没了。 7、 存在不同分区的同名文件。讨论分区和目录的关系。windows是C盘下的test文件，D盘下的test文件。linux呢？是从根下面开始描述的。此时就需要把分区和某一个文件夹做关联，将来这个test就是这个关联好的目录下的文件了。 8、 将第一个硬盘分区和boot关联，boot就是对应/dev/sda1，所以要访问第一个硬盘的第一个分区就访问/boot就行了。此时第一个分区里的test就在/boot/test。第二个分区要想访问，就得先把他映射成一个目录比如叫/data，把第二个主分区/dev/sda2挂载到/data下，第二个test就在/data/test 9、 这种挂载在windows里是存在的，windows的分区也可以挂载到文件夹的。windows的e盘的盘符可以删了，此时这块空间和目录结构就没有关联没有映射了，磁盘管理就看不到e盘了，但数据还在，再加回去，可以叫其他F盘之类，还可以挂载到NFS文件夹中的这就跟linux的挂载文件一样了。 10、 没有独立出来挂载分区的文件夹，都是跟在根下的，都在根所在的分区里，有些是不能独立挂载的，必须和根在一起，比如/etc /dev ， /proc是虚拟文件夹内存来着更加不能独立了。 11、 理论上一个分区也是阔以的，但是肯定不安全，一个分区挂了，就完了。 12、 一般分区这样 /dev/sda 200g硬盘的推荐分区： /dev/sda1 mount /boot 1G 这是引导目录不需要太多空间200M的实际占用，也不是给你存放数据的，你的数据也别扔这里面，1G空间足足有余了。这个目标文件夹就叫mount point挂载点。 /dev/sda2 mount / 100G 根上，根下存放的数据就比较多了，如果linux安装不是最小化安装，光是系统本身就要几个G的数据，如果是最小安装，至少1g。 /dev/sda3 mount /data 50G 测试练习用的文件夹，学习用的，工作中，用户会用来存放数据库单独占一个分区。 /dev/sda4 swap 4G，这里不能叫mount挂载，因为swap不是个文件夹，它是分区，不能叫挂载，挂载都是设备往文件里挂。 如果这样划分的话，我们知道一个硬盘上最多4个主分区，意味着200G剩下50G的空间用free，将来不能再分区了，因为4个分区满了，逻辑分区是在扩展分区里分的，扩展分区是占主分区的1-4这个编号的，现在没地儿了。所以上面的分区得改。 /dev/sda4 extend 剩下的所有空间（除了上面分的所有空间剩下的45G） /dev/sda5 逻辑分区 swap 4G sda5就是在sda4上面分的了 还可以继续分小的逻辑分区。比如/dev/sda6等。 13、 swap 交换 早期机器内存小2G 4G swap就是4g 8g的分配， 现在服务器你的内存都很大256g 512g，swap肯定不能乘以2了，swap一般就是8g 16g就足够了。 14、 linux的swap和windows里的pagefile.sys文件是一回事 15、 GPT不支持扩展分区和逻辑分区 4、 在使用vmware worksation安装镜像的时候，光盘需要最后挂载，不然系统自动安装不会让自己分区的，而且还是最小化安装。 5、 os下载，可以到阿里云上下载， 6、 vmware的lck缓存文件注意一下，突然断电关机了，lck可能需要手动删除才能保证VM正常开机。 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"2-linux基础和帮助/2-centos7和rocky_linux安装详解.html":{"url":"2-linux基础和帮助/2-centos7和rocky_linux安装详解.html","title":"第2节 centos7和rocky_linux安装详解","keywords":"","body":"第2节 centos7和rocky_linux安装详解 1、安装前最好校验一下，防止iso损坏。 2、密码不符合安全要求，需要点击两次done。 3、文件格式化，linux centos6默认是ext4，也支持windows里的vfat，也支持centos7里的xfs。就用默认的就行 4、分区的sda1或sda2对应/还是/boot，这个序号对应关系不大，只要空间够就行。 5、ctrl + alt f2切到命令行界面，f6切回图形界面，cat /proc/meminfo 便于你在装机阶段查看内存大小。shift pageUp往上翻，memTotoal可见总内存大小。当然你要说 | less | more ，我也没办法。 6、在分区的时候，扩展分区是自动给你分的，你只要知道你在划分sda5的时候，会自动给你划分sda4—扩展分区就行了。 7、cat /proc/partition 可见当前只有一个sda 8、ls /dev/sda* 可见只有一个以sda开头的文件 9、等你的分区，确定格式化，werite chages to disk或done的时候，再去看ls /dev/sda*去看就看到分区开始实施了， cat /proc/partitions 也有了。 10、boot loader环节后面再说，这跳过 11、工作中一般都是minimal最小化安装，节约资源。学习选择Desktop或Server with GUI。 12、desktop，图形默认是GNOME，还有一种是KDE，一般不用KDE的（选择customize now—Desktops—KDE Desktop）。 13、centos7的安装注意： 1、内存2G，1G会导致系统安装报错-内存不够。 2、分区一样的，选择I will configure partitioning -Done-进入分区界面 单位可以输入比如1G 3、KDUMP别管，内核分析记录用的，系统崩溃查看用的，不是一般人玩的。默认是enabled，建议关掉，反正用不到。 4、关于ens33将来要改成eth1的 5、安装后，做好快照 14、ubuntu-18.04.1的安装 略，开发的，我看到的 智能小车，图像识别什么的用的就是ubuntu系统。 15、在安装过程中，可以 ctrl + alt f1 f2去切命令行界面 如果需要的话 16、centos允许你用root登陆，ubuntu不允许使用root，可以改passwd使能root的。 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"2-linux基础和帮助/3-linux入门操作和基础命令.html":{"url":"2-linux基础和帮助/3-linux入门操作和基础命令.html","title":"第3节 linux入门操作和基础命令","keywords":"","body":"第3节. linux入门操作和基础命令 入门操作 1、看版本 cat [root@localhost ~]# cat /etc/os-release NAME=\"Rocky Linux\" VERSION=\"8.5 (Green Obsidian)\" ID=\"rocky\" ID_LIKE=\"rhel centos fedora\" VERSION_ID=\"8.5\" PLATFORM_ID=\"platform:el8\" PRETTY_NAME=\"Rocky Linux 8.5 (Green Obsidian)\" ANSI_COLOR=\"0;32\" CPE_NAME=\"cpe:/o:rocky:rocky:8.5:GA\" HOME_URL=\"https://rockylinux.org/\" BUG_REPORT_URL=\"https://bugs.rockylinux.org/\" ROCKY_SUPPORT_PRODUCT=\"Rocky Linux\" ROCKY_SUPPORT_PRODUCT_VERSION=\"8\" [root@localhost ~]# cat /etc/centos-release Rocky Linux release 8.5 (Green Obsidian) [root@localhost ~]# cat /etc/redhat-release Rocky Linux release 8.5 (Green Obsidian) [root@localhost ~]# cat /etc/rocky-release Rocky Linux release 8.5 (Green Obsidian) [18:27:16 root@pyConsole ~]#lsb_release -a bash: lsb_release: command not found... Install package 'redhat-lsb-core' to provide command 'lsb_release'? [N/y] y * Waiting in queue... * Loading list of packages.... Failed to install packages: Could not depsolve transaction; 1 problem detected: Problem: conflicting requests - nothing provides ncurses-compat-libs(x86-64) needed by redhat-lsb-core-4.1-47.el8.x86_64 [18:27:22 root@pyConsole ~]#cat /etc/centos-release CentOS Linux release 8.2.2004 (Core) 2、看内核 uname -r 3、关闭GUI，free可见 700M+的内存使用量，关闭前后的内存使用对比，init 3 关闭GUI，进入纯字符界面。再来看free 还剩200M+，一下500M的量省了。linux的图形界面相当于linux的一个软件可以开关。 5、runlevel 可见 5 3，说明之前是5模式切换到3的。 6、init 5如果你有图形的话，可以切回去。 7、who 不仅看当前登入的人 who -r可见这用户用的哪个运行模式，如果上一次是其他模式，也有last关键字看到 基础cli-1 1、root也不一定就是管理员，这是由UID的设置来影响的，UID=0就是超级用户 也就是管理员。 2、id 就能看到，id -u 显示当前用户的uid，id -u xx 显示xx用户的uid（从1000开始的） 3、centos6 新建用户默认从500开始，centos7和ubuntu默认冲1000开始 4、1000或500以内是特殊保留的数字 5、xx账号的uid改成0，xx就是超级用户了。 6、ll /dev/console 救援模式用的就是console终端，一般用不到 7、cat /etc/shells 可见目前支持的shell类型，在ubuntu上支持的并不相同。 8、/sbin/nologin 是一个特殊shell，禁止登入，当用户使用这种类型的shell的时候，就是不能登入的，软件运行的时候是后台运行的，但是不需要用户登入就能运行的。nologin其实就是无需登入就能运行的意思。 9、主机名：bj-yz-k8s-node1-100-10.XXX.com，北京亦庄k8snode1节点X.X.100.10.域名 10、echo $PS1 可见默认值，\\u就是用户名 \\h主机名 \\w当前目录 ，可以加上颜色 11、字体颜色 31-37 7种颜色，背景颜色 41-47 也是7种颜色 ， 1和5 就是亮色和闪烁。 PS1=\"[\\u@\\h \\W]$\" 这是默认值 PS1=\"[\\e[1;5;41;33m][\\u@\\h \\W]\\$[\\e[0m]\" PS1=\"[\\e[1;32m][[\\e[0m]\\t [\\e[1;33m]\\u[\\e[36m]@\\h[\\e[1;31m] \\W[\\e[1;32m]][\\e[0m]\\$\" 12、配置文件のPS1，ls /etc/profile.d/xx.sh 名字无所谓后缀要求是sh。 13、ubuntu切root, sudo -i 输入当前用户的口令就行了。 14、centos的PS1配置文件可以放在/etc/profile.d/xx.sh 或者和ubuntu一样放到/etc/profile文件下，unbutnu实在~/.profile，在每个账号的家目录下。 15、/etc/profile是统一的配置文件，这个文件影响范围大，配置要小心。 16、sleep 10，然后看pstree -p可以看到bash下面有一个sleep 17、还有很多程序不依赖于bash，不需要和人进行交互，后台直接运行了。 18、shell自身提供的内部命令、非shell自身提供的，磁盘上其他程序 19、bash里面集成了很多工具，就是内部命令，bash运行了，这些内部命令是加载到了内存中的。 20、cat /etc/profile.d/env.sh，这个cat就是bin下的cat cat就不是bash下内部命令了。是独立的二进制程序，这就是外部命令。 21、外部命令需要找到磁盘的存放路径，内部命令不需要会开机加载到内存中的 22、type用来查看命令是内部还是外部。 23、内部命令是集成在shell中的，而shell用户一登入就加载到内存里了；而外部命令表现为磁盘上的某个文件，所以内部命令速度更快。 24、如果有一个命令即使内部命令又是外部命令，那么内部命令优先生效，比如echo 当执行echo命令的时候，系统自动选择第一个内部命令。 25、为啥有一个内部命令了，还需要一个外部命令存在呢？因为内部命令是存在某个特定shell里的，echo在bash里，但是不一定在csh等其他shell里，所以需要外部命令来保证命令的普遍适用性。 26、切换shell 27、help可以列出所有内部命令的帮助。不多 28、外部命令就多了，表现为磁盘文件，ls /bin/ 或ls/sbin/ 29、enable会列出所有内部命令的列表 enable -n echo禁用echo后，echo就只有外部命令了，就表现为磁盘文件了，所以如上图。 禁用后，就看不到echo了 help里还可以看到一个*号 enable echo就再次启用了 30、enable -n enable enable enable不可能了，因为enable已经禁用了，退出重进就行了，或新开一个终端。 31、which专用用来查看文件的路径，自然可以查看外部命令了（外部命令就是磁盘的一个二进制bin文件） 32、bc了解一下 obase=2输出为二进制或10进制 ibase=2输入为二进制，默认都是obase=10，ibase=10. 32、whereis不仅仅显示文件（外部命令）的存放路径，还显示了相关文档帮助也显示出来了， 这是man帮助 33、外部命令，系统是怎么找到的，PATH变量了解一下 PATH变量就是存放了一个个文件夹， 1、当你输入一个命令，系统首先判断是否有别名，是执行，不是继续。 2、如果是内部命令，执行，如果不是，继续 3、如果是外部命令，就搜索PATH变量里的路径。前面的目录找到了，后面就不会找了。 4、其实也不是每次执行外部命令，都搜一遍PATH变量的路径的。为了加快访问速度，比如有一个文件我经常访问，linux就会将其缓存在内存中，因为内存中已经有了，就直接在内存中访问就行了。这也是linux的一个经常的思路。这就是所谓的缓存技术。 5、第一次执行hostname的时候，会按PATH变量里的路径来搜，一旦找到后，就会把hostname的路径缓存在内存里HASHE。下次执行hostname的时候，先从内存的HASH表里去搜索，如果查到内存中有这个路径，就不按照PATH变量搜索了，直接按HASH的记录的上次缓存的路径直接去到那个路径找到hostname文件去执行。 6、这里面还有一个细节，就是除了HASH，其实还有一个HASH对应的明文（路径的明文），这个一般不会给你讲这么细，网工会有这个思路可能。 7、这样的一个漏洞或缺点就是，如果外部命令hostname被移动了，那么HASH缓存的路径就不对了，这样命令执行就会报错。如下图 图示为hash记录的上一次hostname的路径。 再移回去就可以了， 疑点：我明明移动的是/bin/hostname而不是/user/bin/hostname，为啥一个效果！ 因为bin就是/usr/bin的快捷方式-软连接，所以一回事了。 再来一遍完整的： 8、上面的也可以不将外部命令移回去，可以清一下缓存就行了。 hash -d hostname 就行了 hash -r 全删 删掉了后，由于缓存没了，所以就会重新搜索，然后再次hash缓存到内存中了。 9、上面就意味着，自己做的程序，就要放到PATH变量里的路径或加一个新路径。 基础cli-2 1、内部命令和外部命令的本质区别，首先都会放入内存中的，本质区别是，内部命令在shell（bin/bash）二进制文件中；外部命令不在二进制文件里，是独立的文件。还一个内存方面一个是登入加载，一个是首次运行加载。 内外之分在于是否在/bin/bash文件里，在就是内部，不在就是外部。 2、问题：内部命令放在/bin/bash下，那么外部命令放在哪？首先放哪都行，关键是外部命令要运行，就得保证PATH变量里有该路径，然后规范行为是，外部命令放到PATH变量下的路径里去。所以外部命令一般来讲就在PATH下。 3、除了内部命令和外部命令，还有别名。 alias cdnet=\"cd /etc/sysconfig/network-scripts/\" 退出后失效，要想存住，就要将其放到文件里，别名的文件在家目录里的.bashrc里 重新登入后依然有效 4、alias列出所有别名，unalias cdnet可以临时删掉，但由于之前写在了配置文件里，所以重新登入后，还是没删掉 还在。所以配置文件的需要进配置文件删除 5、如果有一个字符串，既是 别名、又是内部命令、还是外部命令，那么执行的顺序是什么，这就是命令的执行优先级问题。 以echo（这个即使内部又是外部命令）为例，将其定义成别名，进行测试 说明，别名优先 总结：命令的执行顺序： ①首先判断是否是别名，如果是别名，别名是在内存中定义的，所以直接就执行了。所谓直接就是指已经在内存中了，不像外部命令那样首次执行还需要在PATH变量里进行查找。 助记词alias别名 ②其次，如果不是别名，判读是否是内部命令，如果是，直接执行内部命令（因为内部命令是内置在shell中的，用户登入就已经加载到内存中了）， 助记词 内部命令 ③最后，如果既不是别名也不是内部命令，那就按外部命令处理，就会看HASH表（表里记录了已经被执行过了外部命令的路径），如果HASH表里有该命令，就按表内记录的路径去搜索该外部命令去执行；如果HASH表里没有，就在PATH变量里查找，找到后执行。当然所谓执行也是加载到内存中执行的。对于首次运行的外部命令，也会产生的新的HASH表项。 助记词 外部命令（hash $PATH变量） ④如果找不着，就报错，此命令不存在。 PS：缓存为王，如果想提供一个慢速设备上（比如硬盘）的数据的执行效率，就把它放到内存里，下次从内存访问，速度就提升了。外部命令就是该逻辑思想。后面还有很多次这种套路。 6、加别名用~/.bashrc，这是只针对当前用户有效，家目录嘛，肯定的了。 对所有用户有效是编辑/etc/bashrc 7、别名修改后使之生效的方法，这也是很多配置文件修改后使其生效的通用方法： source /path/to/config_file #就是source 后跟你的配置文件路径 . /path/to/config_file # 就是. 后跟配置文件全路径 比如 . ~/.bashrc 比如： 8、之前的echo既是别名又是内部命令还是外部命令，如何不执行默认的别名优先呢， \\ 和 ‘ 以及 “ 或者 路径 再次command都是可以的 9、命令的格式，COMMAND [OPTIONS…] [ARGUMENTS…] 这点可以联系网络设备的cli 以及python argparse 自定义命令的格式或者规范问题。 -c 这种短选项，以及bsd风格的只有c没有-的用法，freeBSD这种好像cisco的wsa esa底层是这个。 ls -l 这个l就没有长格式 很多命令使用风格已经变了 可以理解成多层子命令的嵌套 10、ctrl+d 是正常退出 sleep 100就不能ctrl+d正常退出，得用ctrl+c强行退出。 11、ctrl+z 12、多个命令写在一行里用分号隔开 上图就是命令太长后认为换行用的。比如pycharm里面也是这么玩的。不过pycharm后来新版本直接回车也没有\\了，也能实现一套命令认为换行的效果。 13、date 系统时间：有软件操系统内核维护，通过CPU的工作频率维护的，date查看 硬件时间：主板上的CMOS，有块小电池（银币状）可供电5年。clock查看 timedatectl 看的最全 clock -s 将system time改一下，改成硬件时间 clock -w 将hardware time改一下，改成系统时间。 date -s ‘20200101 12:02:01’ 系统时间和硬件时间 或者date 010101012008.01 缺点就是看着乱七八糟，优点就是不用写引号便于python调用时的字符串拼接入库啥的。 上图GMT+8 14、时间其实内部一般用NTP去同步的 这里我先停掉ntpd服务，再去同步时间就好了 注意，ntp只会同步系统时间，不会同步硬件时间。 如果硬件时间不对，就先ntp保证系统时间准确后，再clock -w让硬件时间去同步系统时间就可以了。 15、ntp后面细讲，如果企业里时间不同步，涉及加密、集群就会出问题。 16、查看隐藏文件的方法 推荐第一种 l. -l ll -ad .* ll -a |grep -E \" \\.\" a alias b basename bc c cal 9 1752 chkconfig iptables off cd command clock(hwclock) cat /etc/rehat-release /proc/maminfo /proc/partitions d dir类似ls dirname df du date e enable enable -n exit echo f free -h g getenforce disabled h hexdump -C halt history hostname help hash i iptables -vnL init 3字符模式 5图形 0是关机 6是重启 info ifconfig id j k l lsblk logout ls lsb_release -a lshw m mount /dev/sr0 /mnt挂光盘到/mnt下 man mv mandb n ntpdate o p ps pwd poweroff ping pstree q r rpm -ivh rm rz runlevel查看当前运行模式的 s systemctl disable firewalld stat shutdown screen sleep source(.) sz sudo -i t touch tty 看在哪个终端里 type u uname -r unalias v vdir类似ll w which whereis whoami who -r whatis x xxd 等价于hexdump -C y z rz后再按esc可以产生如下图效果，并排两个提示符😶 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"2-linux基础和帮助/4-linux帮助用法.html":{"url":"2-linux基础和帮助/4-linux帮助用法.html","title":"第4节 linux帮助用法","keywords":"","body":"第4节. linux帮助用法 查看帮助相关整理 帮助有这些 whatis command –help -h man and info /usr/share/doc Red Hat documentation 其他网站和搜索 whatis是外部命令，是用来告诉你去找man手册第几页的 以及 该命令的简要说明 如果系统是刚刚装好，whatis是没有结果的，就会出现如下提示，我就不还原系统了。 whatis数据库存放的帮助的简要说明，在刚装好操作系统是没有的，是需要过一会自动生成。如果你不想等，只需要执行 centos6上 makewhatis centos7上 mandb 这样就能生成whatis数据库了。 whatis只是简单说明，详细用法还得参考其他帮助 -----------↓-----Unicode字符集和UTF-8编码--------↓----------- 1、有关文件类型 cat是查看文本文件的，二进制文件看不了，常见的二进制文件有：图片、视频、可执行文件，bash也是 2、二进制的怎么看，二进制太长了，一般就是以16进制形式查看。 hexdump /bin/bash hexdump -C /bin/bash 在linux保存处理都是二进制的，上图的A就是41这个十六进制对应的二进制进行存放在磁盘上的。 阔以的，这排版都得倒一下的~ 3、这些英文或者汉字对应的都有二进制表示的，这种就需要编码表来实现。ASCII就是早期著名的编码表。ASCII（American Standard Code for Information Interchange） 4、ASCII只能表达128个字符，只适用于欧美国家，后来就有了GB2312、GBK我国自己的编码表，以及还有韩国自己的。每个国家的编码都不一样。可能存在都是55这个十六进制，代表的字符不一样，这就产生了冲突。为了统一，就有了统一命令的Unicode， 5、Unicode只是一个规范，定义了全球所有文字或者叫字符和二进制的对应关系。它并没有明确下来这个二进制在磁盘上保存到底是什么形式（用哪种风格）并没有确定下来，比如具体这个二进制在磁盘上占几位，Unicode就没有明确下来，为了具体明确下来（磁盘上存放某个字符占多少位、在网络上传输的时候转成二进制占多少位）就推出了编码的具体实现—比如UTF-8，UTF-8就是Unicode的具体实现。 6、Unicode属于字符集（字符和二进制的对应关系）、UTF-8是编码方式（站位的明确定义）。还有UTF-16和UTF-32，UTF-8使用的最多。 UTF-16用2个或4个字节来表示某个字符。工作中，用得少 UTF-32，所有的文字全都占4个字节。工作中，用的少 UTF-8，使用1-4个字节来表示字符。比如UTF-8兼容ASCII码就是一个字节就够了。生僻字3个或4个字节，常用文字占1-2个字节。 7、Unicode（UTF-8）处理的逻辑机制是这样的，我们vim或nano处理某个文件的时候，在编辑的时候，vim是个软件，自然会在内存中运行这个vim程序。vim打开比如xx.txt这个文件，就会把xx.txt里的字符就转化成了Unicode。你在xx.txt里就可以编辑修改，此时注意这些字符都是在内存中以Unicode形式存在的，当然显示的时候是转换成人类看懂的文字的（这是计算机内部处理的）。 然后你一旦保存，就是存到磁盘上去了，保存到磁盘上就表现为具体编码形式UTF-8了。 后面你再次读xx.txt文件的时候，就是读入内存中，那么此文件在内存中又是以Unicode形式存在的。 8、在网络传输的过程中，PC----请求----Server。比如PC请求http://www.xx.com/index.html, 这个文件在server的磁盘上保存时UTF-8形式，读取到server自己的内存中就是unicode，在网络上传输就是UTF-8，读取到PC处的内存就是unicode，存到PC本地的磁盘就是UTF-8了。当然我记得还有一个BASE64，也需要了解一下。在加密数据的时候就有先使用对称加密后在使用BASE64进行网络传输的，图片在网络传输也是使用BASE64的。 ---------------------↑---------帮助的用法-------------↑------------------------ 9、命令帮助，内部命令和外部命令的help是不一样的 内部命令：help COMMAND 或 man bash 只要是内部命令，都可以通过man bash查看，（当然man也可以看外部命令） 因为/bin/bash文件里集成了所有内部命令，所有man bash就能看到所有内部命令的详细帮助。 bash的man手册有4000多行，有人对其进行了翻译，就是普通学员做了这个事。当然网上也有人汉化也可以参考。 外部命令帮助用法： ①COMMAND -help -h ②man COMMAND ③info COMMAND ④README INSTALL ChangeLog这些程序自身的帮助文档 ⑤程序官方文档 也就是官网的Documentation ⑥发行版的官方文档 ⑦Google bing baidu等搜索引擎 [OPTIONS]...就是选项可以有多个，FORMAT就是在下面列出了很多的FORMAT 10、date 1970-1-1是Unix诞生日 11、显示前天是周几 date 010210102020.300 unix的诞生日，很多时间计算都是从这个点开始的，比如 显示前天周几 12、man手册 manual的意思，利用man可以查看很多外部命令的帮助 上图whereis列出了man帮助的文档。gz压缩文档，不用解压后查看，直接用man命令查看即可。 13、man对应的文档基本都是放在/usr/share/man下的。 man1：linux命令基本都在第1章，是我们常常需要的； man2：系统调用，OS对 外部APP提供内核调用的接口，开发用的；就是应用程序需要和操作系统内核打交道，就得系统调用来完成，在第二章里。man socket 一般看到的就是man 2，属于网络方面的系统调用。不过为啥我的腾讯云上的VPS默认是man3的socket。另外就算是开发也不会直接进行这种底层调用，一般也是通过C库或者python库去调用。 man3：C库调用 man4：设备文件及特殊文件 man5：配置文件格式，也是我们关心的，linux好多配置文件，配置文件有很多格式，这些说明就在第5章里。 这个issu文件怎么配置，他的帮助就在第5章里。然而VPS上并没有 换成我自己的vm虚机就有了 应该VPS是最小化安装，当然也不是都没有，最小化安装man ls，man bash都有的。 man6：游戏 man7：杂项 man8：管理类的命令，管理员，root身份进行一些管理型的命令。 man9：和开发相关的linux内核API。 14、man使用注意点 man xx 默认看的是man1，1以外的章节 需要特别指定第几章才行。比如passwd这个文件配置说明。 /etc/passwd是个文件，/usr/bin/passwd是个命令，这两个passwd不是同一个东西。 显然whatis查看的不仅仅是命令，而type只是查看命令是内部 还是外部 亦或是alias。 man passwd看的是第1章，看的是passwd命令（/usr/bin/passwd） 如果要/etc/passwd配置文件帮助，就需要：man 5 passwd 总之，先whatis xxx看一下在那一章节，然后man n xx去看 man也是个外部命令，可以用whatis去看一下有哪些章。 1p都是和开发相关的。 man man可见 15、man搜索和vim搜索一样 或者 ”?second”，n 和 N是下一个或者上一个。方向键上下，一样调用历史记录。 man -a 查看所有，q+enter进入下一章 man -k passwd查看包含passwd的帮助类似whatis passwd，但明显要比whatis passwd多得多。 man -f passwd 等价于whatis passwd man -w date查看帮助文件在磁盘的路径，类似whereis date，区别在于man只是看man手册在哪，而whereis date还显示命令（文件）的路径。 16、man举例 \\S就是OS版本 Kernel就是Kernel \\r内部版本 \\m X86架构 这个issue就定了用户登入提示信息。 现在需要：显示用户在哪个终端登入上来的，（原本是tty查看的），还要显示时间、显示主机名，此时就需要查看帮助 说明了issue只有第5章有，是预登入和标识文件。 直接man issue就行了，因为只有1个 第5章 上图是man issue的所有信息了（就这么多行，到底了），其中并没有看到什么\\S \\r \\m的解释 不过有一个SEE ALSO可以参考 于是man motd 我们issue是登入之前，而motd是登入之后，不是此时需要的帮助，换一个 man 8 agetty 都找到了 再来对比一下 都找到出处了, welcome…是自己加的 修改为： ​ 17、linux的语言默认是英文，不建议转成中文，但是可以转，如下 有些地方就是中文了 但是man里面还是英文的， 还需要安装如下的中文的包 才能在man手册中显示为中文。 安装的话，我准备使用本地安装光盘里找一找相关软件包，所以不适用VPS了，换成本地CENTOS7 上图表示现在光盘没有挂载，可是我已经在WmwareWorkstation上勾选了connect了。此时只需要在GUI界面上使用和cli同样的账号，此时是root，登入一下就行了 进到光盘的路径下，里面就是所有的安装的软件文件，而且后缀都是.rpm。找到man开头的 发现了zh-CN的中文包了，这个就是可以修改man手册里的中文的包。 使用rpm -ivh 安装，注意ls man按tab补全后ctrl a切换到头将ls改为rpm -ivh，因为rpm 不带自动补全功能 此时在修改一下LANG，localectl set-locale LANG=zh_CN.UTF-8，退出再登入，然后就可以看到man手册里的中文了 但是man 1 passwd就是命令的帮助手册还是英文的 说明中文支持的还不是非常全。不过只是了解一下怎么切中文，一般也不会切的。 所以，切回英文 localectl set-locale LANG=en_US.UTF-8。 18、info 命令一般不用，不过info里面的都是一个个链接，更像是一个网页，是*号开头的，按回车就会跳转，挺有意思的，了解一下，比如info ls 光标停在*号行，按回车，就会跳转 19、man帮助使用较多，info基本不用，此外还有一些不怎么用的帮助，了解一下 GUI里的Applications\\help里面点开可以查看的，这是CentOS7的。CentOS6实在GUI的system/help下。 20、不怎么用帮助之/usr/share/doc 每一个安装好的软件包，都有一个对应的文件夹放在/usr/share/doc下，你可以进去查看软件的说明。 这些文档大部分都是文本，PDF\\HTML\\TXT 都能打开看基本上。 21、linxu只是一个操作系统，常规操作掌握后，更多精力是放在linux系统之上的应用程序—这些第三方软件（apache、nginx、mariadb等），这些软件就要去官方网站查看文档。 第三方应用官方文档举例 http://httpd.apache.org http://www.nginx.org https://mariadb.com/kb/en https://dev.mysql.com/doc http://tomcat.apache.org http://www.python.org 点击documentation后，可以看到 这个软件有很多moduels模块组成，其中有core模块，点击进去可以看看该模块里的各个指令directives。 点击root命令 要学会看懂这里面的说明，因为官方文档才是最权威的一手资料。 22、现在还没进入都linux上层应用的学习阶段，现在还是在学习操作系统本身，系统本身也有官方网站以及documentation的。 红帽知识库和官方在线文档 http://kbase.redhat.com http://www.redhat.com/docs http://access.redhat.com https://help.ubuntu.com/lts/serverguide/index.html 比如现在需要看centos8的安装指南 http://www.redhat.com 如图就找到了CentOS8的安装手册，有升级的、基本安装、定制化、高级安装（kickstat自动化安装），而且右边栏还可以选择查看的文档格式（pdf or web） 23、搜索引擎 http://tldp.org http://www.slideshare.net # 这网站是很多国外的人在研究技术的时候写成了PPT，可以拿下来改吧改吧。 http://www.google.com 搜索的技巧 https://segmentfault.com/a/1190000038432191 https://funletu.com/12851/.html openstack filetype:pdf rhca site:redhat.com/docs #这种站内搜索，受限于对方的安全措施，应该叫反爬机制 https://www.ibm.com/developerworks/cn/linux/index.html 要知道IBM已经收购红帽了，所以该网站也是阔以的。 24、帮助举例 ASCII 字符集 在编码的时候使用 八进制、十进制、十六进制。 然后，man ascii ASCII码总共128个字符，每个字符对应的八进制、十进制、十六进制分别是什么，分两列展示。 想用echo一下ascii，不知道怎么玩，可以man echo在搜oct就行了 所以echo -e “\\0xxx”还有echo-e “\\x21” 25、ascii查看举例 \\x0a是十六进制的，是不分大小写的 26、\\r和\\n 这是\\r的回车return的效果，没有换行，所以还在本行，就会把之前的xxx覆盖了前两位。 这是换行+回车的效果，linux的\\n就是微软的\\r\\n linux也认\\r是回车的意思，所以\\r就是回车、\\n就是换行在回车，这里两个回车了，效果还是把车停到了最左边，就是100个\\r也就是1个\\r的效果，一个\\r也被集成在\\n里了。 所以，在python使用paramiko非交互模式获取H3C的dis cu inter | I inter后，详情如下 如果上图re.split处这么写：portPer1.split(‘\\n’)，在print(i)的时候你会看到显示都是OK的，但是一旦将这些i传入list里后，就会出现xxx\\r\\r如下情况： 此处需补图，回公司才有环境，还得自己整一个网络环境出来，用eve吧明天搞。 所以H3C的display 看到的分行，其实里面是xxx\\r\\r\\n，我猜它这么做为了，为了个屁，就是强迫症，多次回车保证车必然停在最右边，然后\\n换行，所以我改成了re.plit(xxx)如上图。 27、对比一下MS和Linxu的\\r\\n 我们已经知道\\r\\n是MS的换行，\\n是linux的换行，这里说换行自然就包含了回车了。 下面看实验 传到桌面，在打开 可见linux的\\n到MS里是没问题的，结论MS兼容\\n 反过来，来一波 在windows新建f2.txt 使用rz传到linux里或直接拖进去 carriage return简写了 结论 MS的\\r\\n到linux下linux只需要\\n就能进行换行回车，所以多了一个\\r，当然cat的时候是看不到的，或者说python处理的时候可能print也是看不到的，但是\\r确实留在了文本里面，确实会为后面的数据处理带来麻烦的。 相对的，linux下的\\n到了MS里，MS处理的就很好，奇了怪了。我明明记得很多txt文本在windows里看到的都是xxxx\\nxxxx\\nxxxx\\n不换行的格式错乱啊，难道是sz工具对其进行处理了？ 尝试不使用sz工具，而是用sftp进行linxu->ms的文件传输，结果一样还是MS里显示OK。 尝试不用echo -e \"ABC\\nabc\" > f1.txt的方法创建内容，而是使用vim 依然在MS里显示OK，好了此问题不研究了。MS你优秀~ 我明明小写abc后面在linux里就没有换行，传过来结果换行了。 方法论：在文本处理的时候，文本从linux->MS，\\n前加上\\r；从ms->linux，\\r\\n去掉\\r。 以上就说明了：二进制在磁盘上保存机制不同，不可见的符号是看不到的，但是在磁盘上保存确实有的。 xxd和hexdump -C一样的效果，专门看不可见字符。 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"2-linux基础和帮助/5-linux入门命令.html":{"url":"2-linux基础和帮助/5-linux入门命令.html","title":"第5节 linux入门命令","keywords":"","body":"第5节. linux入门命令 1、localectl list-locales查看所支持的语言 [11:45:53 root@localhost ~]#localectl list-locales | grep ^en_US en_US en_US.iso88591 en_US.iso885915 en_US.utf8 [11:46:02 root@localhost ~]# [11:46:02 root@localhost ~]#localectl set-locale LANG=en_US.utf8 这是界面风格是英文，不是说不支持中文，因为UTF-8全球语言都支持，之前的文章也讲过UTF-8是unicode全球文职字符集的编码格式。 2、时区文件/etc/localtime 这个时区文件Shanghai也是个二进制文件 3、timedatectl list-timezones 4、cal显示日历 -h看一下就好 [11:49:22 root@localhost ~]#cal 9 1752 September 1752 Su Mo Tu We Th Fr Sa 1 2 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 5、halt，poweroff，reboot，shutdown 关机：halt,poweroff 重启：reboot ​ -f: 强制，不调用shutdown ​ -p: 切断电源 关机或重启：shutdown shutdown [OPTION]... [TIME] [MESSAGE] -r: reboot -h: halt -c: cancel TIME: 不指定，默认就是+1（CentOS7），相对当前时间过一分钟后执行相关动作 ​ now: 立刻关机，等于+0; ​ +m: 例如+3，表示3分钟后； ​ hh:mm: 绝对时间表示，特定时间执行相关动作。 哈哈哈，shtudown -h查看帮助？想当然了，小心误操作哦。 [11:50:25 root@localhost ~]#shutdown Shutdown scheduled for Fri 2022-01-07 11:53:15 CST, use 'shutdown -c' to cancel. [11:52:15 root@localhost ~]#shutdown -c [11:52:22 root@localhost ~]# [11:52:36 root@localhost ~]#shutdown -h Shutdown scheduled for Fri 2022-01-07 11:53:38 CST, use 'shutdown -c' to cancel. [11:52:38 root@localhost ~]#shutdown -c [11:52:41 root@localhost ~]# 6、windows也有shutdown命令 1小时后关机 取消 还支持远程关机 7、who 和 who am I 以及w who，当前有哪些用户登入上来 who am I 或who x x只看当前用户 w 显示谁在登入，运行了那些程序 有点监控的意思了,并没有。 8、screen的用法 虚拟多个屏幕用 首先找到光盘进行安装，当然也用直接yum VmwareWorkstation 连接光盘后，使用非GUI界面相同账号登入(这里是root)，即可完成挂载光盘。哈哈，就这么挂，怎么滴~，当然我现在是mini没GUI。 rpm有tab自动补齐啊，上次怎么没有呢，不管了。 举例1：防止ssh断开导致ping或tftp断开 如果ping着的时候，关闭ssh窗口，ping就停了，证明方法ps aux |grep ping 问题就来了，如果我在备份数据的时候，ssh断了，那备份就失败了，所以screen有用武之地了。 screen -S ming # 创建ming命名的新的屏幕 screen -ls # 查看开启的屏幕有哪些 screen -r ming 进入ming命名的屏幕 举例2：屏幕协助 screen -S ming # A开启一个屏幕 screen -x ming # B进入这个屏幕，此时两个人就共享一个屏幕了。 screen -x ming # C同样可以可以进入该屏幕，此时就三个人共享一个屏幕了，那么问题来了上限是多少人呢？没兴趣知道。哈哈 ctrl+a+d # 注意手法，不能先按ctrl+d，因为ctrl+d是退出的快捷键（等价于exit）；临时剥离该屏幕，但是其他共享屏幕的人看不到的，此时可以干一些不想共享给别人知道的事，然后完了再screen -x ming切回去，就有成了大家共享一个屏幕的情况了。 exit # 一人退出共享屏幕，全部菜单都退出了。 9、echo，回显用 尝试使用帮助看echo，①type echo 发下是内部命令，②所以使用help echo看帮助 [root@centos7 ~]# type echo echo is a shell builtin [root@centos7 ~]# help echo echo: echo [-neE] [arg ...] Write arguments to the standard output. Display the ARGs on the standard output followed by a newline. Options: -n do not append a newline -e enable interpretation of the following backslash escapes -E explicitly suppress interpretation of backslash escapes `echo' interprets the following backslash-escaped characters: \\a alert (bell) \\b backspace \\c suppress further output \\e escape character \\f form feed \\n new line \\r carriage return \\t horizontal tab \\v vertical tab \\\\ backslash \\0nnn the character whose ASCII code is NNN (octal). NNN can be 0 to 3 octal digits \\xHH the eight-bit character whose value is HH (hexadecimal). HH can be one or two hex digits Exit Status: Returns success unless a write error occurs. 功能：显示字符 语法：echo [-neE][字符串] 说明：echo会将输入的字符串送往标准输出，输出的字符串间以空白字符隔开，并在最后加上换行符。 选项： ​ -E （默认）不支持\\解释功能，也就是\\的转义功能； ​ -e 启动\\解释功能，也就是启动转义； ​ -n 不自动换行，类似python的print(‘xxx’,end=’’) 显示变量的值 ​ echo “$VAR_NAME” # 显示变量的值 ​ echo ‘$VAR_NAME’ # 这里讲的其实不是echo的事情了，是引号的用法，单引号就是里面都是原封不动的字符串，不会给你查找变量或命令的。 单引号，最笨，里面是什么就是什么 双引号，普通，里面的变量能够解释出来，里面的命令不识别 原样输出； 反向单引号，最聪明，里面的变量、命令，统统给你识别并解释运行个结果出来。 echo只是结合echo来回显而已。 举个栗子 echo -e “\\a” # 可以发出声音，一般用在代码跑完后滴一声提示。 注意这个linux是在远端PC上，不是本地，但是声音却是本地声音 10、echo显示颜色 echo -e '\\033[43;31;5mICE\\e[0m' 前景颜色43、背景颜色31、5是闪烁‘ 注意43和31位置互换效果一样的，看的其实是4X就是背景色、3X就是字体色 注意\\e也就是\\033前后都有。颜色数字顺序不重要，然后上图是大家喜爱的红配绿。 1m的1是亮色 注意\\033等价于\\e linux里很多信息都是带颜色的，比如 我们自己也可以做出该效果 比如echo： 上图是1是加亮，下图5是闪烁 将来shell脚本，需要屏幕上显示一些东西带颜色，就这么玩。 11、一些编码转换和查询 之前一篇说过字符集和编码也就是unicode和UTF-8的事情，下面是工具网站 http://www.chi2ko.com/tool/CJK.htm https://javawind.net/tools/native2ascii.jsp?action=transform http://tool.oschina.net/encode 类似的网站 12、命令行扩展、被括起来的集合 很多时候会用到3种引号 ‘’ 单引号 “” 双引号 `` 反向单引号 等价于 $() 注意凡是在word或execl中的引号不能直接复制到linux或python里运行，不管你是否是英文的，复制过去就是不对，基本上需要重新键入引号。后面才知道word本身可以设置引号为英文的，这样就可以统一了。 花括号 echo file {1,3,5} rm -f file{1,3,5} echo {1..10} echo {a..z} echo {000..20..2} 花括号里面的就是选择或者递增的关系，花括号外面的_是必然有的。 批量创建文件、用户等。 双引号、单引号、反向单引号，针对不同的场景，作用不同， 针对echo的，针对shell编程的，不同应用地方的作用是不同的。 1、引号在echo处的作用 单引号：里面全是字符串，他大舅他二舅都是他舅。 反向单引号：能识别里面的命令和变量。 双引号：不能识别里面的命令，只能识别里面的变量。 2、一个命令调用另一个命令的结构的时候，经常使用反向单引号。 问题来了 data后面的要引起来，所改成双引号，但是问题如下 结合下图 结论date ‘+%F %T’得到的是两个值，所以touch的时候才会创建两个文件 都是空格惹的祸 所以最终的方法如下 结论：touch创建一个文件的时候不能带空格，有了就是两个文件了。上面的’+%F_T’可以不用引号了，因为本身就是一个整体了。 但文件名应该可以带空格的，虽然不太好，windows就是 3、反向单引号和$()是等价的 结论：反向单引号作为一个单元在其他引号内部出现，不影响效果。 所以上面的也可以这么写 4、每晚12点01分执行备份日志等操作，并保存为前一天的时间 5、tab补全 命令补全（命令的option也是可以补全的，按两下tab会出来一推） 路径补全 文件补全 虽然没神马用。 6、命令行历史 linux输入的每个命令默认都是有历史记录的，除非在键入命令的时候加入特别选项（也很方便做到）。 这些输入的命令记录会放在内存的缓存区里。内存里有一个历史列表，存放了输入的这些命令。 突然断电，或者直接关闭xshell，这些记录就有可能没了，可能就没写到.bash_history文件里。 一般系统会自动保存到文件里， history的ctrl r快速搜 上图的操作为：!然后按ctrl r，输入echo，就会从history里找到最近的一次包含echo的命令，我经常用来做snmpwalk -v -2c xxx 10.1.1.1 .1.3.6.1 x.x.x.x.x 这种历史的调用。 这是包含，下面的水以什么开头的最近的一次历史命令 下面是包含什么的最近的一次历史命令 10、把上一条命令的前面的换掉 11、上面的ctrl r修正一下 不需要输入history在按ctrl r直接ctrl r就行ctrl g是退出 12、非常实用的命令,把前一个命令的最后一个参数调出来 上面的!$调用比较方便，还有交互式下的快捷键可用来替代!$，比如 按esc松开不松开都可以再按. 或者按alt . 考虑到xshell的默认快捷键冲突，所以建议改一改，这么改就行 需要更加多样的调用，实际上!$是上一个命令的最后一个参数，!^是就是第一个参数，其他还有很多类似用法，但是我觉得没必要了，其他的不实用。 13、history命令选项用法继续 ①history会默认记录命令，现在考虑安全，可以清除历史 这个history -c是清楚的内存中的历史，而历史命令不仅仅是内存中有，还有磁盘文件也有。 但是这个文件放的是以前的历史命令。不是现在的几条。退出重进，发现echo passwordxxx确实不在，其实就是趁着内存中的命令还没自动放进./.bash_history里history -c直接就清掉了。 但是腾讯云上显然不是这样，应该是有了优化（内存中的命令会立刻存到.bash_history文件中的，如下图。） ①history会默认记录命令，现在考虑安全，可以清除历史 这个history -c是清楚的内存中的历史，而历史命令不仅仅是内存中有，还有磁盘文件也有。 而且腾讯云的VPS，内存里的命令清了，立即退出，重进，会发现命令还在的，说明内存和.bash_history磁盘文件是实时同步的。 为了确认一下，可以cat看一下 注意#1587828143这些是时间应该 上面写错了，不是腾讯云的优化，是这个原因： 我把历史命令前面的时间格式取消后，发现内存的命令不会自动同步进.bash_history了。 果然又再次秒同步了。 最后再验证一下 懵逼了， 终于知道什么因果关系了：将将将将~ 一般情况内存的命令不会实时同步进.bash_history文件里的。 想要实时同步，可以这么做，在history显示行首加上时间格式就能促使命令的实时存盘。 但是需要注意的事 即使注释了这行，还是会实时同步的，如下图， 但是如果你使用；去注释改行，那么 export HISTTIMEFORMAT=\"%F %T \" ①没有做时间格式的历史记录，但是命令实时同步进.bash_history ②做了时间格式，命令也是实时同步的 ③用#注释时间格式，命令还是实时同步的 ④用;号注释时间格式，命令就不再实时同步了。 什么鬼。。。睡觉 反正记着有办法让内存的命令实时同步就行了。方法之一就有上面的思路。 上面瞎折腾，靠谱的还是参考下面人家的 https://developer.aliyun.com/article/637427 14、history默认是1000条最近的记录 也可以在/etc/profile里写 退出重登，发现还是3000的历史记录，说明etc/bashrc优先 验证，去etc/bashrc下注释掉那行，退出重进，发现此时是10条记录了 history -d 36就是清第36条 怎么删除一个范围？ -a ，追加经磁盘文件 -r , 将历史文件的记录读到内存中的history记录下，默认用户登入的时候就会读取，执行该动作。 -w , 将当前的history内存记录存到指定文件中，比-a多了个路径，-a是默认的.bash_history 所以 -p 是不存在历史内存列表中，而且是将命令按空格展开成多行。 -s 是制造虚假的历史命令，实际未执行。 15、history命令历史的相关环境变量 HSITSIZE：命令历史的记录条数是内存中的记录条数 HISTFILE：指定历史文件，默认为~/.bash_history HISTFILESIZE：命令历史文件记录历史的条数，这个其实用HISTSIZE控制内存中的记录条数，就能控制文件的条数了，对了，默认HISTFILESIZE多大？也是1000条。 HISTTIMEFORMAT=”%F %T ”，显示时间，指定格式，也可以写到/etc/profile.d/env.sh下。PS1就是写在这个下面的 HISTIGNORE=”str1:str2*:...” 忽略str1命令，str2开头的历史命令。用法如下 安全敏感的不记录 HISTCONTROL：控制命令历史的记录方式，该环境变量的值如下： ​ ignoredups 默认值，忽略重复的命令，连续且相同的为“重复”.不过腾讯云主机是unset没有默认值的： 如图，不赘述 ​ ignorespace 忽略以空白开头的命令（类似HISIGNORE=”str1:str2*...”），如下图 ​ ignoreboth 相当于ignoredups,ignorespace的组合 ​ ​ erasedups 删除重复命令，不同于ignoredups(连续的相同命令只留一条随机的？)。erasedups是不连续的也删。 这些变量的赋值，上图是直接HISTCONTORL=XXX，这种不会保存在配置文件里，退出用户丢失。可以保存在/etc/profile或/etc/profile.d/env.sh或~/.bash_profile或/etc/bashrc，可以看看云主机的一些环境变量的保存路径，初步总结下来，只要大的路径对了，就行了，比如tab.vimrc不一定非要独立的文件的。感觉腾讯云这么做也无所谓规范不规范的。 16、快捷键 在xshell里没问题，但是在摸粑粑里有的不灵 ctrl + l 等价于clear清屏 ctrl + o 执行键入的命令，并重新显示出来，这玩意有延迟的，需要将命令打在屏幕上等一会，在按ctrl + o 才对，不让出来的命令是之前的 ctrl + s 锁屏，用来盲敲的 ctrl + q 解锁，恢复输入可见 crtl + c 强制退出 ctrl + d 规范退出，正常退出 ctrl + z 挂起命令 bg 恢复后就停不下来了，除非退出xshell。 fg 比较好，可以退出ctrl c ctrl z在挂起都行 17、一些有用的快捷键 ctrl+w，往前删除，一段一段的删，就是遇到空格就停下了 ctrl+k 和 ctrl+u相反，光标处删到行尾 alr+r 删除整行 和xshell冲突 ctrl + xx 光标在行首和当前位置切换 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"3-文件管理/3-文件管理.html":{"url":"3-文件管理/3-文件管理.html","title":"第三章 文件管理","keywords":"","body":"第三章 文件管理 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:38 "},"3-文件管理/1-文件系统.html":{"url":"3-文件管理/1-文件系统.html","title":"第1节 文件系统","keywords":"","body":"第1节. 文件系统 1、文件系统结构元素 就是文件目录结构， /boot 启动相关文件，例如内核 /etc 配置文件，比如之前的/etc/issue /etc/profile.d/ /etc/bashrc等 /dev 硬件设备 b开头，表示块， c开头，字符文件， 都是设备文件 tty，字符设备，是一个个字符来进行输入输出的 块设备，光盘、硬盘，是以一块一块为单位，而一块代表N个字节，比如4096Byte表示一块。如果是块设备，每次输入输出就是4Kbyte。一下子读入4K或写入4K。 比如硬盘分区都是BLOCK为单位， 比如issue该文件里面存放了点数据，如图才346byte，但是由于磁盘分区上保存数据是以块为单位的，哪怕你只是修改该文件1个字节，实际上读取的也是以块为单位的，所以 假设4KB一个block，那么，读动作 就是一下子读取4kbyte到内存中，改完了写入磁盘分区也是也是 4kbyte的空间站位。 总之，实际的数据量虽然不大，可能把这个数据写入、写出的时候，实际会大很多，就是这个意思。 2、/bin 给普通用户用的 /sbin给系统管理员用的 还有/usr/tmp 都是软连接， ll的细节注意一下 ls /bin和ls /bin/效果一样，都是现实/bin下的所有文件 # 这里还是要用ll -d去看文件夹，反正有些py模块里，文件夹就要用XX/来标识。实际操作需要验证一下的。（带不带/，要不要-d，之类的） ll /bin 和 ll /bin/不一样，前者是显示文件夹本身，后缀是显示该文件夹下的文件。 # 这话也是错的，因为/bin是个软连接，本身是文件。 ll /bin -d 和 ll /bin/ -d 不一样，虽然都是显示文件夹metaDate。前者是显示软连接的元数据，后缀是显示源文件的medaDate。 这两个都是等价的 这两个显然不同。 所以总结，看文件夹的信息，就是ll /bin -d，这样最靠谱。 靠谱的原因就是-d看起来是看文件夹，其实对文件一样有效。所以看文件本身不进入子层，正确的使用方法就是ll /bin -d ll / -d这种了。 上面仔细看图就好，其实还是软连接造成的操作上的细微区别。 3、/usr 下很多文件夹和/很像， /usr 像是个二层根。 结构是有规范的无论是什么linxu版本，都基本符合这一套目录结构。 FHS：Filesystem Hierarchy Standard http://www.pathname.com/fhs 文件要存放规矩 4、两个特殊目录/proc 和 /sys 这两个目录大小为0 虽然是0，但是在/proc下是可以看到数据的。 说明proc下有很多数据的，但是proc文件夹的大小就是0。这是因为proc看到的是内存中的数据，内存数据不占磁盘空间，所以ll /proc -d显示的是磁盘空间占用大小。 /sys 是映射的硬件信息 /proc是放进程process相关信息的 5、以/sys为例，可以用里面的一些文件来管理硬件 这里换本地的VM来做实验—增加新的硬盘 当前只有一块硬盘和一个光盘 现在要实现加硬盘不重启的效果，以VmwareWorkstation为例，直接在VM里添加即可(略)。 但是添加完了，一般需要重启才行。不过可以这样： 在/sys 此时就新加的硬盘就出现了，也不需要重启系统。 一般就是host2或host0就行。 可以考虑将上面的两条命令定义成别名 现在再加一块硬盘，就可以利用别名快捷实现了 6、linux文件名最长为255个字节，验证如下 创建一个256字符（一个字符对应一个字节？），利用ALT + NUMBER 在输入字符即可 按住alt不动，紧接着输入256，然后松开后输入x，这样就完成256个x的输入。 一个x字符对应的就是一个字节，UTF-8格式规定的。不信可以这么检查 vim test，里面写一个x，然后hexdump test -C 看一下： 再man一下ascii找到小写的x 确实是16进制的78，而16进制78就是一个字节的空间。 所以，touch xxxx...xx 256个x就是256个字节的长度了，验证方法有效。 7、包含路径在内文件名最长4095个字节。 蓝色-目录 绿色-可执行文件 红色-压缩文件 其实就是看后缀，系统一看后缀是.gz的就给你打上红色了 天蓝色-链接文件 灰色-其他文件 黄色-设备文件，有的是b块设备、有的是c字符设备。 ​ b的单位是块，是随机读写，不是顺序的，是随机的放在磁盘的某些位置。而c的单位是字符，是顺序一个个字符进行输入输出的。块设备通常是有缓存的，硬盘有缓存，而字符设备是没有缓存的，就按照顺序进行访问就行了。 粉色-socke文件，套接字文件，s开头的，是为了实现网络通讯的。后面讲mysql会用到。 /run下面又很多粉红色文件 棕色-管道文件，p开头的，是实现进程间通信的，就是同一台PC上的不同APP互访，用的不多，用socket用的比较多。 文件的颜色和后缀的关系，实在/etc/DIR_COLORS下定义的 看下一个pip40,33确实是棕色 试一下上图DIR_COLORS的效果 01,31就是红色没跑了 然后在试一下exe文件，默认是注释了的， 现在打开 还是没有变，不急，执行一下DIR_COLORS文件，执行不了，退出重进就行了 搞不懂为什么.bashrc可以. ~/bashrc直接跑一遍，是修改的配置生效，无需退出重进。 而. /etc/DIR_COLORS却不能这样。 8、文件名规则 1、上面说了255个字节的文件名 2、说了4095个字节带路径的文件名 3、说了颜色 4、还有，除了斜杠和NULL，所有字符都可以用来作为文件名，但是使用特殊字符的目录名和文件名不推荐， 5、标准Linux文件系统（如ext4），文件名称大小写敏感，如果是linux挂载了fat的硬盘（ntfs，需要额外装软件，才能挂到linux下），则给硬盘下大小写不敏感。总之文件名称的大小写是跟着文件系统走的，而文件系统就是你格式化硬盘分区所选择的xfs、fat32、ntfs这些。 验证方法：linux关机，添加硬盘-使用现有的物理磁盘-选择磁盘1（假设你的fat分区在1下，这里看到的0和1就是物理硬盘的编号）-分区2（假设fat格式的是分区2），启动centos 这里的0就是硬盘0，1就是你电脑的第二块磁盘。我就一块0. 确定即可 但是我的实验不能加载物理硬盘 没什么意义，有时间可以换个机器试试，成功开机后，然后接着下面操作： lsblk -f 可见是这个硬盘是vfat格式 文件系统，需要挂载到一个目录才能使用 所以mount /dev/sdd2 /mnt df 可见sdd2已挂载 cd /mnt ls 可见各种windows下的格式， 此时该/mnt下的文件就不再区分大小写了。 这个实验就是说，标准linux文件系统(如ext4)，文件名称大小写敏感。 然而你可以挂载fat32硬盘上去，这个就不区分大小写了。 理论上可以，但直接创建是失败的。可以这么做： 删除一样， 或者 带上路径就行了 9、文件类型 - 普通文件 d 目录文件 b 块设备 c 字符设备 l 符号链接文件 p 管道文件pipe s 套接字文件socket 共7种类型，联系上文 除了-普通文件，其他的文件操作都要小心。特性不一样 p和s 主要是为了两个应用程序之间互相通信用的临时文件。比如两个软件交换数据，一个往pipe里写，另一个从对应的pipe里读。 10、CentOS 7的bin和usr/bin实际是同一个东西了 同样的，lib和/usr/lib， 这些在早期的centos6里不是这样的，都是独立。就是很相似，所以干脆合在一起了。 lib是放库文件的。 11、pwd -P 显示原文件路径 -L 显示的快捷方式就是软链接文件的路径 pwd默认带-L 同样需要注意的是，ll -d 看到的情况也要验证一下，是否是软链接的还是原文件的。 12、有些场合下，相对路径不是相对当前的cwd（current work direction）当前工作目录 比如前文提到的软连接，以及练习-2里也有提到， 就是相对于你要存放软连接的路径的 相对路径 13、basename和dirname， 创建和之前文件相同目录下的另一个文件，可以将下图中的/data/dir1/通过其他方式取出来，比如py里的os.gold、os.walk还是os.list都有方法的。或者你直接将/data/dir1作为变量。 14、cd备忘 cd ~ 等于 cd 进入当前用户的home目录 cd ~user1就回到了user1的家目录 cd – 上一次的路径，效果就是当前和上一次路径返回切换，原理就是OLDPWD这个变量里保存了上一次目录 之所以回得去，就是因为有一个变量保存了上一次的pwd信息。 15、ls备忘 ls -a 包含隐藏 ls -l 显示metadata ls -R 递归，应该有用，os.walk估计还没这个ls -R原生的优秀呢 ls -d 虽然是directory，但是ll -d通常用来看单个文件或文件夹都可以的 ls -1 文件分行显示？啥意思 ls -S 按从大到小排序，这个好 ls -t 按mtime排序 ls -u 配合-t选项，显示并按atime从新到旧排序 ls -U 按目录存放顺序显示 ls -X 按文件后缀排序 ls其实现在也是alias别名了，想用原始的ls只需要\\ls就行了 关于atime 所以正如练习-2里提到过的，atime并不是实时更新的 Access：最近访问时间acces time (atime)，这个不是实时更新的，为了防止大量的写accesstime这个操作，节省资源 但是当你当前读取的时间比上次atime超过1天了都，所以肯定给你立马更新了。最小差值多少，这个可以测一下。 由此可见，还正就是日期从25号变成了26号， 且时间跨度有一个值大概在12小时， 总结一下，hours在12小时，day + 1，基本就会cat后立刻更新时间了。当然可能12小时都嫑。我只是无聊，至于到底几个小时，who care。 clock -s 记得还原 16、ctime 文件的属性发生改变的时间 属性就是：一行里的各种数据，包括 文件的权限、inode数量（硬链接个数，注意软连接不算在meta data里）、所有者、所属组、大小。 这些通通都是元数据 上图cli写错了，直接stat /etc/motd就行了，不要time stat meta data发生改变，ctime就变了 注意atime 各种time不属于元数据。文件名是属于元数据的 17、selinux和防火墙 先不管，关闭即可 上图是selinux 防火墙也是启用的 关闭selinux 原来是enforceing，改成disabled 改完后，需要重启才能生效，不过可以结合cli方式临时关闭selinux就不用重启了。 不过可惜，disabled没有对应的值，0-permissive，1-enforcing。所以我还是老老实实重启吧。 systemctl disabled firewalld.service # 开启不启动 systemctl stop firewalld # 关闭防火墙 最后这样： Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:38 "},"3-文件管理/2-文件管理.html":{"url":"3-文件管理/2-文件管理.html","title":"第2节 文件管理","keywords":"","body":"第2节. 文件管理 1、centos6以前的版本禁用selinux vi /etc/selinux/config SELINUX=disabled chkconfig iptables off service firewalld stop # 应该是这个吧，如果不是，上面一条重启不自启动就行了 2、文件通配符 ★文件通配符，顾名思义，就是匹配文件名称的，别想多了。 * 匹配零个或多个字符 ? 匹配任何单个字符 ~ 当前用户家目录 ~haiwang 用户haiwang家目录 ~+ 当前工作目录 ~- 前一个工作目录 # 等同于cd -，但是ls 不能ls -这么用，要ls ~-这样 [0-9] 匹配任意一个数字 [a-z] 任意小写字母一个 [A-Z] 任意一个大写字母 [haiwang] 匹配列表中的任何的一个字符 yingxiong 匹配列表中的所有字符以外的字符 y开头的 包含x的 .txt结尾的，但是不包括.txt，因为*不会包含隐藏文件。 *在文件名通配符领域里，表示该位置有一个或多个，或者没有，都可以 要在非隐藏文件里找需要的文件名，就可以用ls *来做 而要在隐藏文件里找，就用正则就行了 而查看隐藏的我现在想到的就可以用正则来做，后来又发现还有l.（列出当前所有的隐藏文件和文件夹）。 查看隐藏文件 l.只能看当前文件夹下的隐藏文件/文件夹，如果是看其他路径，就需要参考l.这个alias里的原来语法： ls -d /data/.* 只看文件夹 ll |grep \"^d\" ll -d */ ls ??? 表示就看3个字符的文件 汉字unicode，一个汉字也是一个字符。只是一个汉字这一个字符 在磁盘上保存不是占一个字节。 unicode 汉字，可能占2-4个字节。 在通配符里面没有^[xxx]这种写法，和正则regex相似又不一样 文件里面过滤字符串，这是不是通配符的活，通配符是匹配文件名称，文件内容交给regex 注意事项 ls /data/f[a-c].html表示啥 [a-c]代表aAbBc，这个regex又不同了 [A-C]等价于AbBcC 见下图 如果就是想要小写或大写，可以这么写 [:digit:] 任意数字，相当于0-9 [:lower:] 任意小写字母 [:upppere:] 任意大写字母 [:alpha:] 任意 大 小 写字母 [:alnum:] 任意数字或字母 [:blank:] 水平空白字符 [:space:] 水平或垂直空白字符，垂直空白字符是啥？回车？还是↓ [:punct:] 标点符号 [:print:] 可打印字符 [:cntrl:] 控制（非打印）字符 [:graph:] 图形字符 [:xdigit:] 十六进制字符 注意两个[[:lower:]] 方括号的意思，里面的[:lower:]是一个整体表示一个小写字符，外面的表示任意一个字母。 等价于正则里的[a-z]写法。 只看隐藏文件的方法，和上面的对比一下 l.的缺陷，只能看当前文件夹，下图就是，明明cli里写的ls -d /data/ .*但是看得还是当前目录的 上图有一个思路对了，手残敲错了，应该如下 只看文件夹的方法 一个是看非隐藏，一个是看隐藏的文件夹 通配符，在py的os.xx模块里，好像就不是regex而是通配符 按理说练习应该放在外面，但是这是课堂视频里的练习，不是作业，就不放在外面单独文章了 1、显示/var目录下所有以l开头，以一个小写字母结尾，且中间出现至少一位数字的文件或目录 ls /var l*[0-9]*[[:lower:]] 2、显示/etc目录下任意一位数字开头，且以非数字结尾的文件或目录 ll -d /etc/[0-9]*[^0-9] 这里可以考虑吧-d去掉，为的就是遍历一下/etc下文件夹下的文件或更深层次 3、显示/etc目录下以非字母开头，后面跟了一个字母及其他任意长度任意字符的文件或目录 ll -d /etc/[^[:alpha:]][[:alpha:]]* 注意些通配符的时候，有根弦--通配符不是正则。然后一个字母要有大小写[a-zA-Z] 4、显示/etc/目录下所有以rc开头，并后面是0-6之间的数字，其他为任意字符的文件或目录 ls -d /etc/rc[0-6]* 5、显示/etc目录下，所有以.d结尾的文件或目录 ls -d /etc/*.d # 注意.d文件也算是.d结尾的，这样就看不到了 ls -d /etc/*.d;ls -d /etc/.d 6、显示/etc目下，所有.conf结尾的，且以m.n,r,p开头的文件或目录 ls -d /etc/[mnrp]*.conf 7、只显示/root下的隐藏文件和目录 ls -d /root/.* 8、只显示/etc下的非隐藏目录 ls -d /etc/*/ 3、touch 1、创建文件 2、如果文件存在，只是修改时间（atime、ctime、mtime）都给你改当前时间了 补充： 默认ll的时间是mtime 3、总结，touch是安全的创建文件的方法 还有个创建文件的方法 > echo >> f5.txt 追加内容也是一个道理 以上的> 或 >> 是依赖于shell的， 上图换成csh就不行了 > 、>>不是命令，其实是重定向。 > 常用来快速给文件清空，无论文件有多大，都给你快速清空。据说灰常好的小功能。 touch [OPTION]... FILE... -a 仅改变atime和ctime -m 仅改变mtime和ctime -t [[CC]YY]MMDDhhmm[ss] 指定atime和mtime的时间戳 -c 如果文件不存在，则不予创建，这个一看就不错 4、保持日志为前一天 生成昨天日期作为文件名，上图是错误的写法，会自己坑自己 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:38 "},"3-文件管理/3-cp和mv.html":{"url":"3-文件管理/3-cp和mv.html","title":"第3节 cp和mv","keywords":"","body":"第3节. cp和mv 1、cp命令 cp的三种语法 前两种用的多， cp [OPTION]... [-T] SOURCE DEST # 复制并改名 cp [OPTION]... SOURCE... DIRECTORY # 复制多个源文件到一个文件夹中 cp [OPTION]... -t DIRECTORY SOURCE # 同上，多了个-t 其实第三种用的也很多，因为通常会将rm，alisa成mv，此时就需要将目的文件夹放到前面，如下图： cp 复制文件的meta data会改变的 cp复制文件的时候，可能有一些信息会丢失（时间） cp复制文件的时候，可能有一些信息会丢失（时间，所属用户 用户组） 文件拷过来了，但是所属者、所属组，也包括时间都变了。 这就是信息丢失了，很可能导致文件复制过来不可用了。 cp赋值普通文件是可以的，除了上面的说的问题。但是cp不能复制特殊文件 之前讲过7种类型的文件 ll看最前面的符号就是类型了 zero也是一个常用的字符文件 cp复制文件的时候，cp复制问题-文件内容变了，拷的就不是你要的文件 下图注意复制的其实不是软连接，而是真是的文件被复制的。 cp复制文件的时候，cp了一个/dev/zero设备文件，如下图，什么都不一样了（文件类型、权限、大小）都变了 其实zero好像通常用来产生固定大小的文件的，一般你测试网速，就可以用zero产生一个大文件提供下载。 所以 cp主要针对普通文件的。要复制特殊文件，需要加一些选项，就算普通文件，如果需要保留原来的时间也需要cp加选项。 2、复制文件夹的注意事项 复制到文件夹，不改名字 复制多个文件，复制到文件夹下 如果是复制文件夹 需要递归选项 如果文件夹不存在，自动给你创建 如果文件夹存在，会覆盖？！不是，看清楚下图，①sysconfigbak文件存在，②所以会把sysconfig文件夹的内容全都复制到sysconfigbak文件夹下。③而再次cp -r的时候由于sysconfigbak下已经有sysconfig整个文件夹的内容了，所以会问你是否覆盖。 这就是传说中的：幂等性 多次重复执行一个命令，效果一样，这就叫做幂等性。 所以cp命令不具有幂等性的特点。 源 目标 不存在 存在且为文件 存在且为目录 一个文件 新建DEST，并将SRC中内容填充至DEST中 将SRC中的内容覆盖至DEST中 注意数据丢失风险！ 建议用-i 选项 在DEST下新建与原文件同名的文件，并将SRC中内容填充至新文件中 多个文件 提示错误 提示错误 在DEST下新建与原文件同名的文件，并将原文件内容复制进新文件中 目录 须使用-r选项 创建指定DEST同名目录，复制SRC目录中所有文件至DEST下 提示错误 在DEST下新建与原目录同名的目录，并将SRC中的内容复制到目录中 3、CP常用选项 -i 覆盖前提示，默认就有 需要注意 这是因为root账号有自己的alias别名定义，user1没有定义，别名的定义在家目录的.bashrc里写的。在root账号的家目录里有定义的别名，这里 -n 不覆盖，注意两者顺序 -r, -R 递归复制目录及内容 -a 归档，相当于-dR –perserv=all -d --no-dereference –preserv=links 不复制原文件，只复制链接名 --preserv[=ATTR_LIST] ​ mode:权限 ​ ownership:属主属组 ​ timestamp: ​ links ​ xattr ​ connext ​ all 4、cp的技巧 cp通常是需要加上-i ，cp – i 作为alias别名存在，但是存在下图情况，一个个问就很烦了。也不能取消别名的安全措施 所以可以利用\\前缀来还原成原始的命令，不用别名 不要想当然以为是cp -f，并不是这样的 -n 不覆盖 -d 不复制原文件，只复制链接名 默认是复制原始文件，而不是软链接本身。 --preserv[=ATTR_LIST] ​ mode:权限 ​ ownership:属主属组 ​ timestamp: ​ links ​ xattr ​ connext ​ all !*等价于上一次命令的后面所有参数，不仅仅是下图表示的两个，上图就出现了三个 如果我们希望保留时间属性，就可以 cp xx xx –preserv=timestamp 这会时间就保留住了 如果所有的都保留住 -p 等同于 –preserv=mode,ownership,timestamp #mode是权限、owership所有者所属组、timestamp就是时间了。 -a 前文有，能保留的属性都保留了，最全了。相当于-dR --preserv=all # 这个其实是help里这么写的，但是你不觉得很奇怪吗，r = R, -d只是--preserv=links，所以-a应该是-r 和 --preverv=all这样表示才对。很明显帮助里多了个-d。作为-dr --preserv=all，写法应该就是cli的是偶带了多个参数。所以自然也是and的关系。 -v --verbose # 复制的时候看到过程，如果文件很大，就需要这个直观显示，防止有人以为卡主不动了。 所以工作中推荐av经典组合 -f --force 演示过程中的错误注意事项： ​ root用户将某文件复制到user1用户的家目录下 正确写法是~user1，经常写错的原因是因为cd ~/切到自身的家目录这里是可以有/的。 现在user1家目录下的fstab的所属用和用户组是root的 于是如图所示，不能覆盖了，但是我自己的家目录，我还不能改吗？！-f就是强制措施 -f的思路，就是如果覆盖不了，实际上先删掉后 重新创建新的文件。当然如果删不了就肯定不行了！ 谁复制的，就变成谁的↑，但这话又不全对↓ -f 此时是删了再创建的，所以用户和用户组都是user1。 切到root用户下，cp /etc/fstab ~user1，覆盖掉，发现用户和组还是user1。 -u --update 只复制源比目标更新文件或目标不存在的文件 复制的时候存在一个覆盖的问题，一般都是更新的数据整个文件夹，cp -u 到服务器上的数据，这样就只做 增量更新。 -b 目标存在，覆盖前先备份，形式为filename~ --backup=numbered目标存在，覆盖前先备份加数字后缀 ★工作中，可以做个alias bak=’cp -a --backup=numbered’ 这样就小整合了一下。 所以-a 经常用来做备份的效果，①保留了所有能保留住的属性，②本身-a就集成了-d和递归的功能。 PS：之所以说保留了能保留的，原因见上图，至少有一个ctime是实时的。 简化写法示例 ll grub2.cfg{,.bak} # {}里面被,逗号分隔成两个部分，,号前面是空，后面是.bak，所以就是 ll grub2.cfg grub2.cfg.bak 这个了。用echo可以直观的看 据说这还是常用的备份方法，搞不懂，秀技术吗？ 练习： 1、每天将/etc/目录下的所有文件，备份到/data独立的子目录下，并要求子目录格式为backupYYYY-mm-dd，备份过程可见 cp -av /etc /data/bakcup`data +%F` 2、创建/data/rootdir目录，并复制/root下所有文件到该目录内，要求保留原有权限。 mkdir /data/rootdir;cp -a /root /data/rootdir cp -r --perserv=mode /root /data/rootdir cp -rp /root /data/rootdir cp -a /root /data/rootdir 5、mv 移动和改名 ★可以用mv替代rm，方法就是alias rm=mv ... mv [OPTION]... [-T] SOURCE DEST mv [OPTION]... SOURCE... DIRECTORY mv [OPTION]... -t DIRECTROY SOURCE 常用选项： -i 交互式 -f 强制 -b 目标存在，覆盖前先备份 6、rm删除 rm [OPTION]... FILE... 常用选项： ​ -i 交互式 ​ -f 强制删除 ​ -r 递归 带文件夹一般都带r ​ -no-preserve-root 删除/ 示例： ​ rm -rf /* 有的rm会被alias成rm -i，所以如果需要关闭提示，就用\\rm f1 f2 f3 当然也可以使用-f选项 ★rm -rf / data #这就完蛋了，你带了空格，就是把/下面全删了 rm -rf --no-preserve-root / 在windows里正在使用的文件是不能删除的，但是在linux里没有这个概念。 有些是删不了的，比如media光盘、proc、sys内存、/home /misc /net有些是特殊情况，确实不能删，其他都能。 /删掉后，pwd，cd都能用，原因就是这些都是内部命令，内部命令都已经加载到了内存里。 你删掉的是磁盘文件，内存里的东西都还在。 但是 内部命令依赖的/bin/bash文件已经没了，下次重启后，这些命令就没了。 外部命令那些本次开机后还没有使用过的就不行了，因为外部命令第一次使用后才会加载到内存中，那些本次开机后没有用过的，还都是磁盘文件呢。所以文件没了，就不能使用这些命令了。 rm -rf /* 这个命令误操作的可能性不太大，但是下一个命令就不行了 ★上图就把/data和 /*下的文件全删了。 工作中rm就别用了，别名成mv，其中涉及mv覆盖同名的文件的解决思路 思路就是，rm改成mv mv的时候考虑同名文件，就事前创建一个以当前时间（精确到秒单位,这样只要你的rm命令频率在1s以外，都没有问题）为文件夹名称。然后将要删除的文件移动到该文件夹里。 所以最终的mv替代rm的方法就是： 待填空 7、tree 显示目录树 ​ -d：只显示目录 ​ -L level：指定显示多少层 ​ -P pattern：只显示由指定pattern匹配到的路径，pattern涉及一些正则表达式 mkdir d1/d2/d3/d4 -pv 竟然不是-r,-v 就是建立的过程 -m MODE：创建目时，直接指定权限 rmdir a1/a2/a3/a4 这是删了a4，且a4是空文件夹，rmdir用的不多。 -p：递归删除父空目录 -v：显示详细信息 rm也不是都能删的，报错资源忙，忙的原因是因为/data是个设备挂载点 rm -rf /data确实会把里面的文件都删了，但是当删/data这个文件夹的时候（注意rm -rf /data是删了整个/data文件夹的）由于data是个分区挂载点，所以报错忙。 8、关于磁盘利用率的释放 cp /dev/zero /boot/bigfile # 时间越久，产生的文件越大 ll /boot/bigfile -h >该实验第1遍 现在删除bigfile，该磁盘利用率是否会立刻降下来呢？不一定。这个实验是立即降下来的。 rm -f /boot/bigfile >该实验第2遍 同样上面的实验，现在再rm删除bigfile该文件之前，先用另一个ssh登入打开它。然后在尝试删除观察磁盘利用率是否下降。 然后删除该文件 工作中，很多企业会遇到类似的场景，有些分区要满了，硬盘如果要满了，数据写不进去，就会造成很严重的结果，系统会崩溃，对外服务就挂了。 可能一些log日志文件，就删了不能立刻释放，存在这种情况。 现在关闭之前vim打开的bigfile的窗口 此时空间就释放了 下面 >该实验第3遍 恢复bigfile被占用的情形，就是rm -rf bigfile后磁盘空间不会得到释放的。 推荐的方法为：> fileName ，就是将文件清空 然后再删除该文件就可以了，整个过程完整截图如下 面试题：发现文件删了，空间没释放，正确应该怎么做，面试常见的答案就是上图。 rmdir 删除空目录 ​ -p：递归删除父空目录，就是从内层外外层删，当删除一个子目录后发现父目录也空了，就把父目录也删了。一直删到根。 # 和mkdir -p相反，mkdir -p是先创建父目录，再创建子目录，删除就自然反着删了。 9、rename：改文件名，mv如何改多个文件 rename --help 这样就改了，改文件名称，不仅仅只知道mv，还要知道rename。 再改回去（将.bak删掉） rename .bak \"\" * 练习 第一题的思路，存在一个组合，会想到是大括号的组合用法 ②第二题 ③第三题 这样也可以 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:38 "},"3-文件管理/4-文件节点表.html":{"url":"3-文件管理/4-文件节点表.html","title":"第4节 文件节点表","keywords":"","body":"第4节. 文件节点表 文件的存放有inode表格和data表格 上图可见，创建一个文件夹后，inode就占掉一个。 touch命令本身不支持这么多个参数，所以换种方式 echo f{1..524288} |xargs touch 节点编号 上图可见分区的空间大小，以及节点数最大值。sda1的inodes最大值为65536。 超出节点编号就不行了 echo f{1..65539} |xargs touch 所以看到没有设备空间不一定是真的，可能是节点编号满了。 删除rm *是不行的，可以删除所在文件夹rm -rf /boot/testdir 或者这么删就行了啊： echo f{1..524288} |xargs rm -rf 节点编号和软连接和硬链接密切相关 ext文件系统的架构 直接指针是12个 ①数据量低于48K，直接指针就可以搞定。 ②超出48K--4M，使用间接指针表示。 ③4M-4GB的采用二级指针 现在centos7是XFT文件系统和ext的文件系统不一样。 不管什么系统都是类似的机制。 对于文件夹来讲他的内容放的是什么 文件名是属于文件夹的内容DATA。是放在数据块空间的。 明白这一点，rm f1本质上是删除他的节点表，指正指向的数据块就没人用了，该空间标记为空闲free状态，但是不会删除数据。如果你新建一个文件可能会覆盖掉的。 此外dir1/下的F1的数据就清了。 所以删除f1是需要有f1所在文件夹的权限就行了。 硬连接，本身就是同一个文件 跨分区了，不同分区肯定不是一个文件了，所以肯定不支持 硬链接不能针对文件夹创建。据说是防止循环现象。 删a1的操作等价上图的示例 备注： 👉以下是vim一个文件，然后echo 然后vim vim 发现indoe在两个数字跳来跳去的(估计和vim打开的时候会自动创建一个.xxx.swp有关，可能是这个原因，也不是swp文件的inode不在那两个反复替换的inode里面，反正vim该文件inode是变的，而且是2个inode数字来回变)。然后echo不会。 [10:54:28 root@localhost data]#echo inode_echo >> test [10:54:43 root@localhost data]#stat test File: test Size: 19 Blocks: 8 IO Block: 4096 regular file Device: fd00h/64768d Inode: 33577448 Links: 1 Access: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: ( 0/ root) Context: unconfined_u:object_r:default_t:s0 Access: 2022-01-29 10:54:20.066021237 +0800 Modify: 2022-01-29 10:54:43.345023132 +0800 Change: 2022-01-29 10:54:43.345023132 +0800 Birth: 2022-01-29 10:54:20.066021237 +0800 [10:54:44 root@localhost data]#ll -i total 8 51325766 drwxr-xr-x. 2 root root 6 Jan 19 19:57 dir 373349 drwxr-xr-x. 2 user1 g12 6 Jan 19 19:58 dir2 33577410 -rw-rw-r--+ 1 root root 7 Jan 29 10:53 f1 33577446 -rw-r--r--. 1 user1 g12 0 Jan 19 19:58 f2 33577448 -rw-r--r--. 1 root root 19 Jan 29 10:54 test [10:54:47 root@localhost data]# [10:54:50 root@localhost data]#vim test [10:55:00 root@localhost data]# [10:55:00 root@localhost data]#vim test [10:55:03 root@localhost data]#ll -i total 8 51325766 drwxr-xr-x. 2 root root 6 Jan 19 19:57 dir 373349 drwxr-xr-x. 2 user1 g12 6 Jan 19 19:58 dir2 33577410 -rw-rw-r--+ 1 root root 7 Jan 29 10:53 f1 33577446 -rw-r--r--. 1 user1 g12 0 Jan 19 19:58 f2 33577450 -rw-r--r--. 1 root root 28 Jan 29 10:54 test [10:55:04 root@localhost data]#stat test File: test Size: 28 Blocks: 8 IO Block: 4096 regular file Device: fd00h/64768d Inode: 33577450 Links: 1 Access: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: ( 0/ root) Context: unconfined_u:object_r:default_t:s0 Access: 2022-01-29 10:55:01.373024600 +0800 Modify: 2022-01-29 10:54:59.985024487 +0800 Change: 2022-01-29 10:54:59.987024487 +0800 Birth: 2022-01-29 10:54:59.985024487 +0800 [10:55:09 root@localhost data]#vim test [10:55:25 root@localhost data]# [10:55:25 root@localhost data]# [10:55:25 root@localhost data]#stat test File: test Size: 39 Blocks: 8 IO Block: 4096 regular file Device: fd00h/64768d Inode: 33577448 Links: 1 Access: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: ( 0/ root) Context: unconfined_u:object_r:default_t:s0 Access: 2022-01-29 10:55:25.695026580 +0800 Modify: 2022-01-29 10:55:25.695026580 +0800 Change: 2022-01-29 10:55:25.697026580 +0800 Birth: 2022-01-29 10:55:25.695026580 +0800 [10:55:27 root@localhost data]# [10:55:35 root@localhost data]# [10:55:35 root@localhost data]#vim test [10:55:44 root@localhost data]# [10:55:44 root@localhost data]#stat test File: test Size: 50 Blocks: 8 IO Block: 4096 regular file Device: fd00h/64768d Inode: 33577450 Links: 1 Access: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: ( 0/ root) Context: unconfined_u:object_r:default_t:s0 Access: 2022-01-29 10:55:44.687028126 +0800 Modify: 2022-01-29 10:55:44.687028126 +0800 Change: 2022-01-29 10:55:44.688028126 +0800 Birth: 2022-01-29 10:55:44.687028126 +0800 [10:55:45 root@localhost data]# [10:57:23 root@localhost data]#stat test File: test Size: 55 Blocks: 8 IO Block: 4096 regular file Device: fd00h/64768d Inode: 33577448 Links: 1 Access: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: ( 0/ root) Context: unconfined_u:object_r:default_t:s0 Access: 2022-01-29 10:57:23.128036141 +0800 Modify: 2022-01-29 10:57:23.128036141 +0800 Change: 2022-01-29 10:57:23.129036141 +0800 Birth: 2022-01-29 10:57:23.128036141 +0800 [10:57:23 root@localhost data]#echo 12 >> test [10:57:29 root@localhost data]#stat test File: test Size: 58 Blocks: 8 IO Block: 4096 regular file Device: fd00h/64768d Inode: 33577448 Links: 1 Access: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: ( 0/ root) Context: unconfined_u:object_r:default_t:s0 Access: 2022-01-29 10:57:23.128036141 +0800 Modify: 2022-01-29 10:57:29.437036654 +0800 Change: 2022-01-29 10:57:29.437036654 +0800 Birth: 2022-01-29 10:57:23.128036141 +0800 [10:57:30 root@localhost data]#echo 333 >> test [10:57:35 root@localhost data]#stat test File: test Size: 62 Blocks: 8 IO Block: 4096 regular file Device: fd00h/64768d Inode: 33577448 Links: 1 Access: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: ( 0/ root) Context: unconfined_u:object_r:default_t:s0 Access: 2022-01-29 10:57:23.128036141 +0800 Modify: 2022-01-29 10:57:35.603037157 +0800 Change: 2022-01-29 10:57:35.603037157 +0800 Birth: 2022-01-29 10:57:23.128036141 +0800 [10:57:36 root@localhost data]# total 20 33577460 drwxrwxrwx. 4 root root 78 Jan 29 10:58 . 128 dr-xr-xr-x. 18 root root 236 Jan 10 18:13 .. 51325766 drwxr-xr-x. 2 root root 6 Jan 19 19:57 dir 373349 drwxr-xr-x. 2 user1 g12 6 Jan 19 19:58 dir2 33577410 -rw-rw-r--+ 1 root root 7 Jan 29 10:53 f1 33577446 -rw-r--r--. 1 user1 g12 0 Jan 19 19:58 f2 33577448 -rw-r--r--. 1 root root 62 Jan 29 10:57 test 33577447 -rw-r--r--. 1 root root 12288 Jan 29 10:58 .test.swp Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-02-01 15:42:19 "},"3-文件管理/5-文件链接.html":{"url":"3-文件管理/5-文件链接.html","title":"第5节 文件链接","keywords":"","body":"第5节. 文件链接 硬链接，在同一个分区的不同目录下 不能针对文件夹 不能跨分区 data有3个inode ID的原因，是多一个子文件夹就多一个硬连接。 ll -i查看的连接数是硬连接数，与软连接无关。 硬连接如果使用相对路径是，相对的当前操作的路径。 软连接文件的大小是指向路径的长度决定的 软连接的原始文件要写相对于你要创建的连接文件的路径。 写相对路径，你直接复制/data复制重命名其他的，你的软连接一样使用OK。 软连接可以针对文件夹创建 删除软连接是个危险活~ 因为rm -rf d1.你一个tab键补全就是rm -rf d1.link/ ， 然后你删除的就是d1.link链接的那个源文件夹里的所有东西，而d1.link这个软链接本身并没有删除。 软连接、硬链接区别 1、本质上：硬链接-本质上是同一个文件多个名字；软连接-本质上是不同文件； 2、跨分区：硬链接不支持，软连接支持 3、目录创建：硬链接不支持；软连接支持 4、相互关系：硬链接是相互平等；软连接原始文件删除软连接失效 5、inode编号：硬链接是相同的；软连接不同 6、连接数：硬链接的创建删除会影响连接数；软连接删了这个文件就没了不存在连接数多个的问题。 7、路径问题：原始文件路径：硬链接创建是相对当前工作目录，软连接是相对于要创建的软连接的相对路径。 8、文件类型：软连接时l表示软连接；硬链接就是文件本身是啥类型就是啥。 9、颜色：软连接是蓝色、硬链接看原文件 10、命令实现不同：ln -s和ln linux的文件格式，不存在后缀一说，可以通过file xxx去判断该文件类型。 file -b # 只显示文件名本身 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:38 "},"4-文本编辑工具vim/4-文本编辑工具vim.html":{"url":"4-文本编辑工具vim/4-文本编辑工具vim.html","title":"第四章 文本编辑工具vim","keywords":"","body":"第四章 文本编辑工具vim Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"4-文本编辑工具vim/1-vim.html":{"url":"4-文本编辑工具vim/1-vim.html","title":"第1节 vim","keywords":"","body":"第1节. vim 大篇幅编辑使用软件如vscode的plugin弄就行了。 会用到的备忘： :set nu 删除100dd,dGG,dgg ^$切换行尾行首w光标移动一个空格 vim +10 xxx # 打开就进入了第10行 vim 颜色也不是都加的，/etc/passwd，复制到/data下再vim就会发现颜色没了。/etc/下的属于系统配置文件，所以给你加颜色了。 vim -m 只读打开 /XXX搜索，nN u撤销 U 改行的修改全部撤销 s/要查找的内容/替换的内容/修饰符 这是正则，后面到了正则再说 整个文件的内容vim里替换用%s :%s/XXX/YYY/g /可以替换的 :%s#/dev#/tmp#g 0的ASCI码 cat也看不到 可以这么看二进制文件 00000000这是位置，后面00 00 00是内容 批量注释会有用 复制到vim里，空行格式错位，可以试试 :set paste 这个比较好用， 跳行同学的福音 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"5-标准I&O和管道/5-标准I&O和管道.html":{"url":"5-标准I&O和管道/5-标准I&O和管道.html","title":"第五章 标准I&O和管道","keywords":"","body":"第五章 标准I&O和管道 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:40 "},"5-标准I&O和管道/1-标准输入输出和重定向.html":{"url":"5-标准I&O和管道/1-标准输入输出和重定向.html","title":"第1节 标准输入输出和重定向","keywords":"","body":"第1节. 标准输入输出和重定向 三种I/O设备 把I/O重定向到文件 使用管道 标准输入 每打开一个文件，系统都会分配一个数字编号对应该文件， 可见一个文件会有4个描述符与之对应，退出tail后，这里的对应关系就没了。 可以看到tail -f .bashrc，系统分配了一个3的文件描述符-软连接指向。 而0 1 2是输入输出信息对应的设备文件描述符，什么意思，就是你对.bashrc文件进行操作，会存在各种交互信息，正常的，错误的，等等从键盘输入的，打印到屏幕的。 关于输出重定向的小例子 > # 这是标准输出的重定向 以下命令特别的一个：C ls /data /xxx 2> all.log 1>&2 ls /data /xxx &> all.log ls /data /xxx 2>&1 all.log # 打印到屏幕上去了 ls /data /xxx > all.log 2>&1 以上是标准输出 标准输入 tr的一些用法 tr abcde 123 tr -t abcde 123 tr [:lower:] [:upper:] tr -d '135' tr -s 'ace' tr就可以和标准输入结合 所以转换的话，也可以用tr来做 tr可以转换、压缩、删除，也方便了。 上图是CTRL+D结束才会看到结果。是除了a、b、c以外的都删了。 单行重定向举例 此时多开一个窗口可见aaa已近写进去了 多行重定向 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:40 "},"5-标准I&O和管道/2-管道实现重定向.html":{"url":"5-标准I&O和管道/2-管道实现重定向.html","title":"第2节 管道实现重定向","keywords":"","body":"第2节. 管道实现重定向 如何对错误信息进行管道符传递 上图：管道符|只能处理标准输出，而标准错误无法传递，不过可以下图做法： 上图有两种写法，最后的|&是相对2>&1晚一些时间出来的写法。 换种邮件正文的写法 bc的灵活用法 tee的意义 tee会覆盖 tee的追加效果 tee的意义 计算1+2+3+ ... +100 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:40 "},"6-用户、用户组和权限/6-用户、用户组和权限.html":{"url":"6-用户、用户组和权限/6-用户、用户组和权限.html","title":"第六章 用户、用户组和权限","keywords":"","body":"第六章 用户、用户组和权限 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:40 "},"6-用户、用户组和权限/1-用户和组的增删改查.html":{"url":"6-用户、用户组和权限/1-用户和组的增删改查.html","title":"第1节 用户和组的增删改查","keywords":"","body":"第1节. 用户和组的增删改查 AAA authentication、authorization、accouting|audition UID windows看用户和组 windows里user和group 不能同名，但是在linux里是正常情况。 早期密码是放在/etc/passwd里的，后买放到shaow里，可以回归早期的情况 pwunconv # 密码放到/etc/passwd里 pwconv # 密码放到/etc/shadow里 UID才是关键，将root的UID改成1000，它就不是管理员了。 如果没有一个user的UID=0，重启就起不来了。 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:40 "},"6-用户、用户组和权限/2-用户和组的权限管理.html":{"url":"6-用户、用户组和权限/2-用户和组的权限管理.html","title":"第2节 用户和组的权限管理","keywords":"","body":"第2节. 用户和组的权限管理 /etc/shaow字段说明 useradd -r ming [09:19:15 root@localhost ~]#echo cisco | passwd --stdin ming Changing password for user ming. passwd: all authentication tokens updated successfully. ming:$6$AUsIFTgTuY/hWn8Y$0PgiuhWLxBGeGRtbd/Niz5R1EsMRvV3gdSRT45jnXMyZisgBzcCybETswhJzuuUQeIPkO/gMzo3rKyXvRAE6h.:19008:::::: ---上面是rocke-linux复制过来的---下面是centos----- ming:$6$nfkcZ5x7$Le5WQnLSUiJbw2tdXiilhvVZFGy69iuzKQq2XoA84jrHtrOp8fwQgMyunGIt1wQimPf37xdUL7B6rCOvpSaDE0:19008:0:99999:7::: [root@centos7 ~]# 这些字段的帮助信息可通过man 5 shadow获得 $6 ：表示sha512 $1 ：表示md5 👇注意第一个时间字段=0的特殊功效，就是首次登入修改密码 你改口令的时间距离1970-1-1号的时间 date of last password change The date of the last password change, expressed as the number of days since Jan 1, 1970. The value 0 has a special meaning, which is that the user should change her pasword the next time she will log in the system. An empty field means that password aging features are disabled. [09:25:26 root@localhost ~]#echo `date +%s`/86400 |bc 19008 这就是上图ming用户的19008的由来 minimum password age 用户必须等多久才能修改口令，0就是可以立即修改密码，以天为单位，centos7里默认是0，rocke-linux默认为空 maximum password age 用户不改密码，密码多久到期，以天为单位，centos7默认99999，rocke-linux默认为空 password warning period 上面的最大密码时间意味着过期，而过期前提前7天会提醒你修改密码 [root@centos7 ~]# date -s \"+5 day\" Fri Jan 21 09:40:55 CST 2022 [root@centos7 ~]# date 然后再将本地时间延后10天，此时在用ming登入看看 [root@centos7 ~]# date -s \"+5 day\" Wed Jan 26 09:44:25 CST 2022 [root@centos7 ~]# date -s \"+5 day\" Mon Jan 31 09:45:03 CST 2022 [root@centos7 ~]# password inactivity period 围绕着密码过期时间--maximum password age，如果超过这个时间X天就禁用该账号，这个X就是password inactivity period的意思。 ming:$6$nfkcZ5x7$Le5WQnLSUiJbw2tdXiilhvVZFGy69iuzKQq2XoA84jrHtrOp8fwQgMyunGIt1wQimPf37xdUL7B6rCOvpSaDE0:19008:0:10:7:5:: account expiration date 账户有效期，前面都是针对密码过期的，这个参数是针对账号的 注意这里和前一张图的区别，已经不再说authentication的事了，直接说的事账号挂了。 /etc/group和/etc/gshadow dbus:x:81: polkitd:x:998: ssh_keys:x:997: sshd:x:74: postdrop:x:90: postfix:x:89: user1:x:1000: ming:x:1001: [root@centos7 ~]# cat /etc/group systemd-journal:!:: systemd-network:!:: dbus:!:: polkitd:!:: ssh_keys:!:: sshd:!:: postdrop:!:: postfix:!:: user1:!:: ming:!:: [root@centos7 ~]# cat /etc/gshadow 组设置口令是给普通用户加组的权限， 附加组显示在/etc/group里的行最后一个字段 ming:x:1001:user1 user1用户就加入进了ming这个组，ming就是user1的附加组 /etc/gshadow 存放组口令的文件 ming:!!::user1,user2,user3 !!组密码禁用的，不能通过组口令来往里加成员，只能是root管理了 ::里放的是管理员账号，每个组可以设置管理员,用来添加删除组成员，默认为空就只有root管理 user1,user2,user3就是和/etc/group一样，加入该组的成员就罗列在这里 随机口令的产生 [root@centos7 ~]# openssl rand -base64 9 rvgumQ+4U67t [root@centos7 ~]# openssl rand -base64 9 328culZ3wpV1 [root@centos7 ~]# yum -y install expect 查看man手册： FLAGS The -l flag defines the length of the password. The default is 9. The following example creates a 20 character password. mkpasswd -l 20 The -d flag defines the minimum number of digits that must be in the password. The default is 2. The following example creates a password with at least 3 digits. mkpasswd -d 3 The -c flag defines the minimum number of lowercase alphabetic characters that must be in the password. The default is 2. The -C flag defines the minimum number of uppercase alphabetic characters that must be in the password. The default is 2. EXAMPLE The following example creates a 15-character password that contains at least 3 digits and 5 uppercase characters. mkpasswd -l 15 -d 3 -C 5 [root@centos7 ~]# mkpasswd -l 15 -d 3 -C 5 \\Dpbel2VZa8Dv9W [root@centos7 ~]# mkpasswd -l 15 -d 3 -C 5 m0hsZaXZ*O1Dap9 [root@centos7 ~]# mkpasswd -l 15 -d 3 -C 5 zBfuS0evQP6x1H/ C:\\Users\\MingYi>net accounts 强制用户在时间到期之后多久必须注销?: 从不 密码最短使用期限(天): 0 密码最长使用期限(天): 42 密码长度最小值: 0 保持的密码历史记录长度: None 锁定阈值: 从不 锁定持续时间(分): 30 锁定观测窗口(分): 30 计算机角色: WORKSTATION 命令成功完成。 正要改这个时间，不推荐上文的直接修改/etc/shadow，而是用命令去改 [12:33:30 root@localhost ~]#chage ming Changing the aging information for ming Enter the new value, or press ENTER for the default Minimum Password Age [-1]: 2 Maximum Password Age [-1]: 33 Last Password Change (YYYY-MM-DD) [2022-01-16]: Password Expiration Warning [-1]: 7 Password Inactive [-1]: Account Expiration Date (YYYY-MM-DD) [-1]: 2023-01-16 [12:34:26 root@localhost ~]# ----改时间---- 这里rockety-linux还弄出个-1出来，呵呵，反正估计也是不限制的意思 [12:36:06 root@localhost ~]#getent shadow ming ming:$6$AUsIFTgTuY/hWn8Y$0PgiuhWLxBGeGRtbd/Niz5R1EsMRvV3gdSRT45jnXMyZisgBzcCybETswhJzuuUQeIPkO/gMzo3rKyXvRAE6h.:19008:2:33:7::19373: [12:36:13 root@localhost ~]# [12:36:26 root@localhost ~]#getent passwd ming ming:x:992:988::/home/ming:/bin/bash [12:36:34 root@localhost ~]# [12:36:36 root@localhost ~]#getent group ming ming:x:988: [12:36:48 root@localhost ~]#getent gshadow ming ming:!:: [12:36:53 root@localhost ~]# [12:36:54 root@localhost ~]#getent passwd ming root ming:x:992:988::/home/ming:/bin/bash root:x:0:0:root:/root:/bin/bash [12:37:02 root@localhost ~]# vipw和vigr 编辑passwd和group的推荐命令 pwck和grpck 检查passwd和group的命令 [12:38:19 root@localhost ~]#pwck [user 'cockpit-ws': directory '/nonexisting' does not exist user 'cockpit-wsinstance': directory '/nonexisting' does not exist user 'ming': directory '/home/ming' does not exist pwck: no changes [12:39:02 root@localhost ~]#grpck [12:39:11 root@localhost ~]#ll /home/ total 0 groupadd 创建组 创建组 [13:39:41 root@localhost ~]#groupadd admins [13:39:50 root@localhost ~]#getent group admins admins:x:1000: [13:40:00 root@localhost ~]# 创建系统组 [13:40:46 root@localhost ~]#groupadd -r mysql [13:40:50 root@localhost ~]# [13:40:52 root@localhost ~]#getent group mysql mysql:x:987: [13:40:55 root@localhost ~]# 修改组名 [13:42:45 root@localhost ~]#getent group admins admins:x:1000: [13:42:50 root@localhost ~]#groupmod -n mgmt admins [13:42:56 root@localhost ~]#getent group mgmt mgmt:x:1000: 删除组 [13:44:06 root@localhost ~]#getent group mgmt mgmt:x:1000: [13:44:08 root@localhost ~]#getent group mysql mysql:x:987: [13:44:10 root@localhost ~]#groupdel mgmt [13:44:18 root@localhost ~]#groupdel mysql [13:44:20 root@localhost ~]#getent group mysql [13:44:23 root@localhost ~]#getent group mgmt 删不掉组的原因 [13:49:33 root@localhost ~]#groupdel ming groupdel: cannot remove the primary group of user 'ming' 是因为有用户将ming作为主组，这个用户就是ming自己。是useradd创建ming的时候自动生成的主组。 [13:49:43 root@localhost ~]#useradd ming2 [13:51:05 root@localhost ~]#getent group ming2 ming2:x:1000: [13:51:23 root@localhost ~]#groupdel ming2 groupdel: cannot remove the primary group of user 'ming2' [13:51:32 root@localhost ~]#userdel ming2 [13:51:39 root@localhost ~]#getent group ming2 [13:51:45 root@localhost ~]#ll /home/ total 0 drwx------. 2 1000 1000 62 Jan 16 13:51 ming2 userdel 删除用户连带组，但不会连带家目录，所以关于创建用户和删除用户的时候要注意家目录是否连带生成和删除 man useradd -r, --system Create a system account. System users will be created with no aging information in /etc/shadow, and their numeric identifiers are chosen in the SYS_UID_MIN-SYS_UID_MAX range, defined in /etc/login.defs, instead of UID_MIN-UID_MAX (and their GID counterparts for the creation of groups). Note that useradd will not create a home directory for such a user, regardless of the default setting in /etc/login.defs (CREATE_HOME). You have to specify the -m options if you want a home directory for a system account to be created. man userdel -f, --force This option forces the removal of the user account, even if the user is still logged in. It also forces userdel to remove the user's home directory and mail spool, even if another user uses the same home directory or if the mail spool is not owned by the specified user. If USERGROUPS_ENAB is defined to yes in /etc/login.defs and if a group exists with the same name as the deleted user, then this group will be removed, even if it is still the primary group of another user. Note: This option is dangerous and may leave your system in an inconsistent state. -h, --help Display help message and exit. -r, --remove Files in the user's home directory will be removed along with the home directory itself and the user's mail spool. Files located in other file systems will have to be searched for and deleted manually. The mail spool is defined by the MAIL_DIR variable in the login.defs file. [14:01:12 root@localhost ~]#useradd ming2 useradd: warning: the home directory already exists. Not copying any file from skel directory into it. Creating mailbox file: File exists [14:01:18 root@localhost ~]# [14:01:18 root@localhost ~]# [14:01:18 root@localhost ~]#getent passwd ming2 ming2:x:1000:1000::/home/ming2:/bin/bash [14:01:22 root@localhost ~]# [14:01:23 root@localhost ~]#ll /home/ total 0 drwx------. 2 ming2 ming2 62 Jan 16 13:51 ming2 [14:01:25 root@localhost ~]# [14:01:26 root@localhost ~]#userdel -r ming2 [14:01:30 root@localhost ~]#ll /home/ total 0 [14:01:32 root@localhost ~]#getent passwd ming2 [14:01:39 root@localhost ~]#getent group ming2 [14:01:43 root@localhost ~]# 用户创建管理 [14:03:53 root@localhost ~]#rpm -q --scripts postfix preinstall scriptlet (using /bin/sh): # Add user and groups if necessary /usr/sbin/groupadd -g 90 -r postdrop 2>/dev/null /usr/sbin/groupadd -g 89 -r postfix 2>/dev/null /usr/sbin/groupadd -g 12 -r mail 2>/dev/null /usr/sbin/useradd -d /var/spool/postfix -s /sbin/nologin -g postfix -G mail -M -r -u 89 postfix 2>/dev/null ------------------------- -g 90 gid -r 指定为系统组 useradd的选项学习 /usr/sbin/useradd -d /var/spool/postfix -s /sbin/nologin -g postfix -G mail -M -r -u 89 postfix 2>/dev/null -u 89 ： 指定用户UID为89 -s : 指定shell类型 -o ： 忽略uid唯一性的检查 [14:12:58 root@localhost ~]#getent passwd root root:x:0:0:root:/root:/bin/bash [14:13:09 root@localhost ~]#useradd -u 0 ming3 useradd: UID 0 is not unique [14:13:20 root@localhost ~]#getent passwd ming3 [14:13:36 root@localhost ~]#useradd -u 0 -o ming3 [14:13:42 root@localhost ~]#getent passwd ming3 ming3:x:0:1000::/home/ming3:/bin/bash [14:13:43 root@localhost ~]#getent passwd root root:x:0:0:root:/root:/bin/bash [14:14:47 root@localhost ~]#id root uid=0(root) gid=0(root) groups=0(root) [14:14:49 root@localhost ~]#id ming3 uid=0(root) gid=0(root) groups=0(root) [14:14:51 root@localhost ~]# 创建系统服务， [14:18:18 root@localhost ~]#useradd -r -s /sbin/nologin mysql [14:18:26 root@localhost ~]#getent passwd mysql mysql:x:991:987::/home/mysql:/sbin/nologin 默认行为是useradd不指定主组，就会自动创建和用户名同名的主组 [14:21:35 root@localhost ~]#useradd alice [14:21:48 root@localhost ~]#id alice uid=1000(alice) gid=1000(alice) groups=1000(alice) 通过-g指定主组，就不会自动创建主组了，指定的主要事先存在 [14:22:33 root@localhost ~]#useradd tom -g alice [14:22:58 root@localhost ~]#id tom uid=1001(tom) gid=1000(alice) groups=1000(alice) -G 是附加组 [14:24:10 root@localhost ~]#groupadd g1 [14:24:13 root@localhost ~]#groupadd g2 [14:24:21 root@localhost ~]#groupadd g3 [14:24:23 root@localhost ~]# [14:24:24 root@localhost ~]#useradd jack -g alice -G g1,g2 [14:24:44 root@localhost ~]#id jack uid=1002(jack) gid=1000(alice) groups=1000(alice),1001(g1),1002(g2) [14:26:44 root@localhost ~]#getent group | grep jack g1:x:1001:jack g2:x:1002:jack [14:26:49 root@localhost ~]#getent gshadow | grep jack g1:!::jack g2:!::jack [14:26:55 root@localhost ~]# -N 不创建同名的主组，也不指定，就默认创建一个users [14:28:06 root@localhost ~]#useradd rose -N [14:28:15 root@localhost ~]#id rose uid=1003(rose) gid=100(users) groups=100(users) [14:28:18 root@localhost ~]# 看下windows的创建用户的默认行为，默认就是和linux的useradd -N一样的，都是将新建用户放到users组下面。 C:\\WINDOWS\\system32>net user test001 passwd001 /add 命令成功完成。 C:\\WINDOWS\\system32>net user \\\\DESKTOP-5T7A4A1 的用户帐户 ------------------------------------------------------------------------------- ___VMware_Conv_SA___ admin Administrator ciscoacvpnuser DefaultAccount Guest MingYi named test001 WDAGUtilityAccount 命令成功完成。 C:\\WINDOWS\\system32>net localgroup users 别名 users 注释 防止用户进行有意或无意的系统范围的更改，但是可以运行大部分应用程序 成员 ------------------------------------------------------------------------------- NT AUTHORITY\\Authenticated Users NT AUTHORITY\\INTERACTIVE test001 命令成功完成。 C:\\WINDOWS\\system32>net user \\\\DESKTOP-5T7A4A1 的用户帐户 ------------------------------------------------------------------------------- ___VMware_Conv_SA___ admin Administrator ciscoacvpnuser DefaultAccount Guest MingYi named test001 WDAGUtilityAccount 命令成功完成。 C:\\WINDOWS\\system32>net user test001 /del 命令成功完成。 C:\\WINDOWS\\system32>net user \\\\DESKTOP-5T7A4A1 的用户帐户 ------------------------------------------------------------------------------- ___VMware_Conv_SA___ admin Administrator ciscoacvpnuser DefaultAccount Guest MingYi named WDAGUtilityAccount 命令成功完成。 关于家目录 不带家目录的方式，useradd -r -s /sbin/nologin mysql [14:35:33 root@localhost ~]#getent passwd | tail -5 mysql:x:991:987::/home/mysql:/sbin/nologin alice:x:1000:1000::/home/alice:/bin/bash tom:x:1001:1000::/home/tom:/bin/bash jack:x:1002:1000::/home/jack:/bin/bash rose:x:1003:100::/home/rose:/bin/bash [14:35:38 root@localhost ~]#ll /home/ total 0 drwx------. 2 alice alice 62 Jan 16 14:21 alice drwx------. 2 jack alice 62 Jan 16 14:24 jack drwx------. 2 rose users 62 Jan 16 14:28 rose drwx------. 2 tom alice 62 Jan 16 14:22 tom [14:35:43 root@localhost ~]# 指定创建家目录 [14:43:13 root@localhost ~]#useradd -d /data/jerryhome jerry [14:43:18 root@localhost ~]#ll /data/jerryhome/ -d drwx------. 2 jerry jerry 62 Jan 16 14:43 /data/jerryhome/ [14:43:29 root@localhost ~]#id jerry uid=1004(jerry) gid=1004(jerry) groups=1004(jerry) [14:43:32 root@localhost ~]# 有个奇怪的行为，就是创建用户的时候指定家目录，但是并不创建 [14:46:22 root@localhost ~]#useradd -d /data/xiaohong -M xiaohong [14:46:36 root@localhost ~]#id xiaohong uid=1005(xiaohong) gid=1005(xiaohong) groups=1005(xiaohong) [14:46:38 root@localhost ~]#ll /data/xiao* ls: cannot access '/data/xiao*': No such file or directory 还有与之相反的思路，useradd -r是系统用户不会创建家目录，-m就是会创建了 [14:47:50 root@localhost ~]#useradd -r zhangsan [14:48:09 root@localhost ~]#id zhangsan uid=990(zhangsan) gid=986(zhangsan) groups=986(zhangsan) [14:48:10 root@localhost ~]#ll /home/ total 0 drwx------. 2 alice alice 62 Jan 16 14:21 alice drwx------. 2 jack alice 62 Jan 16 14:24 jack drwx------. 2 rose users 62 Jan 16 14:28 rose drwx------. 2 tom alice 62 Jan 16 14:22 tom [14:48:14 root@localhost ~]# [14:48:14 root@localhost ~]#useradd -r lisi -m [14:48:33 root@localhost ~]#ll /home/lisi/ -d drwx------. 2 lisi lisi 62 Jan 16 14:48 /home/lisi/ [14:48:38 root@localhost ~]# [14:49:16 root@localhost ~]#useradd -r -m -d /data/ada ada [14:49:20 root@localhost ~]#ll /data/ada -d drwx------. 2 ada ada 62 Jan 16 14:49 /data/ada [14:49:24 root@localhost ~]#id ada uid=988(ada) gid=988(ada) groups=988(ada) [14:49:26 root@localhost ~]# -c : 描述信息，有点用的，讲究人士的专用 [14:51:48 root@localhost ~]#useradd -c \"sbZhuanYong\" sb001 [14:52:21 root@localhost ~]#getent passwd sb001 sb001:x:1006:1006:sbZhuanYong:/home/sb001:/bin/bash [14:52:26 root@localhost ~]# 如果是centos可以yum -y install finger然后查看用户描述信息，rokey-linux好像yum不了finger，yum源rocky的里面貌似没有finger 的rpm包。 [root@centos7 ~]# useradd -c 'dalaozhuanyong' dalao001 [root@centos7 ~]# getent passwd dalao001 dalao001:x:1002:1002:dalaozhuanyong:/home/dalao001:/bin/bash [root@centos7 ~]# [root@centos7 ~]# finger dalao001 Login: dalao001 Name: dalaozhuanyong Directory: /home/dalao001 Shell: /bin/bash Never logged in. No mail. No Plan. [root@centos7 ~]# -----改描述------desc--------- [root@centos7 ~]# chfn dalao001 Changing finger information for dalao001. Name [dalaozhuanyong]: Office []: !wgame Office Phone []: 110 Home Phone []: 110 Finger information changed. [root@centos7 ~]# finger dalao001 Login: dalao001 Name: dalaozhuanyong Directory: /home/dalao001 Shell: /bin/bash Office: !wgame, 110 Home Phone: 110 Never logged in. No mail. No Plan. [root@centos7 ~]# getent passwd dalao001 dalao001:x:1002:1002:dalaozhuanyong,!wgame,110,110:/home/dalao001:/bin/bash [root@centos7 ~]# 所以人家postfix的安装后或者前，跑的脚本里的useradd就能理解了 [root@centos7 ~]# rpm -q --scripts postfix preinstall scriptlet (using /bin/sh): # Add user and groups if necessary /usr/sbin/groupadd -g 90 -r postdrop 2>/dev/null /usr/sbin/groupadd -g 89 -r postfix 2>/dev/null /usr/sbin/groupadd -g 12 -r mail 2>/dev/null /usr/sbin/useradd -d /var/spool/postfix -s /sbin/nologin -g postfix -G mail -M -r -u 89 postfix 2>/dev/null [15:08:55 root@localhost yum.repos.d]#yum -y remove postfix [15:10:09 root@localhost yum.repos.d]#groupadd -r postfix [15:11:58 root@localhost yum.repos.d]#groupadd postfix-1 [15:12:02 root@localhost yum.repos.d]# [15:12:03 root@localhost yum.repos.d]#getent group postfix postfix:x:984: [15:12:09 root@localhost yum.repos.d]#getent group postfix-1 postfix-1:x:1007: [15:12:12 root@localhost yum.repos.d]# [15:12:16 root@localhost yum.repos.d]#id postfix id: ‘postfix’: no such user [15:12:19 root@localhost yum.repos.d]#/usr/sbin/useradd -d /var/spool/postfix -s /sbin/nologin -g postfix -G mail -M -r -u 89 postfix [15:12:23 root@localhost yum.repos.d]#id postfix uid=89(postfix) gid=984(postfix) groups=984(postfix),12(mail) [15:12:28 root@localhost yum.repos.d]#ll /home/pos* ls: cannot access '/home/pos*': No such file or directory [15:12:33 root@localhost yum.repos.d]#ll /var/spool/pos* ls: cannot access '/var/spool/pos*': No such file or directory [15:12:43 root@localhost yum.repos.d]# 其实-M没有意义，就是保险，-r本身就不会创建家目录。 注意下，不管是不是需要userdel -r 加不加r都要去确认下家目录是否真的删除，因为我操作时候发现有时候不加-r，好像也是把家目录删了。这个是在rockey-linux上操作的。 默认useradd的行为有文件定义的 [15:25:22 root@localhost ~]#cat /etc/default/useradd # useradd defaults file GROUP=100 HOME=/home INACTIVE=-1 EXPIRE= SHELL=/bin/bash SKEL=/etc/skel CREATE_MAIL_SPOOL=yes [15:25:27 root@localhost ~]#getent group users users:x:100: [15:26:08 root@localhost ~]# GROUP = 100 默认useradd -N 不创建主组的时候，自动加到users主组里，这个行为就是GROUP=100设置的。 INACTIVE=-1 默认用密码过期后 是否给宽限期，默认是永远宽限。 HOME=/home 默认家目录在哪 CREATE_MAIL_SPOOL=yes 默认用户创建的时候创建它的邮箱， [15:26:08 root@localhost ~]#ll /var/spool/mail/ total 0 -rw-rw----. 1 alice mail 0 Jan 16 14:21 alice -rw-rw----. 1 jack mail 0 Jan 16 14:24 jack -rw-rw----. 1 jerry mail 0 Jan 16 14:43 jerry -rw-rw----. 1 rose mail 0 Jan 16 14:28 rose -rw-rw----. 1 sb001 mail 0 Jan 16 14:52 sb001 -rw-rw----. 1 tom mail 0 Jan 16 14:22 tom -rw-rw----. 1 xiaohong mail 0 Jan 16 14:46 xiaohong SKEL=/etc/skel 默认创建家目录里的隐藏文件的由来 [15:33:50 root@localhost ~]#ls -a /etc/skel/ . .. .bash_logout .bash_profile .bashrc [15:33:53 root@localhost ~]# 所以如果需要创建用户，生成的家目录里自动带上什么文件，就有办法了 [15:36:42 root@localhost ~]#ls -a /etc/skel . .. .bash_logout .bash_profile .bashrc [15:36:51 root@localhost ~]# [15:37:01 root@localhost ~]#ls -a /home/ alice/ jack/ lisi/ rose/ sb001/ tom/ [15:37:01 root@localhost ~]#ls -a /home/alice/ . .. .bash_logout .bash_profile .bashrc [15:37:13 root@localhost ~]#touch /etc/skel/.vimrc [15:37:22 root@localhost ~]#ls -a /etc/skel/ . .. .bash_logout .bash_profile .bashrc .vimrc [15:37:32 root@localhost ~]#useradd test-1 [15:37:43 root@localhost ~]#ls -a /home/test-1/ . .. .bash_logout .bash_profile .bashrc .vimrc [15:37:49 root@localhost ~]# 还有个默认行为文件 [15:43:09 root@localhost ~]#cat /etc/login.defs | grep -Ev \"^#|^$\" MAIL_DIR /var/spool/mail UMASK 022 HOME_MODE 0700 PASS_MAX_DAYS 99999 # 口令最大有效期 PASS_MIN_DAYS 0 # 口令修改无需等待直接改 PASS_MIN_LEN 5 # 口令最短5个 PASS_WARN_AGE 7 UID_MIN 1000 # 默认普通用户UID从1000开始，就是这里设置的 UID_MAX 60000 # 这里的1000和60000都是自动的范围，手动除外 SYS_UID_MIN 201 # 系统UID自动范围 SYS_UID_MAX 999 # 系统UID自动范围 GID_MIN 1000 GID_MAX 60000 SYS_GID_MIN 201 SYS_GID_MAX 999 CREATE_HOME yes USERGROUPS_ENAB yes ENCRYPT_METHOD SHA512 # 默认的哈希算法，/etc/passwd里的$6 [15:43:16 root@localhost ~]# root 不受上述配置的限制 所以默认新建用户的相关文件如下 [15:51:36 root@localhost ~]#ll /etc/default/useradd -d -rw-r--r--. 1 root root 119 Aug 19 03:04 /etc/default/useradd [15:51:40 root@localhost ~]#ll /etc/skel -d drwxr-xr-x. 2 root root 76 Jan 16 15:37 /etc/skel [15:51:44 root@localhost ~]#ll /etc/login.defs -d -rw-r--r--. 1 root root 2512 Aug 19 03:04 /etc/login.defs /etc/default/useradd也可以用useradd -D查看 [15:53:09 root@localhost ~]#useradd -D GROUP=100 HOME=/home INACTIVE=-1 EXPIRE= SHELL=/bin/bash SKEL=/etc/skel CREATE_MAIL_SPOOL=yes [15:54:10 root@localhost ~]#cat /etc/default/useradd # useradd defaults file GROUP=100 HOME=/home INACTIVE=-1 EXPIRE= SHELL=/bin/bash SKEL=/etc/skel CREATE_MAIL_SPOOL=yes 1、直接修改文件 2、通过useradd修改 useradd -D -s SHELL类型 useradd -D -b BASE_DIR/home useradd -D -g GROUP默认useradd -N所带的组 [15:54:10 root@localhost ~]#cat /etc/default/useradd # useradd defaults file GROUP=100 HOME=/home INACTIVE=-1 EXPIRE= SHELL=/bin/bash SKEL=/etc/skel CREATE_MAIL_SPOOL=yes [15:54:22 root@localhost ~]#useradd -D -g 1000 [16:01:36 root@localhost ~]#cat /etc/default/useradd # useradd defaults file GROUP=1000 HOME=/home INACTIVE=-1 EXPIRE= SHELL=/bin/bash SKEL=/etc/skel CREATE_MAIL_SPOOL=yes [16:01:37 root@localhost ~]# 批量操作 newusers # passwd格式文件 批量创建用户 chpasswd # 批量修改用户口令 将/etc/passwd文件里的格式复制出来，放入单个文件，然后到别的机器上newusers xxx即可创建 user1:x:1008:1009::/home/user1:/bin/bash user2:x:1009:1010::/home/user2:/bin/bash user3:x:1010:1011::/home/user3:/bin/bash user4:x:1011:1012::/home/user4:/sbin/nologin [13:58:02 root@localhost ~]#getent passwd -----看下👇创建的具体过程---------- [root@centos7 ~]# cat addusers user1:x:1008:1009::/home/user1:/bin/bash user2:x:1009:1010::/home/user2:/bin/bash user3:x:1010:1011::/home/user3:/bin/bash user4:x:1011:1012::/home/user4:/sbin/nologin [root@centos7 ~]# newusers addusers newusers: line 5: invalid line newusers: line 6: invalid line newusers: error detected, changes ignored [root@centos7 ~]# cat addusers -n 1 user1:x:1008:1009::/home/user1:/bin/bash 2 user2:x:1009:1010::/home/user2:/bin/bash 3 user3:x:1010:1011::/home/user3:/bin/bash 4 user4:x:1011:1012::/home/user4:/sbin/nologin 5 6 [root@centos7 ~]# ---------👆可惜报错鸟------------ 删掉多余的空行后，尝试👇----------- [root@centos7 ~]# cat addusers user1:x:1008:1009::/home/user1:/bin/bash user2:x:1009:1010::/home/user2:/bin/bash user3:x:1010:1011::/home/user3:/bin/bash user4:x:1011:1012::/home/user4:/sbin/nologin [root@centos7 ~]# [root@centos7 ~]# newusers addusers [root@centos7 ~]# getent passwd |grep user* user1:x:1000:1000::/home/user1:/bin/bash user2:x:1009:1010::/home/user2:/bin/bash user3:x:1010:1011::/home/user3:/bin/bash user4:x:1011:1012::/home/user4:/sbin/nologin [root@centos7 ~]# -------------然后再批量改口令方法1👇-------------- [root@centos7 ~]# chpasswd user1:cisco # ctrl d安全退出才能生效 [root@centos7 ~]# getent shadow user1 user1:$6$dR6ZP/lQ5aA$V6xJwgibZELgZh2NKOVDSez8CTzw6h05NX.n/Ft4ZpGtlVNfNEpkpTFRdZqkSQWKKgeZ/BxKgfSm2BRcFaMgo0:19029:0:99999:7::: [root@centos7 ~]# chpasswd user1:huawei ^C # 不能ctrl c强制退出 [root@centos7 ~]# getent shadow user1 user1:$6$dR6ZP/lQ5aA$V6xJwgibZELgZh2NKOVDSez8CTzw6h05NX.n/Ft4ZpGtlVNfNEpkpTFRdZqkSQWKKgeZ/BxKgfSm2BRcFaMgo0:19029:0:99999:7::: [root@centos7 ~]# ------👆注意没截图就是方便后面搜索，但是要小心失真丢东西，这里是ctrl C强制退出，所以没改成功，很多这种交互式的配置都需要ctrl +d 退出。--------- ----非交互式配置方式👇------ [root@centos7 ~]# echo user1:lianxiang |chpasswd [root@centos7 ~]# getent shadow user1 user1:$6$A55IfCFmc$aJPxuWvGRvpTzNocXonzz/gEZTEjV7y3qcHSWEPvxZg1IfA0EUrXMMBpOsw9DXodx4KQ1yCa8SZCTiQtvDYu50:19029:0:99999:7::: [root@centos7 ~]# ---------批量改的方法👇---改口令1---------- [root@centos7 ~]# vi p.set [root@centos7 ~]# cat p.set user1:centos user2:cisco user3:huawei [root@centos7 ~]# cat p.set |chpasswd [root@centos7 ~]# getent shadow user1 user1:$6$PFoqG/41wd3x$PDCFFjFD84xNc2t4je5119lP.ifsTyspYRGnbP4Bx0QpP/9XRd4s9vUFICbEdoDv3pOd7y/7PBLuBsE6EXhwu/:19029:0:99999:7::: [root@centos7 ~]# getent shadow user2 user2:$6$0ilWD/oW7CN$IdC6Gz0.eJKdPBWuGx4KJR00GBrjoxE8KWtCp9lurmP1TaCQGcUra5.VscBTQZ5Um0lKYZO.qb6/fNyYiey0s1:19029:0:99999:7::: [root@centos7 ~]# getent shadow user3 user3:$6$Uv41MY/y9$Q1251b9f9CPX5/sQ1aDhITVsl9pbKEXJspkV4uib/ugaCAlMfg9/Xy4WJBdyq56SJF4k5YuIc0muouxLpi61T0:19029:0:99999:7::: [root@centos7 ~]# 查看id [root@centos7 ~]# id user1 uid=1000(user1) gid=1000(user1) groups=1000(user1) [root@centos7 ~]# id -u user1 1000 [root@centos7 ~]# id -g user1 1000 [root@centos7 ~]# id -G user1 1000 [root@centos7 ~]# id -n user1 id: cannot print only names or real IDs in default format [root@centos7 ~]# id -ng user1 user1 [root@centos7 ~]# id -ngG user1 id: cannot print \"only\" of more than one choice [root@centos7 ~]# id -nG user1 user1 usermod修改用户 [16:04:46 root@localhost ~]#id jack uid=1002(jack) gid=1000(alice) groups=1000(alice),1001(g1),1002(g2) [16:04:48 root@localhost ~]#usermod -g sb001 jack # 修改主组 [16:04:56 root@localhost ~]#id jack uid=1002(jack) gid=1006(sb001) groups=1006(sb001),1001(g1),1002(g2) [16:04:58 root@localhost ~]#usermod -G root jack # -G附加组要注意是覆盖性操作 [16:05:11 root@localhost ~]#id jack uid=1002(jack) gid=1006(sb001) groups=1006(sb001),0(root) [16:05:13 root@localhost ~]# 需要用到-aG,-a只能配合G用，因为其他属性不存在多个值。 [16:05:11 root@localhost ~]#id jack uid=1002(jack) gid=1006(sb001) groups=1006(sb001),0(root) [16:06:01 root@localhost ~]#usermod -aG g1,g2,g3 jack [16:06:12 root@localhost ~]#id jack uid=1002(jack) gid=1006(sb001) groups=1006(sb001),1001(g1),1002(g2),1003(g3),0(root) 空口令登入方法 关联用户锁定，就是不需要输入密码进行登入 修改/etc/shadow里的两个!!，没设置密码，就是两个!! [11:38:54 root@localhost ~]#cat /etc/shadow |grep lisi lisi:!!:19008:::::: [11:38:59 root@localhost ~]#vi /etc/shadow ][11:39:14 root@localhost ~]#cat /etc/shadow |grep lisi lisi::19008:::::: 修改/etc/passwd里的x拿掉，效果一样，无需密码，x就是占位，表示密码放在了/etc/shadow里。 [11:47:43 root@localhost ~]#cat /etc/passwd |grep sb001 sb001:x:1006:1006:sbZhuanYong:/home/sb001:/bin/bash [11:47:44 root@localhost ~]#vi /etc/passwd [11:48:00 root@localhost ~]#cat /etc/passwd |grep sb001 sb001::1006:1006:sbZhuanYong:/home/sb001:/bin/bash 注意这个在rocky-linux里没有用了，在centos7里可以的。 锁定用户 [root@centos7 ~]# useradd test [root@centos7 ~]# getent passwd test test:x:1003:1003::/home/test:/bin/bash [root@centos7 ~]# getent shadow test test:!!:19029:0:99999:7::: # 新创建的用户是被锁定的 [root@centos7 ~]# getent group test test:x:1003: [root@centos7 ~]# getent gshadow test test:!:: -------↓--------设置密码后的变化------↓--------- [root@centos7 ~]# echo cisco |passwd --stdin test Changing password for user test. passwd: all authentication tokens updated successfully. [root@centos7 ~]# getent passwd test test:x:1003:1003::/home/test:/bin/bash [root@centos7 ~]# getent shadow test test:$6$QexkrOWQ$3e85TAtRmiYEMioZOU8QJ7qaD0xCP2lW4Dposctg7evJMRZy3kseNQXD.C21lKtXtqFnzGEhCnbiFq7yI4c5H.:19029:0:99999:7::: [root@centos7 ~]# getent group test test:x:1003: [root@centos7 ~]# getent gshadow test test:!:: -------👇------加锁后的变化---------- [root@centos7 ~]# usermod -L test [root@centos7 ~]# getent passwd test test:x:1003:1003::/home/test:/bin/bash [root@centos7 ~]# getent shadow test test:!$6$QexkrOWQ$3e85TAtRmiYEMioZOU8QJ7qaD0xCP2lW4Dposctg7evJMRZy3kseNQXD.C21lKtXtqFnzGEhCnbiFq7yI4c5H.:19029:0:99999:7::: # 锁是加在shadow里 [root@centos7 ~]# getent group test test:x:1003: [root@centos7 ~]# getent gshadow test test:!:: #gshadow这里一直都是这样的 [root@centos7 ~]# ------👇----解锁------ [root@centos7 ~]# usermod -U test [root@centos7 ~]# getent shadow test test:$6$QexkrOWQ$3e85TAtRmiYEMioZOU8QJ7qaD0xCP2lW4Dposctg7evJMRZy3kseNQXD.C21lKtXtqFnzGEhCnbiFq7yI4c5H.:19029:0:99999:7::: [root@centos7 ~]# -------👇如果是空口令是不给你解锁的---- [root@centos7 ~]# useradd ceshi [root@centos7 ~]# getent passwd ceshi ceshi:x:1004:1004::/home/ceshi:/bin/bash [root@centos7 ~]# getent shadow ceshi ceshi:!!:19029:0:99999:7::: [root@centos7 ~]# usermod -U ceshi usermod: unlocking the user's password would result in a passwordless account. You should set a password with usermod -p to unlock this user's password. 至于两个！！和一个！没啥区别，一来都是锁定。二来只要没有设置密码都不能-U解锁 不过可以vi进去解锁。 当然这个!可以加在passwd里的--通过vi手动加，usermod -L -U都是针对shadow操作，而且要比加在shadow里优先。 修改账号有效期 chage比它好 就是shadow文件里单行，倒数第二个字段--账号有效期，倒数第一字段保留字段。 [root@centos7 ~]# getent shadow test test:!$6$QexkrOWQ$3e85TAtRmiYEMioZOU8QJ7qaD0xCP2lW4Dposctg7evJMRZy3kseNQXD.C21lKtXtqFnzGEhCnbiFq7yI4c5H.:19029:0:99999:7::: [root@centos7 ~]# usermod -U test [root@centos7 ~]# usermod -e 2023-12-12 test [root@centos7 ~]# getent shadow test test:$6$QexkrOWQ$3e85TAtRmiYEMioZOU8QJ7qaD0xCP2lW4Dposctg7evJMRZy3kseNQXD.C21lKtXtqFnzGEhCnbiFq7yI4c5H.:19029:0:99999:7::19703: 设置密码宽限期 chage比它好 在最大超时时间到期后，你还能用几天 [root@centos7 ~]# getent shadow test test:$6$QexkrOWQ$3e85TAtRmiYEMioZOU8QJ7qaD0xCP2lW4Dposctg7evJMRZy3kseNQXD.C21lKtXtqFnzGEhCnbiFq7yI4c5H.:19029:0:99999:7::19703: [root@centos7 ~]# usermod -f 3 test [root@centos7 ~]# getent shadow test test:$6$QexkrOWQ$3e85TAtRmiYEMioZOU8QJ7qaD0xCP2lW4Dposctg7evJMRZy3kseNQXD.C21lKtXtqFnzGEhCnbiFq7yI4c5H.:19029:0:99999:7:3:19703: [root@centos7 ~]# 改时间还是用chage 交互式和非交互是都有 [root@centos7 ~]# chage test Changing the aging information for test Enter the new value, or press ENTER for the default Minimum Password Age [0]: Maximum Password Age [99999]: Last Password Change (YYYY-MM-DD) [2022-02-06]: Password Expiration Warning [7]: Password Inactive [3]: Account Expiration Date (YYYY-MM-DD) [2023-12-12]: [root@centos7 ~]# [root@centos7 ~]# chage -h Usage: chage [options] LOGIN Options: -d, --lastday LAST_DAY set date of last password change to LAST_DAY -E, --expiredate EXPIRE_DATE set account expiration date to EXPIRE_DATE -h, --help display this help message and exit -I, --inactive INACTIVE set password inactive after expiration to INACTIVE -l, --list show account aging information -m, --mindays MIN_DAYS set minimum number of days before password change to MIN_DAYS -M, --maxdays MAX_DAYS set maximum number of days before password change to MAX_DAYS -R, --root CHROOT_DIR directory to chroot into -W, --warndays WARN_DAYS set expiration warning days to WARN_DAYS [root@centos7 ~]# ------注意-E选项时间格式有点坑---------👇--人工写成YYYY-MM-DD----- [root@centos7 ~]# chage -E 10 test [root@centos7 ~]# getent shadow test test:$6$QexkrOWQ$3e85TAtRmiYEMioZOU8QJ7qaD0xCP2lW4Dposctg7evJMRZy3kseNQXD.C21lKtXtqFnzGEhCnbiFq7yI4c5H.:19029:0:99999:7:3:10: [root@centos7 ~]# chage -E 2022-12-12 test [root@centos7 ~]# getent shadow test test:$6$QexkrOWQ$3e85TAtRmiYEMioZOU8QJ7qaD0xCP2lW4Dposctg7evJMRZy3kseNQXD.C21lKtXtqFnzGEhCnbiFq7yI4c5H.:19029:0:99999:7:3:19338: [root@centos7 ~]# chage -I 2 test [root@centos7 ~]# getent shadow test test:$6$QexkrOWQ$3e85TAtRmiYEMioZOU8QJ7qaD0xCP2lW4Dposctg7evJMRZy3kseNQXD.C21lKtXtqFnzGEhCnbiFq7yI4c5H.:19029:0:99999:7:2:19338: [root@centos7 ~]# userdel删除用户 [root@centos7 ~]# ll /home/ total 0 drwx------. 2 ceshi ceshi 83 Feb 6 12:08 ceshi drwx------. 2 dalao001 dalao001 62 Feb 5 14:54 dalao001 drwx------. 2 ming ming 83 Jan 26 09:44 ming drwx------. 2 test test 83 Feb 6 12:08 test drwx------. 2 998 996 62 Feb 5 15:20 test001 drwx------. 2 user1 user1 96 Jan 10 14:16 user1 [root@centos7 ~]# [root@centos7 ~]# [root@centos7 ~]# ll /var/spool/mail/ total 0 -rw-rw----. 1 ceshi mail 0 Feb 6 12:06 ceshi -rw-rw----. 1 dalao001 mail 0 Feb 5 14:54 dalao001 -rw-rw----. 1 ming mail 0 Jan 16 09:28 ming -rw-rw----. 1 test mail 0 Feb 6 11:57 test -rw-rw----. 1 user1 mail 0 Jan 10 11:12 user1 [root@centos7 ~]# [root@centos7 ~]# userdel test [root@centos7 ~]# ll /home/test -d drwx------. 2 1003 1003 83 Feb 6 12:08 /home/test [root@centos7 ~]# ll /var/spool/mail/test -d -rw-rw----. 1 1003 mail 0 Feb 6 11:57 /var/spool/mail/test # 除了家目录，邮箱也要注意是否删除 [root@centos7 ~]# ------不要以为重新创建test用户能继续关联之前没有删除的家目录和邮箱---那是不可能的👇---- [root@centos7 ~]# useradd test useradd: warning: the home directory already exists. Not copying any file from skel directory into it. Creating mailbox file: File exists [root@centos7 ~]# [root@centos7 ~]# [root@centos7 ~]# ll /var/spool/mail/test -d -rw-rw----. 1 1003 mail 0 Feb 6 11:57 /var/spool/mail/test [root@centos7 ~]# ll /home/test -d drwx------. 2 1003 1003 83 Feb 6 12:08 /home/test [root@centos7 ~]# userdel -r test userdel: /var/spool/mail/test not owned by test, not removing userdel: /home/test not owned by test, not removing [root@centos7 ~]# ll /var/spool/mail/test -d -rw-rw----. 1 1003 mail 0 Feb 6 11:57 /var/spool/mail/test [root@centos7 ~]# ll /home/test test/ test001/ [root@centos7 ~]# ll /home/test -d drwx------. 2 1003 1003 83 Feb 6 12:08 /home/test [root@centos7 ~]# userdel -r test userdel: user 'test' does not exist -----选项 -r ----👇能够删除用户家目录和邮箱------- [root@centos7 ~]# useradd test2 [root@centos7 ~]# ll /home/test2 -d drwx------. 2 test2 test2 62 Feb 6 13:36 /home/test2 [root@centos7 ~]# ll /var/spool/mail/test2 -d -rw-rw----. 1 test2 mail 0 Feb 6 13:36 /var/spool/mail/test2 [root@centos7 ~]# userdel -r test2 [root@centos7 ~]# ll /home/test2 -d ls: cannot access /home/test2: No such file or directory [root@centos7 ~]# ll /var/spool/mail/test2 -d ls: cannot access /var/spool/mail/test2: No such file or directory [root@centos7 ~]# 附加，group如果是组里没有其他人，userdel 也会删除组的。 所以这里userdel，要注意 组、家目录、邮箱 信息是否有变化。user没了，group、家目录、邮箱如果在，那么这些文件的属性里的user id都会变成该用户的uid--数字，而不再是原来的用户名。而且1005也只是个空数字，并没有任何用户与其对应。 PATH内容随用户而变 变量变量，它是变的，root和user1的PATH变量的内容是不一样 [root@centos7 ~]# echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin [user1@centos7 ~]$ echo $PATH /usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/user1/.local/bin:/home/user1/bin [user1@centos7 ~]$ su 切换 su - user1 # 这种切换用户环境一并切换 su # 原地切换，pwd的所在路径都不变 ------------完全切换👇---------------- [root@centos7 data]# pwd /data [root@centos7 data]# su - user1 Last login: Sun Feb 6 16:10:51 CST 2022 on pts/0 [user1@centos7 ~]$ pwd /home/user1 [user1@centos7 ~]$ echo $PATH /usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/user1/.local/bin:/home/user1/bin [user1@centos7 ~]$ --------------原地切换👇-pwd和$path都不变的-------------- [root@centos7 data]# su user1 [user1@centos7 data]$ pwd /data [user1@centos7 data]$ echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin [user1@centos7 data]$ --------换个用户执行命令，本身不切换过去----👇-------------- [user1@centos7 data]$ su root -c \"getent shadow root\" Password: root:$6$Kih8C.5/adh8TNjx$wNC09CUb7KsECwLH1LFfAagv8N47OAEqSMHLlOuU.vB24ZzU/H5p6DLpNV31zLKlJioqNmXkIkQEaAUf0H74Z0::0:99999:7::: [user1@centos7 data]$ su活su - 直接回车就是切root，root参数默认就有 root 切换 普通用户 无需密码 普通用户 切换 root 需要密码 ubuntu默认不让root登入的情况 ubuntu默认root等不了，su 切换要密码，但是没设置过root密码默认就 root的口令情况，你非root用户也看不全 这个时候就的使用sudo命令咯 sudo -i 提示出入的是当前普通用户的口令---👇-- 不是每个账号都能sudo 切换到root的，之所以可以是因为系统安装的时候授予了wang账号可以切换。 所以ubuntu这里的！去掉，root就直接无口令登入了 ----而且上面知识运行了root本地登入👆-----远程root还是无法登入ubuntu-------- -----👇一般只有系统安装时设置的默认第一个账户才能sudo -i 切成root用户------ passwd的有用选项 [root@centos7 data]# type passwd # 外部命令，就是用--help去查看帮助，当然也可以man passwd is hashed (/usr/bin/passwd) [root@centos7 data]# passwd --help Usage: passwd [OPTION...] -k, --keep-tokens keep non-expired authentication tokens -d, --delete delete the password for the named account (root only) -l, --lock lock the password for the named account (root only) -u, --unlock unlock the password for the named account (root only) -e, --expire expire the password for the named account (root only) -f, --force force operation -x, --maximum=DAYS maximum password lifetime (root only) -n, --minimum=DAYS minimum password lifetime (root only) -w, --warning=DAYS number of days warning users receives before password expiration (root only) -i, --inactive=DAYS number of days after password expiration when an account becomes disabled (root only) -S, --status report password status on the named account (root only) --stdin read new tokens from stdin (root only) Help options: -?, --help Show this help message --usage Display brief usage message -d ： 删除密码 -l : 这个和usermode -L一样 -u: 这个和usermode -U一样 -e: 👈这个好，典型应用按理，强制用户首次登入修改密码的。 -n -x -w 这些和chage以及usermod差不多，都可以改，推荐chage或者passwd。 改口令的方法2 echo cisco | passwd --stdin user1 &> /dev/null 这个passwd怎么批量啊？密码和用户都是变量，密码可以放到文件里，cat file |重定向给passwd，问题时用户怎么弄呢？好像没有chpasswd方面呢~注意此处划重点敲黑板👉呢字带尾音~。其他技术问题忽略即可~ [root@centos7 data]# vi change_passwd.sh [root@centos7 data]# [root@centos7 data]# . change_passwd.sh # 这里也是个点，放到后面，就是脚本执行的N种方法 Changing password for user user1. passwd: all authentication tokens updated successfully. Changing password for user user2. passwd: all authentication tokens updated successfully. Changing password for user user3. passwd: all authentication tokens updated successfully. [root@centos7 data]# [root@centos7 data]# cat change_passwd.sh #!/bin/bash echo cisco |passwd --stdin user1 echo huawei |passwd --stdin user2 echo juniper |passwd --stdin user3 [root@centos7 data]# --------👇优化输出----------- [root@centos7 data]# . change_passwd.sh [root@centos7 data]# [root@centos7 data]# cat change_passwd.sh #!/bin/bash echo cisco |passwd --stdin user1 > /dev/null echo huawei |passwd --stdin user2 > /dev/null echo juniper |passwd --stdin user3 > /dev/null [root@centos7 data]# 修改shell类型 [root@centos7 data]# getent passwd user1 user1:x:1000:1000::/home/user1:/bin/bash [root@centos7 data]# chsh -s /sbin/nologin user1 Changing shell for user1. chsh: Warning: \"/sbin/nologin\" is not listed in /etc/shells. Shell changed. [root@centos7 data]# getent passwd user1 user1:x:1000:1000::/home/user1:/sbin/nologin [root@centos7 data]# cat /etc/shells /bin/sh /bin/bash /usr/bin/sh /usr/bin/bash [root@centos7 data]# -------- 等价于usermod -s --------- [root@centos7 data]# getent passwd user2 user2:x:1009:1010::/home/user2:/bin/bash [root@centos7 data]# usermod -s /sbin/nolgin user2 [root@centos7 data]# getent passwd user2 user2:x:1009:1010::/home/user2:/sbin/nolgin [root@centos7 data]# 组操作补充 附加组的操作 [root@centos7 data]# id user1 uid=1000(user1) gid=1000(user1) groups=1000(user1) [root@centos7 data]# usermod -G g11,g12 user1 usermod: group 'g11' does not exist usermod: group 'g12' does not exist [root@centos7 data]# groupadd g11 [root@centos7 data]# groupadd g12 [root@centos7 data]# usermod -G g11,g12 user1 [root@centos7 data]# id user1 uid=1000(user1) gid=1000(user1) groups=1000(user1),1013(g11),1014(g12) [root@centos7 data]# -------------删除附加组👇----------- [root@centos7 data]# usermod -G \"\" user1 [root@centos7 data]# id user1 uid=1000(user1) gid=1000(user1) groups=1000(user1) [root@centos7 data]# 查看组信息的其他方法 [root@centos7 data]# usermod -G g11,g12 user1 [root@centos7 data]# groups user1 user1 : user1 g11 g12 [root@centos7 data]# [root@centos7 data]# gpasswd --help Usage: gpasswd [option] GROUP Options: -a, --add USER add USER to GROUP -d, --delete USER remove USER from GROUP -h, --help display this help message and exit -Q, --root CHROOT_DIR directory to chroot into -r, --delete-password remove the GROUP's password -R, --restrict restrict access to GROUP to its members -M, --members USER,... set the list of members of GROUP -A, --administrators ADMIN,... set the list of administrators for GROUP Except for the -A and -M options, the options cannot be combined. [root@centos7 data]# gpasswd -a user1 root Adding user user1 to group root [root@centos7 data]# id user1 uid=1000(user1) gid=1000(user1) groups=1000(user1),0(root),1013(g11),1014(g12) [root@centos7 data]# 有时候发现直接图片更好看一些，要不还是放弃cli复制了，直接图片吧，补充关键字就好。 给组设置口令 某个普通用户要加入某个组，就用到了组密码 id user1 su - user1 touch file1 ll file1 希望创建的文件主组时g12，可修改user1的主组为g12， newgrp g12 user1 -------👆 上图的newgrp时临时有效的，exit后就退出来临时的主组了，👇见下图------ root一样可以 永久的修改就用usermod -g 一些操作排查踩坑记录 因为user3创建之前就有同名的家目录，所以带来一些问题：这也是su user3为什么显示-bash-4.2$ 的原因 查看附加组 [root@centos7 ~]# id ming uid=1001(ming) gid=1001(ming) groups=1001(ming) [root@centos7 ~]# [root@centos7 ~]# [root@centos7 ~]# groupmems --help Usage: groupmems [options] [action] Options: -g, --group groupname change groupname instead of the user's group (root only) -R, --root CHROOT_DIR directory to chroot into Actions: -a, --add username add username to the members of the group -d, --delete username remove username from the members of the group -h, --help display this help message and exit -p, --purge purge all members from the group -l, --list list the members of the group [root@centos7 ~]# groupmems -l -g ming [root@centos7 ~]# groupadd g1 [root@centos7 ~]# groupadd g2 [root@centos7 ~]# groupadd g3 [root@centos7 ~]# usermod -G ming g1,g2,g3 usermod: user 'g1,g2,g3' does not exist [root@centos7 ~]# usermod -G ming g1 g2 g3 [root@centos7 ~]# usermod -G g1,g2,g3 ming # 注意次序 [root@centos7 ~]# id ming uid=1001(ming) gid=1001(ming) groups=1001(ming),1015(g1),1016(g2),1017(g3) [root@centos7 ~]# groupmes -l -g ming -bash: groupmes: command not found [root@centos7 ~]# groupmems -l -g ming [root@centos7 ~]# groupmems -l -g g1 # 这是以某个组为线索看谁把它作为附加组了 ming [root@centos7 ~]# groupmems -l -g g2 ming [root@centos7 ~]# groupmems -l -g g3 ming [root@centos7 ~]# -----如果本身就是group的附加组，newgrp直接切成主组 无需密码-----👇---- [11:41:27 root@localhost ~]#usermod -G g12 user1 [11:41:43 root@localhost ~]#id user1 uid=1008(user1) gid=1009(user1) groups=1009(user1),1013(g12) [11:41:47 root@localhost ~]#id uid=0(root) gid=0(root) groups=0(root) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 [11:41:48 root@localhost ~]#su - user1 Last login: Mon Jan 17 20:48:42 CST 2022 on pts/0 [11:41:55 user1@localhost ~]$id uid=1008(user1) gid=1009(user1) groups=1009(user1),1013(g12) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 [11:42:01 user1@localhost ~]$id user1 uid=1008(user1) gid=1009(user1) groups=1009(user1),1013(g12) [11:42:03 user1@localhost ~]$newgrp g12 [11:42:09 user1@localhost ~]$id uid=1008(user1) gid=1013(g12) groups=1013(g12),1009(user1) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 [11:42:10 user1@localhost ~]$exit exit [11:42:25 user1@localhost ~]$exit logout [11:42:29 root@localhost ~]#groupmems -l -g g12 user1 [11:42:35 root@localhost ~]# 删除附加组成员 [11:42:29 root@localhost ~]#groupmems -l -g g12 user1 [11:45:06 root@localhost ~]#groupmems -l -g g12 user1 [11:45:08 root@localhost ~]#id user1 uid=1008(user1) gid=1009(user1) groups=1009(user1),1013(g12) [11:45:24 root@localhost ~]#groupmems -d user1 -g g12 [11:45:30 root@localhost ~]#id user1 uid=1008(user1) gid=1009(user1) groups=1009(user1) [11:45:32 root@localhost ~]# 这个只是附加组里的成员 [11:47:07 root@localhost ~]#groupmems -d user1 -g user1 groupmems: user 'user1' is not a member of 'user1' [11:47:12 root@localhost ~]#id user1 uid=1008(user1) gid=1009(user1) groups=1009(user1) 其实usermod就挺好，方法有点多，哈哈 [11:49:06 root@localhost ~]#id user1 uid=1008(user1) gid=1009(user1) groups=1009(user1),1014(g13) [11:49:08 root@localhost ~]#usermod -G g12,g13 user1 [11:49:19 root@localhost ~]#id user1 uid=1008(user1) gid=1009(user1) groups=1009(user1),1013(g12),1014(g13) [11:49:21 root@localhost ~]#usermod -G g12 user1 [11:49:46 root@localhost ~]#id user1 uid=1008(user1) gid=1009(user1) groups=1009(user1),1013(g12) [11:49:48 root@localhost ~]# 清空组中所有成员 工具各有所长 [11:51:22 root@localhost ~]#id user1 uid=1008(user1) gid=1009(user1) groups=1009(user1),1013(g12) [11:51:24 root@localhost ~]#usermod -G g12 user2 [11:51:44 root@localhost ~]#usermod -G g12 user3 [11:51:46 root@localhost ~]#id user1 uid=1008(user1) gid=1009(user1) groups=1009(user1),1013(g12) [11:51:48 root@localhost ~]#id user2 uid=1009(user2) gid=1010(user2) groups=1010(user2),1013(g12) [11:51:48 root@localhost ~]#id user3 uid=1010(user3) gid=1011(user3) groups=1011(user3),1013(g12) [11:51:49 root@localhost ~]# [11:51:49 root@localhost ~]#groupmems -l -g g12 user1 user2 user3 [11:51:57 root@localhost ~]# 情况附加组成员就用groupmems [11:51:49 root@localhost ~]#groupmems -l -g g12 user1 user2 user3 [11:51:57 root@localhost ~]# [11:52:28 root@localhost ~]#groupmems -p -g g12 [11:52:53 root@localhost ~]#groupmems -l -g g12 [11:52:56 root@localhost ~]#id user1 uid=1008(user1) gid=1009(user1) groups=1009(user1) [11:52:59 root@localhost ~]#id user2 uid=1009(user2) gid=1010(user2) groups=1010(user2) [11:53:02 root@localhost ~]#id user3 uid=1010(user3) gid=1011(user3) groups=1011(user3) [11:53:02 root@localhost ~]# 不知道主组成员能不能清 [11:53:55 root@localhost ~]#usermod -g g12 user1 [11:54:03 root@localhost ~]#id user1 uid=1008(user1) gid=1013(g12) groups=1013(g12) [11:54:05 root@localhost ~]#groupmems -l -g g12 [11:54:18 root@localhost ~]#groupmems -p -g g12 [11:54:35 root@localhost ~]#groupmems -l -g g12 [11:54:35 root@localhost ~]# --------👆肯定不能了，主组是不归groupmems管的----------- useradd\\usermod\\userdel基本上这些事都能做， groupmems这个命令有问题啊 [root@centos7 ~]# id user1 uid=1000(user1) gid=1000(user1) groups=1000(user1),1014(g12) [root@centos7 ~]# whatis groupmems groupmems (8) - administer members of a user's primary group [root@centos7 ~]# groupmems -l -g user1 [root@centos7 ~]# groupmems -l -g g12 user1 [root@centos7 ~]# ---------毛的primary group，它就是个附加组管理工具------------👆------------ 练习 创建用户cacti，附加组为bin和root，默认shell为/bin/csh，注释信息为\"i am a cacti\" useradd -s /bin/csh -G bin,root -c \"i am a cacti\" cacti [root@centos7 ~]# useradd -s /bin/csh -G bin,root -c \"i am a cacti\" cacti [root@centos7 ~]# id cacti uid=1007(cacti) gid=1007(cacti) groups=1007(cacti),0(root),1(bin) [root@centos7 ~]# getent passwd cacti cacti:x:1007:1007:i am a cacti:/home/cacti:/bin/csh [root@centos7 ~]# finger cacti Login: cacti Name: i am a cacti Directory: /home/cacti Shell: /bin/csh Never logged in. No mail. No Plan. [root@centos7 ~]# 创建下面的用户、组和组成员关系， 名字为webs的组， 用户nginx，使用webs作为附加组 用户varnish，使用webs作为附加组 用户mysql，不可交互登入西路，且不是webs的成员 nginx,varnish,mysql密码都是cisco groupadd webs useradd -G webs nginx useradd -G webs varnish useradd -s /sbin/nologin mysql cat p.set nginx:cisco varnish:cisco mysql:cisco EOF cat p.set |chpasswd ---------------------------👇检查下，效果杠杠的----------------------- --------👆上面讲了用户和组，👇下面开始整理文件针对这些用户和组的权限------- QoS， diff serv （打标\\分类+后面的管制、限速、队列）也是这个道理，区别对待，上面的用户和组就是区别，下面针对这些人设置对应文件的访问就是对待。 文件权限 chown修改文件所属 [root@centos7 ~]# touch /data/f1 [root@centos7 ~]# su - user1 Last login: Mon Feb 7 12:33:30 CST 2022 on pts/0 [user1@centos7 ~]$ ll /data/f1 -rw-r--r--. 1 root root 0 Feb 7 12:33 /data/f1 [user1@centos7 ~]$ cat /data/f1 [user1@centos7 ~]$ echo 111 > /data/f1 -bash: /data/f1: Permission denied -------👆user1作为other没有f1的写权限----------- -------👇chown就可以修改文件的所有者和所属组，好像也用不到chgrp------- [user1@centos7 ~]$ [user1@centos7 ~]$ exit logout [root@centos7 ~]# chown user1 /data/f1 [root@centos7 ~]# ll /data/f1 -rw-r--r--. 1 user1 root 0 Feb 7 12:33 /data/f1 [root@centos7 ~]# chown :g12 /data/f1 [root@centos7 ~]# ll /data/f1 -rw-r--r--. 1 user1 g12 0 Feb 7 12:33 /data/f1 [root@centos7 ~]# ll /data/f1 -rw-r--r--. 1 user1 g12 0 Feb 7 12:33 /data/f1 [root@centos7 ~]# chown root:g13 /data/f1 chown: invalid group: ‘root:g13’ [root@centos7 ~]# chown root:g1 /data/f1 [root@centos7 ~]# ll /data/f1 -rw-r--r--. 1 root g1 0 Feb 7 12:33 /data/f1 [root@centos7 ~]# chown user1.g12 /data/f1 [root@centos7 ~]# ll /data/f1 -rw-r--r--. 1 user1 g12 0 Feb 7 12:33 /data/f1 --------👇chgrp就是文件属组---------- [root@centos7 ~]# chgrp g2 /data/f1 [root@centos7 ~]# ll /data/f1 -rw-r--r--. 1 user1 g2 0 Feb 7 12:33 /data/f1 [root@centos7 ~]# chmod修改文件权限 模式法： chmod who opt per file who: u,g,o,a opt: +,-,= per: r,w,x 去掉文件的所有者r权限：chmod u-r file [user1@centos7 ~]$ ll total 4 -rw-rw-r--. 1 user1 user1 0 Feb 6 20:23 file1 [user1@centos7 ~]$ chmod u-r file1 [user1@centos7 ~]$ ll total 4 --w-rw-r--. 1 user1 user1 0 Feb 6 20:23 file1 [user1@centos7 ~]$ ---------此时再看👇user1用户对file1的权限的情况----------- [user1@centos7 ~]$ cat file1 cat: file1: Permission denied [user1@centos7 ~]$ echo xx >> file1 [user1@centos7 ~]$ ll total 8 --w-rw-r--. 1 user1 user1 3 Feb 7 13:43 file1 -rwxrwxrwx. 1 root root 839 Jan 10 14:20 fstab [user1@centos7 ~]$ -----------可见👆权限是所属者适用就只看所属者了--------------- ---------------user>group>other-----3个权限只一个有效--------- [root@centos7 ~]# chmod u=-,g=r,o=rwx /data/f1 [root@centos7 ~]# ll /data/f1 ----r--rwx. 1 user1 g2 3 Feb 7 13:48 /data/f1 [root@centos7 ~]# su user1 [user1@centos7 root]$ cat /data/f1 cat: /data/f1: Permission denied [user1@centos7 root]$ echo xx > /data/f1 bash: /data/f1: Permission denied [user1@centos7 root]$ exit exit [root@centos7 ~]# su user2 [user2@centos7 root]$ cat /data/f1 11 [user2@centos7 root]$ echo xx > /data/f1 [user2@centos7 root]$ cat /data/f1 xx [user2@centos7 root]$ --------------user1的文件权限user1自然可以加回去-------👇--- [user1@centos7 root]$ ll /data/f1 ----r--rwx. 1 user1 g2 3 Feb 7 13:52 /data/f1 [user1@centos7 root]$ chmod u=rwx /data/f1 [user1@centos7 root]$ ll /data/f1 -rwxr--rwx. 1 user1 g2 3 Feb 7 13:52 /data/f1 [user1@centos7 root]$ cat /data/f1 xx [user1@centos7 root]$ echo yy >> /data/f1 [user1@centos7 root]$ cat /data/f1 xx yy [user1@centos7 root]$ ----------非文件拥有者自然不能修改该文件的属性👇------------- [root@centos7 ~]# su user2 [user2@centos7 root]$ ll /data/f1 -rwxr--rwx. 1 user1 g2 6 Feb 7 13:53 /data/f1 [user2@centos7 root]$ chmod u=rx /data/f1 chmod: changing permissions of ‘/data/f1’: Operation not permitted [user2@centos7 root]$ chmod g=- /data/f1 chmod: changing permissions of ‘/data/f1’: Operation not permitted [user2@centos7 root]$ [root@centos7 ~]# chmod a=rwx /data/f1 [root@centos7 ~]# ll /data/f1 -rwxrwxrwx. 1 user1 g2 6 Feb 7 13:53 /data/f1 [root@centos7 ~]# chmod a=- /data/f1 [root@centos7 ~]# ll /data/f1 ----------. 1 user1 g2 6 Feb 7 13:53 /data/f1 [root@centos7 ~]# chmod a=r /data/f1 [root@centos7 ~]# ll /data/f1 -r--r--r--. 1 user1 g2 6 Feb 7 13:53 /data/f1 [root@centos7 ~]# chmod a= /data/f1 [root@centos7 ~]# ll /data/f1 ----------. 1 user1 g2 6 Feb 7 13:53 /data/f1 [root@centos7 ~]# ------------谁都不行，root还行👇------root超脱🐟权限除了x执行权限----- [root@centos7 ~]# chown root.root /data/f1 [root@centos7 ~]# ll /data/f1 ----------. 1 root root 9 Feb 7 13:59 /data/f1 [root@centos7 ~]# cat /data/f1 xx yy zz [root@centos7 ~]# echo ee >> /data/f1 [root@centos7 ~]# cat /data/f1 xx yy zz ee [root@centos7 ~]# ---------👇--执行权限root要是没有的，也不行，root也就rw读写不受权限影响----- [root@centos7 ~]# ll /bin/cat -rwxr-xr-x. 1 root root 54080 Aug 20 2019 /bin/cat [root@centos7 ~]# [root@centos7 ~]# chow a-x /bin/cat -bash: chow: command not found [root@centos7 ~]# chmod a-x /bin/cat [root@centos7 ~]# ll /bin/cat -rw-r--r--. 1 root root 54080 Aug 20 2019 /bin/cat [root@centos7 ~]# cat /data/f1 -bash: /usr/bin/cat: Permission denied [root@centos7 ~]# /bin/cat /data/f1 -bash: /bin/cat: Permission denied [root@centos7 ~]# chmod +x /bin/cat # 这里等价于a+x [root@centos7 ~]# cat /data/f1 xx yy zz ee -------👇----root比较牛逼，只要u、g、o里一个角色有执行权限，那他就有权限了--------- [root@centos7 ~]# ll /bin/cat -rwxr-xr-x. 1 root root 54080 Aug 20 2019 /bin/cat [root@centos7 ~]# chmod u-x,g-x /bin/cat [root@centos7 ~]# ll /bin/cat -rw-r--r-x. 1 root root 54080 Aug 20 2019 /bin/cat [root@centos7 ~]# cat /data/f1 xx yy zz ee [root@centos7 ~]# 修改目录下所有文件和子目录的权限，这个R特别的坑和rm也差不多了 [root@centos7 ~]# ll /data/ total 8 -rw-r--r--. 1 root root 151 Feb 6 19:31 change_passwd.sh ----------. 1 root root 12 Feb 7 14:19 f1 -rw-r--r--. 1 root root 0 Feb 7 14:19 f10 -rw-r--r--. 1 root root 0 Feb 7 14:19 f11 -rw-r--r--. 1 root root 0 Feb 7 14:19 f12 -rw-r--r--. 1 root root 0 Feb 7 14:19 f13 -rw-r--r--. 1 root root 0 Feb 7 14:19 f14 -rw-r--r--. 1 root root 0 Feb 7 14:19 f15 -rw-r--r--. 1 root root 0 Feb 7 14:19 f16 -rw-r--r--. 1 root root 0 Feb 7 14:19 f17 -rw-r--r--. 1 root root 0 Feb 7 14:19 f18 -rw-r--r--. 1 root root 0 Feb 7 14:19 f19 -rw-r--r--. 1 root root 0 Feb 7 14:19 f2 -rw-r--r--. 1 root root 0 Feb 7 14:19 f20 -rw-r--r--. 1 root root 0 Feb 7 14:19 f3 -rw-r--r--. 1 root root 0 Feb 7 14:19 f4 -rw-r--r--. 1 root root 0 Feb 7 14:19 f5 -rw-r--r--. 1 root root 0 Feb 7 14:19 f6 -rw-r--r--. 1 root root 0 Feb 7 14:19 f7 -rw-r--r--. 1 root root 0 Feb 7 14:19 f8 -rw-r--r--. 1 root root 0 Feb 7 14:19 f9 [root@centos7 ~]# chmod a+x -R /data/ [root@centos7 ~]# ll /data/ -d drwxr-xr-x. 2 root root 241 Feb 7 14:19 /data/ [root@centos7 ~]# ll /data/ total 8 -rwxr-xr-x. 1 root root 151 Feb 6 19:31 change_passwd.sh ---x--x--x. 1 root root 12 Feb 7 14:19 f1 -rwxr-xr-x. 1 root root 0 Feb 7 14:19 f10 -rwxr-xr-x. 1 root root 0 Feb 7 14:19 f11 -rwxr-xr-x. 1 root root 0 Feb 7 14:19 f12 -rwxr-xr-x. 1 root root 0 Feb 7 14:19 f13 -rwxr-xr-x. 1 root root 0 Feb 7 14:19 f14 -rwxr-xr-x. 1 root root 0 Feb 7 14:19 f15 -rwxr-xr-x. 1 root root 0 Feb 7 14:19 f16 -rwxr-xr-x. 1 root root 0 Feb 7 14:19 f17 -rwxr-xr-x. 1 root root 0 Feb 7 14:19 f18 -rwxr-xr-x. 1 root root 0 Feb 7 14:19 f19 -rwxr-xr-x. 1 root root 0 Feb 7 14:19 f2 -rwxr-xr-x. 1 root root 0 Feb 7 14:19 f20 -rwxr-xr-x. 1 root root 0 Feb 7 14:19 f3 -rwxr-xr-x. 1 root root 0 Feb 7 14:19 f4 -rwxr-xr-x. 1 root root 0 Feb 7 14:19 f5 -rwxr-xr-x. 1 root root 0 Feb 7 14:19 f6 -rwxr-xr-x. 1 root root 0 Feb 7 14:19 f7 -rwxr-xr-x. 1 root root 0 Feb 7 14:19 f8 -rwxr-xr-x. 1 root root 0 Feb 7 14:19 f9 [root@centos7 ~]# [root@centos7 ~]# ll /data/ total 8 -rw-r--r--. 1 root root 151 Feb 6 19:31 change_passwd.sh ----------. 1 root root 12 Feb 7 14:19 f1 -rw-r--r--. 1 root root 0 Feb 7 14:19 f10 -rw-r--r--. 1 root root 0 Feb 7 14:19 f11 -rw-r--r--. 1 root root 0 Feb 7 14:19 f12 -rw-r--r--. 1 root root 0 Feb 7 14:19 f13 -rw-r--r--. 1 root root 0 Feb 7 14:19 f14 -rw-r--r--. 1 root root 0 Feb 7 14:19 f15 -rw-r--r--. 1 root root 0 Feb 7 14:19 f16 -rw-r--r--. 1 root root 0 Feb 7 14:19 f17 -rw-r--r--. 1 root root 0 Feb 7 14:19 f18 -rw-r--r--. 1 root root 0 Feb 7 14:19 f19 -rw-r--r--. 1 root root 0 Feb 7 14:19 f2 -rw-r--r--. 1 root root 0 Feb 7 14:19 f20 -rw-r--r--. 1 root root 0 Feb 7 14:19 f3 -rw-r--r--. 1 root root 0 Feb 7 14:19 f4 -rw-r--r--. 1 root root 0 Feb 7 14:19 f5 -rw-r--r--. 1 root root 0 Feb 7 14:19 f6 -rw-r--r--. 1 root root 0 Feb 7 14:19 f7 -rw-r--r--. 1 root root 0 Feb 7 14:19 f8 -rw-r--r--. 1 root root 0 Feb 7 14:19 f9 [root@centos7 ~]# chown -R user1 /data/ [root@centos7 ~]# ll /data/ total 8 -rw-r--r--. 1 user1 root 151 Feb 6 19:31 change_passwd.sh ----------. 1 user1 root 12 Feb 7 14:19 f1 -rw-r--r--. 1 user1 root 0 Feb 7 14:19 f10 -rw-r--r--. 1 user1 root 0 Feb 7 14:19 f11 -rw-r--r--. 1 user1 root 0 Feb 7 14:19 f12 -rw-r--r--. 1 user1 root 0 Feb 7 14:19 f13 -rw-r--r--. 1 user1 root 0 Feb 7 14:19 f14 -rw-r--r--. 1 user1 root 0 Feb 7 14:19 f15 -rw-r--r--. 1 user1 root 0 Feb 7 14:19 f16 -rw-r--r--. 1 user1 root 0 Feb 7 14:19 f17 -rw-r--r--. 1 user1 root 0 Feb 7 14:19 f18 -rw-r--r--. 1 user1 root 0 Feb 7 14:19 f19 -rw-r--r--. 1 user1 root 0 Feb 7 14:19 f2 -rw-r--r--. 1 user1 root 0 Feb 7 14:19 f20 -rw-r--r--. 1 user1 root 0 Feb 7 14:19 f3 -rw-r--r--. 1 user1 root 0 Feb 7 14:19 f4 -rw-r--r--. 1 user1 root 0 Feb 7 14:19 f5 -rw-r--r--. 1 user1 root 0 Feb 7 14:19 f6 -rw-r--r--. 1 user1 root 0 Feb 7 14:19 f7 -rw-r--r--. 1 user1 root 0 Feb 7 14:19 f8 -rw-r--r--. 1 user1 root 0 Feb 7 14:19 f9 [root@centos7 ~]# [root@centos7 ~]# ll /data/ -d drw-r--r--. 2 user1 root 241 Feb 7 14:19 /data/ -------坑在这里👇----- rm -rf / data #小手一抖，空格全没有 chmod -R a=rwx / data #小手再都，大妈食堂有 ------👆你把/根下所有的文件夹和子文件权限都弄了，更狠的来了👇---- chown -R user1 / data #/根下所有文件夹和文件所有者都变成了user1了 参考别的文件设置同样的用户和组，以及权限 [root@centos7 ~]# ll /etc/fstab -rw-r--r--. 1 root root 595 Jan 5 17:41 /etc/fstab [root@centos7 ~]# ll /data/f1 ----------. 1 user1 root 12 Feb 7 14:19 /data/f1 [root@centos7 ~]# chown --reference /etc/fstab /data/f1 [root@centos7 ~]# ll /data/f1 ----------. 1 root root 12 Feb 7 14:19 /data/f1 [root@centos7 ~]# chmod --reference /etc/fstab /data/f1 [root@centos7 ~]# ll /data/f1 -rw-r--r--. 1 root root 12 Feb 7 14:19 /data/f1 [root@centos7 ~]# Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-02-02 14:46:52 "},"6-用户、用户组和权限/3-文件和特殊权限.html":{"url":"6-用户、用户组和权限/3-文件和特殊权限.html","title":"第3节 文件和特殊权限","keywords":"","body":"第3节. 文件和特殊权限 接上文，模式法 chmod who opt per file who: u,g,o,a opt: +,-,= per: r,w,x 数字法 rwxrw-r-- f1 111110100 👉 111 110 100 = 7 6 4 r 4 w 2 x 1 文件夹的权限 w：针对文件夹，就是创建、删除其中的文件。而修改文件涉及的是文件本身的写权限。 ----------👇--------------------------------- [user1@centos7 dir]$ ll ./ -d drwxr-xr-x. 2 root root 16 Feb 8 09:23 ./ # 文件夹dir的权限 [root@centos7 dir]# su user1 [user1@centos7 dir]$ ll total 0 -rw-r--rw-. 1 root root 0 Feb 8 09:23 f1 [user1@centos7 dir]$ touch 11 touch: cannot touch ‘11’: Permission denied [user1@centos7 dir]$ vi f1 [user1@centos7 dir]$ cat f1 111 [user1@centos7 dir]$ rm f1 rm: cannot remove ‘f1’: Permission denied [user1@centos7 dir]$ echo xxx > f1 [user1@centos7 dir]$ cat f1 xxx [user1@centos7 dir]$ r: 读权限针对文件夹就是看不到文件夹下面的内容，但是如果你知道某个文件的名称，是可以直接看该文件内容的。 [root@centos7 data]# chmod o-r dir/ [root@centos7 data]# ll total 0 drwxr-x--x. 2 root root 16 Feb 8 09:46 dir [root@centos7 data]# su user1 [user1@centos7 data]$ cat dir/f1 xx [user1@centos7 data]$ cd dir [user1@centos7 dir]$ ls ls: cannot open directory .: Permission denied [user1@centos7 dir]$ cat f1 xx [user1@centos7 dir]$ ll -d f1 -rw-r--r--. 1 root root 3 Feb 8 09:48 f1 [user1@centos7 dir]$ ll ls: cannot open directory .: Permission denied [user1@centos7 dir]$ x：执行权限针对文件夹就是进入咯，这个执行一旦取消，关系就大了，你连文件夹都进不去，那么文件夹下的文件就看不到 dir/f1 bash: dir/f1: Permission denied [user1@centos7 data]$ ll dir/ ls: cannot open directory dir/: Permission denied [user1@centos7 data]$ 👇-----给上面的dir补一个r读权限---- [root@centos7 data]# chmod o=r dir [root@centos7 data]# ll total 0 drwxr-xr--. 2 root root 16 Feb 8 09:46 dir [root@centos7 data]# ll dir/f1 -rw-r--rw-. 1 root root 3 Feb 8 09:48 dir/f1 [root@centos7 data]# [root@centos7 data]# su user1 [user1@centos7 data]$ ll dir ls: cannot access dir/f1: Permission denied total 0 -????????? ? ? ? ? ? f1 # 👈元数据看不到，文件名字倒是可以的 [user1@centos7 data]$ cd dir bash: cd: dir: Permission denied [user1@centos7 data]$ ll dir/f1 ls: cannot access dir/f1: Permission denied [user1@centos7 data]$ 文件夹来讲： 目录存放的数据块里的内容是各个文件名和其对应的节点信息 文件存放的数据块里的内容是文件的内容 读：可以列出该文件夹下的文件名，拿掉后，如果知道文件夹下的文件名，也能通过/dir/file去直接cat（这取决于文件本身的r权限）。 执行：可以进入目录，可以访问目录里的文件内容(依赖于文件本身的r权限)。 写：决定是否可以在目录里面创建和删除文件。文件本身的权限还得看文件自己的。 注意，w需要x加持~如果文件夹的执行权限取消，及时有写权限，由于进不到该目录下，所以也就没法去写文件的。 说下大X，后面再将st [root@centos7 data]# ll total 0 drwxr-xr--. 2 root root 16 Feb 8 09:46 dir -rw-r--r--. 1 root root 0 Feb 8 11:31 f1 -rw-r--r--. 1 root root 0 Feb 8 11:31 f2 [root@centos7 data]# chmod -R a+x /data [root@centos7 data]# ll /data total 0 drwxr-xr-x. 2 root root 16 Feb 8 09:46 dir -rwxr-xr-x. 1 root root 0 Feb 8 11:31 f1 -rwxr-xr-x. 1 root root 0 Feb 8 11:31 f2 [root@centos7 data]# ll /data -d drwxr-xr-x. 3 root root 37 Feb 8 11:31 /data ------👆通过-R可以使文件夹和其下所有文件的权限都递归改掉----- 但是如果遇到文件你给它一个x执行权限，往往存在安全风险---所以-R 配合大X就可以过滤文件的权限修改 👇 [root@centos7 data]# chmod -R a-x /data/ [root@centos7 data]# ll /data/ total 0 drw-r--r--. 2 root root 16 Feb 8 09:46 dir -rw-r--r--. 1 root root 0 Feb 8 11:31 f1 -rw-r--r--. 1 root root 0 Feb 8 11:31 f2 [root@centos7 data]# chmod -R a+X /data/ [root@centos7 data]# ll /data/ total 0 drwxr-xr-x. 2 root root 16 Feb 8 09:46 dir -rw-r--r--. 1 root root 0 Feb 8 11:31 f1 -rw-r--r--. 1 root root 0 Feb 8 11:31 f2 [root@centos7 data]# 练习： 误删了用户ming的家目录，进行恢复 三条命令 cp -r /etc/skel /home/ming chown -R ming.ming /home/ming chmod 700 /home/ming # 里面的几个隐藏文件都是从/etc/skel下复制过来的，属性不变就好。 ---误删除了用户ming家目录下的文件，但是目录还在，进行恢复👇 [root@centos7 ~]# rm -rf /home/ming/.* rm: refusing to remove ‘.’ or ‘..’ directory: skipping ‘/home/ming/.’ rm: refusing to remove ‘.’ or ‘..’ directory: skipping ‘/home/ming/..’ [root@centos7 ~]# ll -a /home/ming total 0 drwx------. 2 ming ming 6 Feb 8 13:43 . drwxr-xr-x. 16 root root 192 Feb 8 12:01 .. --👇注意，此时通过.*复制/etc/skel/下的所有文件--包含隐藏和非隐藏，会有大问题🐕-- [root@centos7 home]# cp -r /etc/skel/.* /home/ming cp: will not create hard link ‘/home/ming/skel’ to directory ‘/home/ming/.’ cp: overwrite ‘/home/ming/.bash_logout’? ^C [root@centos7 home]# ll /home/ming total 1036 -rw-r--r--. 1 root root 16 Feb 8 13:44 adjtime -rw-r--r--. 1 root root 1529 Feb 8 13:44 aliases -rw-r--r--. 1 root root 12288 Feb 8 13:44 aliases.db drwxr-xr-x. 2 root root 236 Feb 8 13:44 alternatives -rw-------. 1 root root 541 Feb 8 13:44 anacrontab -rw-r--r--. 1 root root 55 Feb 8 13:44 asound.conf drwxr-x---. 3 root root 43 Feb 8 13:44 audisp drwxr-x---. 3 root root 83 Feb 8 13:44 audit drwxr-xr-x. 2 root root 22 Feb 8 13:44 bash_completion.d -rw-r--r--. 1 root root 2853 Feb 8 13:44 bashrc drwxr-xr-x. 2 root root 6 Feb 8 13:44 binfmt.d -rw-r--r--. 1 root root 37 Feb 8 13:44 centos-release -rw-r--r--. 1 root root 51 Feb 8 13:44 centos-release-upstream drwxr-xr-x. 2 root root 6 Feb 8 13:44 chkconfig.d drwxr-xr-x. 2 root root 21 Feb 8 13:44 cron.d drwxr-xr-x. 2 root root 42 Feb 8 13:44 cron.daily -rw-------. 1 root root 0 Feb 8 13:44 cron.deny drwxr-xr-x. 2 root root 22 Feb 8 13:44 cron.hourly drwxr-xr-x. 2 root root 6 Feb 8 13:44 cron.monthly -rw-r--r--. 1 root root 451 Feb 8 13:44 crontab drwxr-xr-x. 2 root root 6 Feb 8 13:44 cron.weekly -rw-------. 1 root root 0 Feb 8 13:44 crypttab -rw-r--r--. 1 root root 1620 Feb 8 13:44 csh.cshrc -rw-r--r--. 1 root root 1103 Feb 8 13:44 csh.login 👆发现复制很N多文件过来了，原因是因为.*通配符它代表.xxx还有..xxx所以复制.*意味着你不仅仅复制了当前目录下的所有文件，也复制了上级目录下的所有文件。 推荐👇👉使用cp -r /etc/skel/. /home/ming这种方式复制所有文件含隐藏文件 drwx------. 2 root root 6 Feb 8 13:52 ming [root@centos7 home]# cp -r /etc/skel/. /home/ming [root@centos7 home]# ll -a ming total 12 drwx------. 2 root root 72 Feb 8 13:53 . drwxr-xr-x. 16 root root 192 Feb 8 13:52 .. -rw-r--r--. 1 root root 18 Feb 8 13:53 .bash_logout -rw-r--r--. 1 root root 193 Feb 8 13:53 .bash_profile -rw-r--r--. 1 root root 231 Feb 8 13:53 .bashrc -rw-r--r--. 1 root root 0 Feb 8 13:53 f1 [root@centos7 home]# ------👇这样也行，就是通过.[^.]*来表示所有隐藏文件，和*来表示所有非隐藏文件---- [root@centos7 home]# cp -r /etc/skel/.[^.]* /home/ming [root@centos7 home]# ll /home/ming -a total 12 drwx------. 2 root root 62 Feb 8 13:55 . drwxr-xr-x. 16 root root 192 Feb 8 13:52 .. -rw-r--r--. 1 root root 18 Feb 8 13:55 .bash_logout -rw-r--r--. 1 root root 193 Feb 8 13:55 .bash_profile -rw-r--r--. 1 root root 231 Feb 8 13:55 .bashrc [root@centos7 home]# cp -r /etc/skel/* /home/ming [root@centos7 home]# ll /home/ming -a total 12 drwx------. 2 root root 72 Feb 8 13:55 . drwxr-xr-x. 16 root root 192 Feb 8 13:52 .. -rw-r--r--. 1 root root 18 Feb 8 13:55 .bash_logout -rw-r--r--. 1 root root 193 Feb 8 13:55 .bash_profile -rw-r--r--. 1 root root 231 Feb 8 13:55 .bashrc -rw-r--r--. 1 root root 0 Feb 8 13:55 f1 [root@centos7 home]# mkdir创建文件夹的时候可以设置权限 [root@centos7 home]# mkdir --help Usage: mkdir [OPTION]... DIRECTORY... Create the DIRECTORY(ies), if they do not already exist. Mandatory arguments to long options are mandatory for short options too. -m, --mode=MODE set file mode (as in chmod), not a=rwx - umask -p, --parents no error if existing, make parent directories as needed -v, --verbose print a message for each created directory -Z set SELinux security context of each created directory to the default type --context[=CTX] like -Z, or if CTX is specified then set the SELinux or SMACK security context to CTX --help display this help and exit --version output version information and exit GNU coreutils online help: For complete documentation, run: info coreutils 'mkdir invocation' [root@centos7 home]# [root@centos7 ~]# mkdir -m 000 /home/sb001 [root@centos7 ~]# ll /home/sb001 -d d---------. 2 root root 6 Feb 8 14:00 /home/sb001 [root@centos7 ~]# 文件的特殊权限 /etc/shaow这个文件普通用户没有权限对其修改，但是可以通过passwd命令对其进行修改的，因为改自身密码本质上就是修改了shadow文件。 [root@centos7 ~]# ll /etc/shadow ----------. 1 root root 1366 Feb 8 14:06 /etc/shadow [root@centos7 ~]# su user1 [user1@centos7 root]$ cat /etc/shadow cat: /etc/shadow: Permission denied [user1@centos7 root]$ echo xx /etc/shadow xx /etc/shadow [user1@centos7 root]$ echo xx >> /etc/shadow bash: /etc/shadow: Permission denied [user1@centos7 root]$ passwd Changing password for user user1. Changing password for user1. (current) UNIX password: passwd: Authentication token manipulation error [user1@centos7 root]$ passwd Changing password for user user1. Changing password for user1. (current) UNIX password: New password: Retype new password: passwd: all authentication tokens updated successfully. [user1@centos7 root] 这是因为passwd命令-也就是这/bin/passwd这个执行文件用户属性位上有s位。 [user1@centos7 root]$ ll /bin/passwd suid当用户使用该程序/命令访问某个文件的时候，原则上是使用这个用户的权限去访问文件。 一旦有了suid，不管谁运行这个程序，通过这个程序访问文件，就是获得这个程序所有者的权限。上图只要你运行passwd，你的身份就转换为root了。suid全称就是set owner user id up to execution在执行时设置所有者用户ID。 第二点，suid一定是作用在二进制的可执行的文件上(对shell脚本无效)，否则没有意义了就。所以大S没有意义-去掉x后就是大S [root@centos7 ~]# ll /usr/bin/vi -rwsr-xr-x. 1 root root 928056 Oct 14 2020 /usr/bin/vi [root@centos7 ~]# su user su: user user does not exist [root@centos7 ~]# su user1 [user1@centos7 root]$ vi /etc/shadow # 此时就可以vi进去修改并保持了 [user1@centos7 root]$ echo xxx >> /etc/shadow # echo不行肯定的啊你suid的是vim啊 bash: /etc/shadow: Permission denied ----------这个，，，尝试将echo变成suid权限，发现还是不行，可能要该重定向文件咯呵呵---- [root@centos7 ~]# which echo /usr/bin/echo [root@centos7 ~]# ll /usr/bin/echo -rwxr-xr-x. 1 root root 33088 Aug 20 2019 /usr/bin/echo [root@centos7 ~]# chmod u+s /usr/bin/echo [root@centos7 ~]# ll /usr/bin/echo -rwsr-xr-x. 1 root root 33088 Aug 20 2019 /usr/bin/echo [root@centos7 ~]# su user1 [user1@centos7 root]$ echo xx >> /etc/shadow bash: /etc/shadow: Permission denied [user1@centos7 root]$ exit exit [root@centos7 ~]# which >> -bash: syntax error near unexpected token `newline' [root@centos7 ~]# 数字法修改suid： 4是单独算的 [root@centos7 ~]# ll /usr/bin/echo -rwsr-xr-x. 1 root root 33088 Aug 20 2019 /usr/bin/echo [root@centos7 ~]# chmod 755 /usr/bin/echo [root@centos7 ~]# ll /usr/bin/echo -rwxr-xr-x. 1 root root 33088 Aug 20 2019 /usr/bin/echo [root@centos7 ~]# chmod 4755 /usr/bin/echo [root@centos7 ~]# ll /usr/bin/echo -rwsr-xr-x. 1 root root 33088 Aug 20 2019 /usr/bin/echo [root@centos7 ~]# sgid 1、如果某个用户运行cat程序也即是使用cat去访问文件，就会继承所属组的权限。或者说就会将用户原本的所属组提升至该程序的所属组。 同样数字法 755前面补一个2，sgid 755前面补一个4，sguid 755前面补一个6，suid+sgid 粘滞位 针对文件夹的属性 非用户本人，无法删除文件夹下的文件 粘滞位对文件不生效 [root@centos7 dir]# su user1 [user1@centos7 dir]$ ll total 0 -rw-r--r--. 1 root root 0 Feb 8 16:19 f1 -rw-rw-r-T. 1 user1 user1 0 Feb 8 16:22 f2 [user1@centos7 dir]$ rm -rf f2 [user1@centos7 dir]$ ll total 0 -rw-r--r--. 1 root root 0 Feb 8 16:19 f1 [user1@centos7 dir]$ 总结 suid： ​ 作用于可执行的二进制的程序，权限4，功能：用户执行此程序时，将继承此程序所有者的权限。 sguid： ​ 作用于可执行的二进制的程序，权限2，功能：用户执行此程序时，将集成此程序所属组的权限。 ​ 作用于目录，权限2，功能，新建的文件，将自动集成该目录的所属组。 sticky： ​ 作用于目录，权限1，功能：只能删除自己的文件，root不受限。 创建一个目录可以让有限的几个用户使用 [16:49:55 root@localhost data]#mkdir -m 770 testdir [16:50:10 root@localhost data]#ll total 1 drwxrwx---. 2 root root 6 Jan 19 16:50 testdir [16:52:38 root@localhost data]#chown .grp001 testdir [16:52:50 root@localhost data]#ll total 1 drwxrwx---. 2 root grp001 6 Jan 19 16:50 testdir [16:53:01 root@localhost data]#usermod -G grp001 user1 [16:54:31 root@localhost data]#usermod -G grp001 user2 [16:55:01 root@localhost data]#groupmems -l -g grp001 user1 user2 [16:55:14 root@localhost data]#su user1 [16:55:19 user1@localhost data]$cd testdir/ [16:55:28 user1@localhost testdir]$touch f1 [16:55:30 user1@localhost testdir]$echo 11 >> f1 [16:55:34 user1@localhost testdir]$exit exit [16:55:36 root@localhost data]#su user2 [16:55:43 user2@localhost data]$cd testdir/ [16:55:54 user2@localhost testdir]$echo xx >> f2 [16:56:06 user2@localhost testdir]$cat f2 xx 貌似centos7.9和7.6这里有个不一样的点👇 就是user1可以修改user2创建的文件，如果时之前的观点，就会再设置文件夹的sguid来使目录下的文件创建的时候自动集成父目录的所属组。 当然最好还是设置一下文件夹的sgid [root@centos7 data]# chmod g+s renyue/ [root@centos7 data]# ll total 0 drwxrws---. 2 root renyue-group 26 Feb 8 17:12 renyue [root@centos7 data]# [root@centos7 data]# su client1 [client1@centos7 data]$ ll total 0 drwxrws---. 2 root renyue-group 26 Feb 8 17:12 renyue [client1@centos7 data]$ cd renyue/ [client1@centos7 renyue]$ touch f3 [client1@centos7 renyue]$ ll total 4 -rw-rw-r--. 1 client1 client1 2 Feb 8 17:12 f1 -rw-rw-r--. 1 client2 client2 0 Feb 8 17:12 f2 -rw-rw-r--. 1 client1 renyue-group 0 Feb 8 17:35 f3 [client1@centos7 renyue]$ cp /etc/fstab /data/dir/ 普通需要什么权限？ cp 命令的执行权限 /etc文件夹的执行 fstab文件的读 /data文件夹的执行 /dir文件夹得执行和写 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-02-01 15:42:20 "},"6-用户、用户组和权限/4-umask权限.html":{"url":"6-用户、用户组和权限/4-umask权限.html","title":"第4节 umask权限","keywords":"","body":"第4节. umask权限 chattr i :文件不会被修改、删除、包含所在目录也不能被删除。 [19:40:28 root@localhost data]#chattr +i f1 [19:40:37 root@localhost data]#ll total 0 -rw-r--r--. 1 root root 0 Jan 19 19:40 f1 [19:40:38 root@localhost data]#lsattr f1 ----i--------------- f1 [19:41:22 root@localhost data]#rm -rf f1 rm: cannot remove 'f1': Operation not permitted [19:41:29 root@localhost data]#echo xx > f1 -bash: f1: Operation not permitted [19:41:32 root@localhost data]#mv f1 f2 mv: cannot move 'f1' to 'f2': Operation not permitted [19:41:36 root@localhost data]#cd .. [19:41:38 root@localhost /]#rm -rf /data/ rm: cannot remove '/data/f1': Operation not permitted [19:41:44 root@localhost /]# a:文件仅可以添加，同样所在目录不能被删除 [19:45:29 root@localhost data]#chattr +a f1 [19:45:36 root@localhost data]#lsattr f1 ----ia-------------- f1 [19:45:39 root@localhost data]#echo xx > f1 -bash: f1: Operation not permitted [19:45:45 root@localhost data]#echo xx >> f1 -bash: f1: Operation not permitted [19:45:48 root@localhost data]#chattr -i f1 [19:46:05 root@localhost data]#lsattr f1 -----a-------------- f1 [19:46:09 root@localhost data]#echo xx > f1 -bash: f1: Operation not permitted [19:46:13 root@localhost data]#echo xx >> f1 [19:46:16 root@localhost data]#cat f1 xx [19:46:19 root@localhost data]#rm -rf f1 rm: cannot remove 'f1': Operation not permitted [19:46:22 root@localhost data]#exit logout [19:46:54 root@localhost /]#rm -rf /data/ rm: cannot remove '/data/f1': Operation not permitted ---但是👇vi进去后在最后一行添加这种操作，系统判定不出来你是不是追加所以这种追加时不行的。 umask 1、root用户新建文件和文件夹可发现默认的权限分别时644和755 [19:57:42 root@localhost data]#ll total 0 drwxr-xr-x. 2 root root 6 Jan 19 19:57 dir -rw-r--r--. 1 root root 0 Jan 19 19:57 f1 [19:57:42 root@localhost data]# 2、换普通用户创建文件和文件夹权限就不一样 [putong@centos7 data]$ ll |grep putong drwxrwxr-x. 2 putong putong 6 Feb 8 20:02 dir2 -rw-rw-r--. 1 putong putong 0 Feb 8 20:02 f2 [putong@centos7 data]$ [putong@centos7 data]$ type umask umask is a shell builtin [putong@centos7 data]$ umask 0002 [putong@centos7 data]$ exit exit [root@centos7 data]# umask 0022 [root@centos7 data]# umask+default_value=777目录|666文件 000+default=777，假设文件也用777总和，会导致文件可能就带上了x执行权限，带来一定的风险。 022+default=777|666，文件夹default=755，文件default=644 👆上面的公式不正确 umask，mask时掩码，user的mask就是用户的掩码的意思。 umask ugo 也分user group other umask的功能，将777或者666中对应的权限去掉，得出默认权限。 777 022 ↓转成二进制,0锁死，1放开，就是通配符或者反掩码的算法. 111 111 111 000 010 010 ------------ 111 101 101 = 755 这就是文件夹创建默认权限 666 022 110 110 110 000 010 010 ------------ 110 100 100 = 644 这就是文件创建默认权限 ----👇修改umask值再来看，发现777|666-umask就不准确了---- [root@centos7 data]# umask 123 [root@centos7 data]# touch f1 [root@centos7 data]# mkdir dir [root@centos7 data]# ll total 0 drw-r-xr--. 2 root root 6 Feb 8 20:18 dir -rw-r--r--. 1 root root 0 Feb 8 20:18 f1 [root@centos7 data]# ------- 分析： 777 123 111 111 111 001 010 011 -------------- 110 101 100 => 掩出来的文件夹默认值为：654，这个确实就是777-123=654 如果是文件 666 123 110 110 110 001 010 011 -------------- 110 100 100 => 得到：644，这个就不是666-123=543，使用奇数+1的规律=644，所以速算法就是 543里面带上了执行权限了，肯定不可能的。 👇 如果是文件夹777-umask=default 如果是文件666-umask=default(3个数，如果是奇数就+1，偶数不变) umask退出后丢失，可以写到.bashrc或者/etc/bashrc里，这里也有个点就是几个文件里配置环境变量等，谁优先的原则，涉及文件有/etc/profile bashrc等，这个后面讲。 [root@centos7 ~]# cat /etc/bashrc | tail -3 fi # vim:ts=4:sw=4 umask 123 [root@centos7 ~]# [root@centos7 ~]# umask 0022 [root@centos7 ~]# umask -p umask 0022 [root@centos7 ~]# umask -p >> .bashrc # 将当前umaks值写入配置文件里 [root@centos7 ~]# tail -1 .bashrc umask 0022 [root@centos7 ~]# FACL 解决一些特殊需求，普通权限解决不了，比如 user1不能访问f1，user2能对f1完全控制，user3只能读f1，user4只能写f1 此时ugo三个角色，user、group、other，用户权限超过3个，就需要ACL了。 setfacl -m u:user1:0 f1 setfacl -m u:user1:- f1 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-02-01 15:42:20 "},"6-用户、用户组和权限/5-FACL实现权限的灵活控制.html":{"url":"6-用户、用户组和权限/5-FACL实现权限的灵活控制.html","title":"第5节 FACL实现权限的灵活控制","keywords":"","body":"第5节. FACL实现权限的灵活控制 解决一些特殊需求，普通权限解决不了，比如 user1不能访问f1，user2能对f1完全控制，user3只能写f1，user4只能读f1 此时ugo三个角色，user、group、other，用户权限超过3个，就需要ACL了。 setfacl -m u:user1:0 f1 👈表示啥权限都没有 setfacl -m u:user1:- f1 👈表示啥权限都没有，等价于0 👉user1不能访问f1 [10:03:19 root@localhost data]#ll f1 -rw-r--r--+ 1 root root 4 Jan 29 10:03 f1 [10:04:59 root@localhost data]#su user2 -c \"cat f1\"👈切换用户输入cli后直接退出来 123 [10:05:00 root@localhost data]#su user1 -c \"cat f1\" cat: f1: Permission denied 👉user2完全控制f1 [10:20:21 root@localhost data]#su user2 -c 'cat f1' 123 [10:20:39 root@localhost data]#su user2 -c 'echo 123 > f1' bash: f1: Permission denied [10:20:43 root@localhost data]#setfacl -m u:user2:rw f1 [10:20:59 root@localhost data]#su user2 -c 'echo 321 > f1' [10:21:05 root@localhost data]#su user2 -c 'cat f1' 321 [10:21:11 root@localhost data]# 👉user3只能写f1 [10:24:33 root@localhost data]#setfacl -m u:user3:w f1 [10:25:44 root@localhost data]#su user3 -c 'cat f1' cat: f1: Permission denied [10:25:52 root@localhost data]#su user3 -c 'echo aaa >> f1' [10:26:01 root@localhost data]#su user3 -c 'cat f1' cat: f1: Permission denied [10:26:03 root@localhost data]#cat f1 321 aaa [10:26:15 root@localhost data]# 👉user4只能读f1,就归到other整体权限去，无需修改 👉查看facl [10:26:15 root@localhost data]#getfacl f1 # file: f1 # owner: root # group: root user::rw- user:user1:--- user:user2:rw- user:user3:-w- group::r-- mask::rw- other::r-- 针对group设置facl [10:28:34 root@localhost data]#setfacl -m g:g1:rw f1 [10:36:27 root@localhost data]#getfacl f1 # file: f1 # owner: root # group: root user::rw- user:user1:--- user:user2:rw- user:user3:-w- group::r-- group:g1:rw- 👈g1有了rw mask::rw- other::r-- [10:38:33 root@localhost data]#su user5 -c \"echo 123 > f1\" bash: f1: Permission denied [10:38:37 root@localhost data]#usermod -G g1 user5 👈user5加入g1扩展组 [10:39:09 root@localhost data]#id user5 uid=1012(user5) gid=1016(user5) groups=1016(user5),1001(g1) [10:39:11 root@localhost data]# [10:39:15 root@localhost data]#su user5 -c \"echo aaa > f1\" [10:39:28 root@localhost data]#cat f1 aaa 针对user1 同时设置facl的user和group权限，user优先。 [11:03:16 root@localhost data]#setfacl -m u:user1:- f1 [11:03:37 root@localhost data]#su user1 -c 'cat f1' cat: f1: Permission denied [11:03:46 root@localhost data]#su user1 -c 'echo 123 > f1' bash: f1: Permission denied [11:03:49 root@localhost data]#getfacl f1 # file: f1 # owner: root # group: root user::rw- user:user1:--- user:user2:rw- user:user3:-w- group::r-- group:g1:rw- mask::rw- other::r-- [11:03:55 root@localhost data]#id user1 uid=1008(user1) gid=1013(g12) groups=1013(g12),1015(grp001) [11:03:59 root@localhost data]#usermod -G g1 user1 [11:04:08 root@localhost data]#id user1 uid=1008(user1) gid=1013(g12) groups=1013(g12),1001(g1) [11:04:46 root@localhost data]#su user1 -c 'echo 123 > f1' bash: f1: Permission denied [11:05:06 root@localhost data]#su user1 -c 'cat f1' cat: f1: Permission denied 所有文件的权限判定规则：从上往下优先，先中先得 1、先看所有者 2、再看FACL： ​ 2.1看针对user的FACL ​ 2.2看针对group的FACL 3、看所属组 4、看other 👇判断所有者优于facl的user [11:12:11 root@localhost data]#getfacl f1 # file: f1 # owner: root # group: root user::rw- user:user1:--- user:user2:rw- user:user3:-w- group::r-- group:g1:rw- mask::rw- other::r-- [11:12:18 root@localhost data]#ll f1 -rw-rw-r--+ 1 root root 7 Jan 29 10:53 f1 [11:12:21 root@localhost data]#chown user1 f1 [11:12:35 root@localhost data]#ll f1 -rw-rw-r--+ 1 user1 root 7 Jan 29 10:53 f1 [11:12:36 root@localhost data]#su user1 -c 'cat f1' aaa bb [11:15:58 root@localhost data]#getfacl f1 # file: f1 # owner: root # group: root user::rw- user:user2:rw- user:user3:-w- group::r-- group:g1:rw- mask::rw- other::r-- 👇判断facl的group 优先于本来的group [11:16:01 root@localhost data]#su user1 -c 'catf1' bash: catf1: command not found [11:16:10 root@localhost data]#su user1 -c 'echo aa > f1' [11:16:16 root@localhost data]#su user1 -c 'cat f1' aa [11:16:21 root@localhost data]#setfacl -x g:g1 f1 [11:16:48 root@localhost data]#su user1 -c 'cat f1' aa [11:16:54 root@localhost data]#su user1 -c 'echo 11 >> f1' bash: f1: Permission denied [11:16:59 root@localhost data]#getfacl f1 # file: f1 # owner: root # group: root user::rw- user:user2:rw- user:user3:-w- group::r-- mask::rw- other::r-- [11:17:04 root@localhost data]# 删除facl两种方法 -x删一个 -b全删 -R -b dir 递归删除文件夹下所有的acl，据说相当有用 [11:19:58 root@localhost data]#getfacl f1 # file: f1 # owner: root # group: root user::rw- user:user1:--- user:user2:rw- user:user3:-w- group::r-- group:g1:rw- mask::rw- other::r-- [11:28:31 root@localhost data]#setfacl -x u:user1 f1 [11:28:41 root@localhost data]#setfacl -x g:g1 f1 [11:28:46 root@localhost data]#getfacl f1 # file: f1 # owner: root # group: root user::rw- user:user2:rw- user:user3:-w- group::r-- mask::rw- other::r-- [11:28:48 root@localhost data]#setfacl -b f1 [11:28:54 root@localhost data]#getfacl f1 # file: f1 # owner: root # group: root user::rw- group::r-- other::r-- [11:28:57 root@localhost data]# 经典案例 我们复制文件夹的时候总担心权限、所有者、所属组这些信息的丢失，cp -a 可以提供思路 我们修改文件夹的权限比如chmod -R 777 dir/ , 带来的问题是，以后想要回收权限，没有办法了，这个时候facl就提供了很好的思路。 [11:40:55 root@localhost ~]#setfacl -R -m u:user1:r data/ [11:41:02 root@localhost ~]#ll total 12 -rw-r--r--. 1 root root 3 Jan 12 16:53 1 -rw-------. 1 root root 1031 Jan 5 16:52 anaconda-ks.cfg drwxrwxrwx+ 4 root root 61 Jan 29 10:59 data -rw-r--r--. 1 root root 0 Jan 12 16:53 f1 -rw-r--r--. 1 root root 0 Jan 12 16:53 f2 -rw-r--r--. 1 root root 4 Jan 12 17:51 hello.txt [11:41:03 root@localhost ~]#cd data/ [11:41:04 root@localhost data]#ll total 8 drwxr-xr-x+ 2 root root 6 Jan 19 19:57 dir drwxr-xr-x+ 2 user1 g12 6 Jan 19 19:58 dir2 -rw-r--r--+ 1 root root 3 Jan 29 11:16 f1 -rw-r--r--+ 1 user1 g12 0 Jan 19 19:58 f2 -rw-r--r--+ 1 root root 65 Jan 29 10:59 test [11:41:05 root@localhost data]#getfacl f2 # file: f2 # owner: user1 # group: g12 user::rw- user:user1:r-- group::r-- mask::r-- other::r-- [11:41:31 root@localhost ~]#getfacl data # file: data # owner: root # group: root user::rwx user:user1:r-- group::rwx mask::rwx other::rwx [11:41:56 root@localhost ~]#setfacl -R -b data/ [11:42:08 root@localhost ~]# [11:42:09 root@localhost ~]#ll total 12 -rw-r--r--. 1 root root 3 Jan 12 16:53 1 -rw-------. 1 root root 1031 Jan 5 16:52 anaconda-ks.cfg drwxrwxrwx. 4 root root 61 Jan 29 10:59 data -rw-r--r--. 1 root root 0 Jan 12 16:53 f1 -rw-r--r--. 1 root root 0 Jan 12 16:53 f2 -rw-r--r--. 1 root root 4 Jan 12 17:51 hello.txt [11:42:11 root@localhost ~]#ll data/ total 8 drwxr-xr-x. 2 root root 6 Jan 19 19:57 dir drwxr-xr-x. 2 user1 g12 6 Jan 19 19:58 dir2 -rw-r--r--. 1 root root 3 Jan 29 11:16 f1 -rw-r--r--. 1 user1 g12 0 Jan 19 19:58 f2 -rw-r--r--. 1 root root 65 Jan 29 10:59 test [11:42:19 root@localhost ~]# 其他用法参考setfacl -h 比如 setfacl -m d:u:ming:rx dir👈意思是dir文件夹下创建的文件默认就带针对ming的rx权限，d设置的默认权限，删除用setfac -k dir来删 setfacl -X file.acl dir👈意思是file.acl里写好g:sales:rw这些facl的明细，这个比较好的。 setfacl -m u:user1:rwX dir👈X是只是针对文件夹设置，不过我用x一i杨的效果。要么是rocky-linux自带的，要吗是版本高的好处，不管。 getfacl file1 | setfacl --set-file=- file2👈参考chmod里的--reference一个效果，就是将f2的权限设置成f1一样的。 FACL里的mask mask就是设置一个最高权限，谁都不能超过 ll可见group的rwx3位现在用来填充mask的值了。 mask默认设置了facl后位rwx，手动修改后getfacl 可见#effective:rw-这种 mask只影响单个人，所有者和other不受影响 [11:59:54 root@localhost data]#getfacl f1 # file: f1 # owner: root # group: root user::rw- group::r-- other::r-- [11:59:57 root@localhost data]#ll total 8 drwxr-xr-x. 2 root root 6 Jan 19 19:57 dir drwxr-xr-x. 2 user1 g12 6 Jan 19 19:58 dir2 -rw-r--r--. 1 root root 3 Jan 29 11:16 f1 -rw-r--r--. 1 user1 g12 0 Jan 19 19:58 f2 -rw-r--r--. 1 root root 65 Jan 29 10:59 test [12:00:03 root@localhost data]#setfacl -m u:user1:rw f1 [12:00:25 root@localhost data]#ll f1 -rw-rw-r--+ 1 root root 3 Jan 29 11:16 f1 [12:00:27 root@localhost data]#setfacl -m u:user2:rwx f1 [12:00:42 root@localhost data]#ll total 8 drwxr-xr-x. 2 root root 6 Jan 19 19:57 dir drwxr-xr-x. 2 user1 g12 6 Jan 19 19:58 dir2 -rw-rwxr--+ 1 root root 3 Jan 29 11:16 f1 -rw-r--r--. 1 user1 g12 0 Jan 19 19:58 f2 -rw-r--r--. 1 root root 65 Jan 29 10:59 test [12:00:44 root@localhost data]#getfacl f1 # file: f1 # owner: root # group: root user::rw- user:user1:rw- user:user2:rwx group::r-- mask::rwx 👈mask默认值 other::r-- [12:00:57 root@localhost data]#setfacl -m mask::r f1 [12:01:14 root@localhost data]#ll total 8 drwxr-xr-x. 2 root root 6 Jan 19 19:57 dir drwxr-xr-x. 2 user1 g12 6 Jan 19 19:58 dir2 -rw-r--r--+ 1 root root 3 Jan 29 11:16 f1 👈修改mask后group位的3位用来表示mask的3位 -rw-r--r--. 1 user1 g12 0 Jan 19 19:58 f2 -rw-r--r--. 1 root root 65 Jan 29 10:59 test [12:01:15 root@localhost data]#getfacl f1 # file: f1 # owner: root # group: root user::rw- user:user1:rw- #effective:r-- 👈注意mask影响了单个用户的权限上限 user:user2:rwx #effective:r-- group::r-- mask::r-- other::r-- [12:01:20 root@localhost data]# facl的备份 怎么备份和还原 getfacl -R /tmp/dir1 > acl.txt 👈备份到acl.txt setfacl -R -b /tmp/dir1 👈清空下 setfacl -R --set-file=acl.txt /tmp/dir1 👈恢复方法1 setfacl --restore acl.txt 👈恢复方法2 getfacl -R /tmp/dir1 👈递归，也就是包含dir1及其下所有文件的facl cp -p 或-a就能备份facl，还有所有者权限等 mv 也支持facl这些的保留 tar不行，tar备份的时候facl就丢了 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-02-01 15:42:20 "},"7-文本三剑客1_grep和正则表达式/7-文本三剑客1_grep和正则表达式.html":{"url":"7-文本三剑客1_grep和正则表达式/7-文本三剑客1_grep和正则表达式.html","title":"第七章 文本三剑客1_grep和正则表达式","keywords":"","body":"第七章 文本三剑客1_grep和正则表达式 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:40 "},"7-文本三剑客1_grep和正则表达式/1-常见文本处理工具.html":{"url":"7-文本三剑客1_grep和正则表达式/1-常见文本处理工具.html","title":"第1节 常见文本处理工具","keywords":"","body":"第1节. 常见文本处理工具 cat查看行结束符/行尾 cat -A查看回车、换行、TAB建 👆cat 空行不算行号 cat 压缩连续空行 倒着看tac和rev nl等价于cat -b 文本截取前后 head默认前10行 tail默认后10行 head一行内取前3个字节，密码生成方法2 前面有openssl还有一种，这里就是3中随机数的生成方法了。好像就一个靠谱，其他缺胳膊少腿的。 tail -f和-F跟踪是不同的，删除文件的效果 文件描述符时连接着inode的，删除文件后重新创建同名，其实inode变了。 文件名就是简单的只看名称了 当然文件描述符本身和inode也不是等价的 只要文件名恢复了，tail -F又继续跟踪了 只是理解一下各个用法，不一定这么用 这就是一个取某个网卡IP地址的固定语法咯，可以做成别名来用。 cut列截取 多个空格的压缩成1个边缘cut基于空格 进一步 [16:14:14 root@localhost ~]#df Filesystem 1K-blocks Used Available Use% Mounted on devtmpfs 897812 0 897812 0% /dev tmpfs 916616 0 916616 0% /dev/shm tmpfs 916616 8868 907748 1% /run tmpfs 916616 0 916616 0% /sys/fs/cgroup /dev/mapper/rl-root 17811456 2153364 15658092 13% / /dev/sda1 1038336 198012 840324 20% /boot tmpfs 183320 0 183320 0% /run/user/0 [16:14:16 root@localhost ~]# [16:14:17 root@localhost ~]#df |cut -c48-51 Use 0 0 1 0 13 20 0 [16:14:18 root@localhost ~]#df |cut -c48-51|tr -dc '[0-9\\n] ' 0 0 1 0 13 20 0 [16:14:50 root@localhost ~]#df |cut -c48-51|tr -dc '[0-9\\n]' 0 0 1 0 13 20 0 [16:14:55 root@localhost ~]# 👆这可以作为观察服务器的登入信息 👇看网站访问信息 linux的词汇量？ 起密码的时候，说明你这是一个单词不让你起，凭的就是这个words里的单词了吧 文件内容纵向合并 文件内容横向合并 两个文件的内容合并到一行 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-02-01 15:42:20 "},"7-文本三剑客1_grep和正则表达式/2-文本三剑客1_grep和正则.html":{"url":"7-文本三剑客1_grep和正则表达式/2-文本三剑客1_grep和正则.html","title":"第2节 文本三剑客1_grep和正则","keywords":"","body":"第2节. 文本三剑客1_grep和正则 wc统计 显示最长一行的长度（单位字符？5个字符） sort排序 排名部分先后，可以用R 对第3列当作数字进行排序 对IP地址排序， 这个还是要用lambda去排的，比如接口和IP这种g1/0/1,192.16.10.1分段去比较的，这里仅仅是整体比一下，看下效果就好。 sort -u 去掉重复行 uniq删除上下连续的重复行 last -f wtmp就是last一个意思 [17:33:36 root@localhost data]#ll /var/log/*tmp -rw-rw----. 1 root utmp 2688 Jan 17 12:00 /var/log/btmp 👈lastb看的是这个文件，是密码输错了的记录 -rw-rw-r--. 1 root utmp 36480 Jan 29 11:15 /var/log/wtmp 👈last看的就是这个文件，是登入成功的记录 [17:33:41 root@localhost data]# 👆以什么样的用户猜密码的，安全加固的方式 uniqd -d 只显示重复的 uniq 的话如果不前置一个sort排序的话，就只是抓取连续的情况。 找出两个文件的相同行 👆上面的题目有BUG啊，如果a.txt里有两行z，那么就会误判咯。 [17:50:07 root@localhost data]#cat f1 z z a b c [17:50:10 root@localhost data]#cat f2 b c [17:50:11 root@localhost data]#cat f1 f2 | sort |uniq -d b c z [17:50:23 root@localhost data]# 可以这样优化👇，先各自去重后再cat结合再找出重复的就行了。 [17:51:20 root@localhost data]#cat f1 z z a b c [17:51:29 root@localhost data]#cat f2 b c [17:51:49 root@localhost data]#uniq f1 |cat - f2 z a b c b c [17:52:22 root@localhost data]#uniq f1 |cat - f2 | sort | uniq -d 👈这才是正解-d就是重复的 b c [17:52:29 root@localhost data]#uniq f1 |cat - f2 | sort | uniq -u 👈u就是取uniqu不一样的 a z 比较文件 -号代表第一个文件，+代表第二个文件,-号去掉+号加上 👆注意patch -b 选项是为了恢复之前先备份a.txt，因为patch的还原文件时直接将a.txt原文件覆盖掉的。 grep三剑客之一 grep不一定都带颜色，因为root的grep系统默认是别名 grep选项 grep -m匹配N次后停止 grep -i忽略大小写 grep -n命中第几行 grep -c匹配的行数 grep -o 命中多少个单行内多次也算 统计文本出现字符的次数-o出现一次单行列出来，再wc -l计算行数 grep -q 静默输出0找到1没找到0是true保持一惯的linux的真假标准 grep -A或-B或-C还是经常用的，但是cisco的show run | section router ospf显然更优化 此外还有-B -C nmap扫描、关于IP探测要总结一下好几种呢ping呢也是有灰常快速的方法的很赞的，当然ping肯定不可靠的。 👉最好是探测该IP上的几个常用端口，然后才能说这个IP是不是UP。他这个sP就是scan ping，聊胜于无，要用-Pn去扫 这招可以用来梳理IDC或者内网的HOST网段使用情况，选项不靠谱，仅作参考咯。 --- grep -E \"XX|YY|ZZ\"或的关系等价于grep -e xx -e yy -e zz 一样 grep 并且过滤 grep -w单词等价于grep的定界符grep \"\\\" grep -w 或grep \"\\\"的这个单词整体 判断的能力： 👆数字 字母 下划线 是一个单词，- 默认会当作分隔符的 ；同样也算作分隔符了 -w就是查找root单词，而root-er是当做root和er两个单词的。-不会被当做一个整体的。 不支持regex，这是什么需求？👇就是比如. *这玩意不做正则的时候，省的转义了 -F 或者fgrep就挺好，挺好~lizheng~tt tx sf sx grep -f 文件内容去匹配，这个玩意支持regex吗？支持擦头 说明：以前学习的通配符是匹配文件名的，而grep里的正则是匹配文本内容的。 而且通配符的和regex的\\，以及通配符的.和regex的.都不太一样。regex的.*表示所有差点比如换行符？，而且regex的*不能独立存在，然是通配符的*就是自称一体表示所有。 1、regex的 .表示 除了 \\n以外任何一个字符，*表示前面的字符不出现或者出现N次。 2、通配符的.就表示. 而通配符的*表示除了.开头的文件名，其他都可以匹配(大概吧哈哈，有的文章说明什么路径中带/的，我就纳闷了通配符是抓文件名的，你文件名中能带/这玩意？呵呵所以这块理解的差不多得了，够了)，包括文件名中带.的(只要不是.开头的就好) 3、还有regex和通配符的其他区别，比如[a-z]在通配符中表示小写的a-z和大写的A-Y不到Z；regex显然没这么奇葩。 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-02-01 15:42:20 "},"7-文本三剑客1_grep和正则表达式/3-基本和扩展正则.html":{"url":"7-文本三剑客1_grep和正则表达式/3-基本和扩展正则.html","title":"第3节 基本和扩展正则","keywords":"","body":"第3节 基本和扩展正则 举个例子 [^ming] 不是m、i、n、g的字符 [0-9] [[:lower:]] 任意一个小写字母 . 任意一个非\\n的字符 * 前一个字符出现0次或N次 a\\? a出现了0次或1次，可有可无的表达方式 a\\+ a出现1次及以上 a\\{10\\} a出现了10次 a\\{10,20\\} 10到20次 a\\{,20\\} 20次以下 a\\{10,\\} 10次以上 .* 所有但是不能匹配\\n，所以你用.*抓全文只能抓到换行符就结束了， .*等价于通配符里的* 位置锚定 [16:47:46 root@host1 ~]#grep -v \"^#\" /etc/fstab /dev/mapper/centos_host1-root / xfs defaults 0 0 UUID=e36eac36-1940-4883-8c19-a05f6b4bb4a6 /boot xfs defaults 0 0 /dev/mapper/centos_host1-swap swap swap defaults 0 0 [16:47:55 root@host1 ~]# [16:47:56 root@host1 ~]# [16:47:56 root@host1 ~]#grep ^[^#] /etc/fstab /dev/mapper/centos_host1-root / xfs defaults 0 0 UUID=e36eac36-1940-4883-8c19-a05f6b4bb4a6 /boot xfs defaults 0 0 /dev/mapper/centos_host1-swap swap swap defaults 0 0 [16:48:07 root@host1 ~]# 上图注意下，grep -v \"^#\" 和 grep \"^[^#]\"的区别，明显第二种也过滤空行。因为[^#]里面至少的又一个字符的。 搜索shutdown行尾👆 搜索空行👆 单词：在系统中，数字字母下划线都算单词的范畴。此外都不算单词。 空行是^$,空白行^[[:space:]]*$ 注意，写的思路： :%s///g :%s/(abc)(123)/1eradmin2/g :%s/(abc)(123)/\\1eradmin\\2/g 👆这个叫后向引用，在后面的sed搜索替代有关 nginx里也有后向引用的 [17:30:32 root@host1 ~]#echo rootrootxxroot |grep -E \"(root){2}\" rootrootxxroot 👆抓两连续的root 练习 4题 cat /etc/passwd |grep -E \"[0-9]{2,3}\" -o | grep -Ev ^0 👈这是错误的，因为4位数也会搜出来的比如65534这个数字也会当作655和34两个匹配结果的，需要词尾锚定 cat /etc/passwd |grep -E \"/\" -o | grep -Ev ^0 注意该方法由于是:xx:所以对于后面的数字是不匹配的。 方法一肯定只能是抓出第一个段数字， 方法二可以匹配所有数字 --- 扩展正则 grep -E还是有一些还是需要加\\的。 nginx的后向引用举例 这是nginx里的rewrite替换的正则写法 windows里也有正则 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-02-02 12:45:57 "},"8-shell脚本编程基础/8-shell脚本编程基础.html":{"url":"8-shell脚本编程基础/8-shell脚本编程基础.html","title":"第八章 shell脚本编程基础","keywords":"","body":"第八章 shell脚本编程基础 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:40 "},"8-shell脚本编程基础/1-shell编程脚本基础.html":{"url":"8-shell脚本编程基础/1-shell编程脚本基础.html","title":"第1节 shell编程脚本基础","keywords":"","body":"第1节. shell编程脚本基础 编程基础 shell和py都是边解释边执行 gcc是个编译软件，可以把高级语言转换成机器代码 gcc就是编译器 在执行的时候有python解释器，会读到内存里翻译成机器码了。但是这个机器码是在内存里的，不是个放在硬盘里的文件。它是边执行边翻译。 编程基本概念 shell脚本基础 创建shell脚本 脚本规范 脚本的基本结构 vim的初始化 脚本执行的方法1:bash xxx 方法2，source xxx和. xxxx 方法3：添加执行权限 👆直接运行脚本，就是外部命令了，是要到PATH变量里找路径的，而当前目录是/root并不在PATH变量里，所以找不到。 添加到PATH变量 👆其实也可以用ln -s 软连接来实现path变量的 但是如果你以后很多脚本都统一放到/data/scipts下的话，还是加/data/scripts为PATH变量好一点 脚本运行方法4：传递给bash命令 evn.sh，只要是sh后缀就行了。 例子，写个脚本创建用户 让其口令立即过期 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-02-02 14:29:26 "},"8-shell脚本编程基础/2-shell编程特殊位置变量.html":{"url":"8-shell脚本编程基础/2-shell编程特殊位置变量.html","title":"第2节 shell编程特殊位置变量","keywords":"","body":"第2节. shell编程特殊位置变量 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:40 "},"8-shell脚本编程基础/3-算术逻辑运算和条件测试.html":{"url":"8-shell脚本编程基础/3-算术逻辑运算和条件测试.html","title":"第3节 算术逻辑运算和条件测试","keywords":"","body":"第3节. 算术逻辑运算和条件测试 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:40 "},"8-shell脚本编程基础/4-条件判断.html":{"url":"8-shell脚本编程基础/4-条件判断.html","title":"第4节 条件判断","keywords":"","body":"第4节. 条件判断 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:40 "},"8-shell脚本编程基础/5-算术运算和read.html":{"url":"8-shell脚本编程基础/5-算术运算和read.html","title":"第5节 算术运算和read","keywords":"","body":"第5节. 算术运算和read Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:40 "},"8-shell脚本编程基础/6-脚本条件分支和安全.html":{"url":"8-shell脚本编程基础/6-脚本条件分支和安全.html","title":"第6节 脚本条件分支和安全","keywords":"","body":"第6节. 脚本条件分支和安全 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:40 "},"9-文本查找和压缩/9-文本查找和压缩.html":{"url":"9-文本查找和压缩/9-文本查找和压缩.html","title":"第九章 文本查找和压缩","keywords":"","body":"第九章 文本查找和压缩 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:40 "},"9-文本查找和压缩/1-文件查找.html":{"url":"9-文本查找和压缩/1-文件查找.html","title":"第1节 文件查找","keywords":"","body":"第1节. 文件查找 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:40 "},"9-文本查找和压缩/2-文件压缩和解压缩.html":{"url":"9-文本查找和压缩/2-文件压缩和解压缩.html","title":"第2节 文件压缩和解压缩","keywords":"","body":"第2节. 文件压缩和解压缩 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:40 "},"9-文本查找和压缩/3-文件打包和解包.html":{"url":"9-文本查找和压缩/3-文件打包和解包.html","title":"第3节 文件打包和解包","keywords":"","body":"第3节. 文件打包和解包 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:40 "},"10-文本三剑客2_sed/10-文本三剑客2_sed.html":{"url":"10-文本三剑客2_sed/10-文本三剑客2_sed.html","title":"第十章 文本三剑客2_sed","keywords":"","body":"第十章 文本三剑客2_sed Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"10-文本三剑客2_sed/1-文本处理三剑客2_sed.html":{"url":"10-文本三剑客2_sed/1-文本处理三剑客2_sed.html","title":"第1节 文本处理三剑客2_sed","keywords":"","body":"第1节. 文本处理三剑客2_sed Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"11-软件包管理/11-软件包管理.html":{"url":"11-软件包管理/11-软件包管理.html","title":"第十一章 软件包管理","keywords":"","body":"第十一章 软件包管理 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"11-软件包管理/1-软件管理基础.html":{"url":"11-软件包管理/1-软件管理基础.html","title":"第1节 软件管理基础","keywords":"","body":"第1节. 软件管理基础 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"11-软件包管理/2-rpm管理软件.html":{"url":"11-软件包管理/2-rpm管理软件.html","title":"第2节 rpm管理软件","keywords":"","body":"第2节. rpm管理软件 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"11-软件包管理/3-yum工作原理.html":{"url":"11-软件包管理/3-yum工作原理.html","title":"第3节 yum工作原理","keywords":"","body":"第3节. yum工作原理 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"11-软件包管理/4-实现yum源仓库和使用yum管理软件以及dnf.html":{"url":"11-软件包管理/4-实现yum源仓库和使用yum管理软件以及dnf.html","title":"第4节 实现yum源仓库和使用yum管理软件以及dnf","keywords":"","body":"第4节. 实现yum源仓库和使用yum管理软件以及dnf Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"11-软件包管理/5-编辑安装httpd2.html":{"url":"11-软件包管理/5-编辑安装httpd2.html","title":"第5节 编辑安装httpd2","keywords":"","body":"第5节. 编辑安装httpd2 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"12-磁盘存储和文件系统/12-磁盘存储和文件系统.html":{"url":"12-磁盘存储和文件系统/12-磁盘存储和文件系统.html","title":"第十二章 磁盘存储和文件系统","keywords":"","body":"第十二章 磁盘存储和文件系统 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"12-磁盘存储和文件系统/1-磁盘工作原理详解.html":{"url":"12-磁盘存储和文件系统/1-磁盘工作原理详解.html","title":"第1节 磁盘工作原理详解","keywords":"","body":"第1节. 磁盘工作原理详解 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"12-磁盘存储和文件系统/2-MBR和GPT分区管理.html":{"url":"12-磁盘存储和文件系统/2-MBR和GPT分区管理.html","title":"第2节 MBR和GPT分区管理","keywords":"","body":"第2节. MBR和GPT分区管理 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"12-磁盘存储和文件系统/3-MBR和GPT分区管理工具详解.html":{"url":"12-磁盘存储和文件系统/3-MBR和GPT分区管理工具详解.html","title":"第3节 MBR和GPT分区管理工具详解","keywords":"","body":"第3节. MBR和GPT分区管理工具详解 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"12-磁盘存储和文件系统/4-文件系统管理实战.html":{"url":"12-磁盘存储和文件系统/4-文件系统管理实战.html","title":"第4节 文件系统管理实战","keywords":"","body":"第4节. 文件系统管理实战 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"12-磁盘存储和文件系统/5-文件系统挂载.html":{"url":"12-磁盘存储和文件系统/5-文件系统挂载.html","title":"第5节 文件系统挂载","keywords":"","body":"第5节. 文件系统挂载 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"12-磁盘存储和文件系统/6-持久挂载实战故障排错和swap空间管理.html":{"url":"12-磁盘存储和文件系统/6-持久挂载实战故障排错和swap空间管理.html","title":"第6节 持久挂载实战故障排错和swap空间管理","keywords":"","body":"第6节. 持久挂载实战故障排错和swap空间管理 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"12-磁盘存储和文件系统/7-外围设备使用.html":{"url":"12-磁盘存储和文件系统/7-外围设备使用.html","title":"第7节 外围设备使用","keywords":"","body":"第7节. 外围设备使用 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"12-磁盘存储和文件系统/8-raid工作原理.html":{"url":"12-磁盘存储和文件系统/8-raid工作原理.html","title":"第8节 raid工作原理","keywords":"","body":"第8节. raid工作原理 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"12-磁盘存储和文件系统/9-LVM管理详解.html":{"url":"12-磁盘存储和文件系统/9-LVM管理详解.html","title":"第9节 LVM管理详解","keywords":"","body":"第9节. LVM管理详解 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"13-网络协议和管理/13-网络协议和管理.html":{"url":"13-网络协议和管理/13-网络协议和管理.html","title":"第十三章 网络协议和管理","keywords":"","body":"第十三章 网络协议和管理 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"13-网络协议和管理/1-网络基础.html":{"url":"13-网络协议和管理/1-网络基础.html","title":"第1节 网络基础","keywords":"","body":"第1节. 网络基础 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"13-网络协议和管理/2-网络架构.html":{"url":"13-网络协议和管理/2-网络架构.html","title":"第2节 网络架构","keywords":"","body":"第2节. 网络架构 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"13-网络协议和管理/3-TCP&IP.html":{"url":"13-网络协议和管理/3-TCP&IP.html","title":"第3节 TCP&IP","keywords":"","body":"第3节. TCP&IP Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"13-网络协议和管理/4-IP地址规划.html":{"url":"13-网络协议和管理/4-IP地址规划.html","title":"第4节 IP地址规划","keywords":"","body":"第4节. IP地址规划 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"13-网络协议和管理/5-linux的网络和路由配置管理.html":{"url":"13-网络协议和管理/5-linux的网络和路由配置管理.html","title":"第5节 linux的网络和路由配置管理","keywords":"","body":"第5节. linux的网络和路由配置管理 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"13-网络协议和管理/6-网络配置和故障拍错.html":{"url":"13-网络协议和管理/6-网络配置和故障拍错.html","title":"第6节 网络配置和故障拍错","keywords":"","body":"第6节. 网络配置和故障拍错 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"13-网络协议和管理/7-多网卡集成的企业级应用.html":{"url":"13-网络协议和管理/7-多网卡集成的企业级应用.html","title":"第7节 多网卡集成的企业级应用","keywords":"","body":"第7节. 多网卡集成的企业级应用 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"13-网络协议和管理/8-网桥实现和ubuntu网络配置.html":{"url":"13-网络协议和管理/8-网桥实现和ubuntu网络配置.html","title":"第8节 网桥实现和ubuntu网络配置","keywords":"","body":"第8节. 网桥实现和ubuntu网络配置 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"14-进程、系统性能和计划任务/14-进程、系统性能和计划任务.html":{"url":"14-进程、系统性能和计划任务/14-进程、系统性能和计划任务.html","title":"第十四章 进程、系统性能和计划任务","keywords":"","body":"第十四章 进程、系统性能和计划任务 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"14-进程、系统性能和计划任务/1-进程管理和内存分配.html":{"url":"14-进程、系统性能和计划任务/1-进程管理和内存分配.html","title":"第1节 进程管理和内存分配","keywords":"","body":"第1节. 进程管理和内存分配 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"14-进程、系统性能和计划任务/2-进程管理工具.html":{"url":"14-进程、系统性能和计划任务/2-进程管理工具.html","title":"第2节 进程管理工具","keywords":"","body":"第2节. 进程管理工具 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"14-进程、系统性能和计划任务/3-进程管理和性能相关工具.html":{"url":"14-进程、系统性能和计划任务/3-进程管理和性能相关工具.html","title":"第3节 进程管理和性能相关工具","keywords":"","body":"第3节. 进程管理和性能相关工具 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"14-进程、系统性能和计划任务/4-进程信号和前后台管理.html":{"url":"14-进程、系统性能和计划任务/4-进程信号和前后台管理.html","title":"第4节 进程信号和前后台管理","keywords":"","body":"第4节. 进程信号和前后台管理 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"14-进程、系统性能和计划任务/5-计划任务实现.html":{"url":"14-进程、系统性能和计划任务/5-计划任务实现.html","title":"第5节 计划任务实现","keywords":"","body":"第5节. 计划任务实现 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"15-shell脚本编程进阶/15-shell脚本编程进阶.html":{"url":"15-shell脚本编程进阶/15-shell脚本编程进阶.html","title":"第十五章 shell脚本编程进阶","keywords":"","body":"第十五章 shell脚本编程进阶 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"15-shell脚本编程进阶/1-循环01.html":{"url":"15-shell脚本编程进阶/1-循环01.html","title":"第1节 循环01","keywords":"","body":"第1节. 循环01 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"15-shell脚本编程进阶/2-循环02.html":{"url":"15-shell脚本编程进阶/2-循环02.html","title":"第2节 循环02","keywords":"","body":"第2节. 循环02 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"15-shell脚本编程进阶/3-函数详解01.html":{"url":"15-shell脚本编程进阶/3-函数详解01.html","title":"第3节 函数详解01","keywords":"","body":"第3节. 函数详解01 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"15-shell脚本编程进阶/4-函数详解02.html":{"url":"15-shell脚本编程进阶/4-函数详解02.html","title":"第4节 函数详解02","keywords":"","body":"第4节. 函数详解02 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"15-shell脚本编程进阶/5-信号处理和函数组详解.html":{"url":"15-shell脚本编程进阶/5-信号处理和函数组详解.html","title":"第5节 信号处理和函数组详解","keywords":"","body":"第5节. 信号处理和函数组详解 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"15-shell脚本编程进阶/6-高级变量和expect.html":{"url":"15-shell脚本编程进阶/6-高级变量和expect.html","title":"第6节 高级变量和expect","keywords":"","body":"第6节. 高级变量和expect Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"16-系统启动和内核管理/16-系统启动和内核管理.html":{"url":"16-系统启动和内核管理/16-系统启动和内核管理.html","title":"第十六章 系统启动和内核管理","keywords":"","body":"第十六章 系统启动和内核管理 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"16-系统启动和内核管理/1-系统启动流程和故障排错.html":{"url":"16-系统启动和内核管理/1-系统启动流程和故障排错.html","title":"第1节 系统启动流程和故障排错","keywords":"","body":"第1节. 系统启动流程和故障排错 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"16-系统启动和内核管理/2-启动流程和服务管理.html":{"url":"16-系统启动和内核管理/2-启动流程和服务管理.html","title":"第2节 启动流程和服务管理","keywords":"","body":"第2节. 启动流程和服务管理 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"16-系统启动和内核管理/3-启动流程详解.html":{"url":"16-系统启动和内核管理/3-启动流程详解.html","title":"第3节 启动流程详解","keywords":"","body":"第3节. 启动流程详解 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"16-系统启动和内核管理/4-linux启动流程grub管理和故障排错.html":{"url":"16-系统启动和内核管理/4-linux启动流程grub管理和故障排错.html","title":"第4节 linux启动流程grub管理和故障排错","keywords":"","body":"第4节. linux启动流程grub管理和故障排错 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"16-系统启动和内核管理/5-自制linux和源码编译内核.html":{"url":"16-系统启动和内核管理/5-自制linux和源码编译内核.html","title":"第5节 自制linux和源码编译内核","keywords":"","body":"第5节. 自制linux和源码编译内核 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"16-系统启动和内核管理/6-systemd特性.html":{"url":"16-系统启动和内核管理/6-systemd特性.html","title":"第6节 systemd特性","keywords":"","body":"第6节. systemd特性 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"16-系统启动和内核管理/7-systemd和grub2管理.html":{"url":"16-系统启动和内核管理/7-systemd和grub2管理.html","title":"第7节 systemd和grub2管理","keywords":"","body":"第7节. systemd和grub2管理 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"17-Security-Enhanced/17-Security-Enhanced.html":{"url":"17-Security-Enhanced/17-Security-Enhanced.html","title":"第十七章 Security-Enhanced","keywords":"","body":"第十七章 Security-Enhanced Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"17-Security-Enhanced/1-SELinux实现安全加固.html":{"url":"17-Security-Enhanced/1-SELinux实现安全加固.html","title":"第1节 SELinux实现安全加固","keywords":"","body":"第1节. SELinux实现安全加固 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"18-文本处理三剑客3_awk/18-文本处理三剑客3_awk.html":{"url":"18-文本处理三剑客3_awk/18-文本处理三剑客3_awk.html","title":"第十八章 文本处理三剑客3_awk","keywords":"","body":"第十八章 文本处理三剑客3_awk Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"18-文本处理三剑客3_awk/1-文本三剑客3_awk详解01.html":{"url":"18-文本处理三剑客3_awk/1-文本三剑客3_awk详解01.html","title":"第1节 文本三剑客3_awk详解01","keywords":"","body":"第1节. 文本三剑客3_awk详解01 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"19-加密和安全/19-加密和安全.html":{"url":"19-加密和安全/19-加密和安全.html","title":"第十九章 加密和安全","keywords":"","body":"第十九章 加密和安全 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"19-加密和安全/1-安全和各种攻击方法.html":{"url":"19-加密和安全/1-安全和各种攻击方法.html","title":"第1节 安全和各种攻击方法","keywords":"","body":"第1节. 安全和各种攻击方法 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"19-加密和安全/2-安全加密算法体系详解.html":{"url":"19-加密和安全/2-安全加密算法体系详解.html","title":"第2节 安全加密算法体系详解","keywords":"","body":"第2节. 安全加密算法体系详解 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"19-加密和安全/3-PKI和证书安全体系详解.html":{"url":"19-加密和安全/3-PKI和证书安全体系详解.html","title":"第3节 PKI和证书安全体系详解","keywords":"","body":"第3节. PKI和证书安全体系详解 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"19-加密和安全/4-互联网安全通讯协议HTTPS详解.html":{"url":"19-加密和安全/4-互联网安全通讯协议HTTPS详解.html","title":"第4节 互联网安全通讯协议HTTPS详解","keywords":"","body":"第4节. 互联网安全通讯协议HTTPS详解 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"19-加密和安全/5-建立私有CA和颁发证书.html":{"url":"19-加密和安全/5-建立私有CA和颁发证书.html","title":"第5节 建立私有CA和颁发证书","keywords":"","body":"第5节. 建立私有CA和颁发证书 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"19-加密和安全/6-证书管理和SSH服务工作原理详解.html":{"url":"19-加密和安全/6-证书管理和SSH服务工作原理详解.html","title":"第6节 证书管理和SSH服务工作原理详解","keywords":"","body":"第6节. 证书管理和SSH服务工作原理详解 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"19-加密和安全/7-SSH服务配置和基于KEY验证.html":{"url":"19-加密和安全/7-SSH服务配置和基于KEY验证.html","title":"第7节 SSH服务配置和基于KEY验证","keywords":"","body":"第7节. SSH服务配置和基于KEY验证 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"19-加密和安全/8-SSH基于key的expect自动化脚本.html":{"url":"19-加密和安全/8-SSH基于key的expect自动化脚本.html","title":"第8节 SSH基于key的expect自动化脚本","keywords":"","body":"第8节. SSH基于key的expect自动化脚本 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"19-加密和安全/9-SSH端口转发功能详解.html":{"url":"19-加密和安全/9-SSH端口转发功能详解.html","title":"第9节 SSH端口转发功能详解","keywords":"","body":"第9节. SSH端口转发功能详解 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"19-加密和安全/10-SSH安全实践配置.html":{"url":"19-加密和安全/10-SSH安全实践配置.html","title":"第10节 SSH安全实践配置","keywords":"","body":"第10节. SSH安全实践配置 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"19-加密和安全/11-dropbear编译安装和文件完整性检查.html":{"url":"19-加密和安全/11-dropbear编译安装和文件完整性检查.html","title":"第11节 dropbear编译安装和文件完整性检查","keywords":"","body":"第11节. dropbear编译安装和文件完整性检查 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"19-加密和安全/12-sudo实现管理授权详解.html":{"url":"19-加密和安全/12-sudo实现管理授权详解.html","title":"第12节 sudo实现管理授权详解","keywords":"","body":"第12节. sudo实现管理授权详解 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"19-加密和安全/13-TCPWRAPPER和PAM安全模块.html":{"url":"19-加密和安全/13-TCPWRAPPER和PAM安全模块.html","title":"第13节 TCPWRAPPER和PAM安全模块","keywords":"","body":"第13节. TCPWRAPPER和PAM安全模块 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"19-加密和安全/14-PAM模块使用.html":{"url":"19-加密和安全/14-PAM模块使用.html","title":"第14节 PAM模块使用","keywords":"","body":"第14节. PAM模块使用 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"20-加密和安全/20-加密和安全.html":{"url":"20-加密和安全/20-加密和安全.html","title":"第二十章 加密和安全","keywords":"","body":"第二十章 加密和安全 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"20-加密和安全/1-时间计时和同步.html":{"url":"20-加密和安全/1-时间计时和同步.html","title":"第1节 时间计时和同步","keywords":"","body":"第1节. 时间计时和同步 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"20-加密和安全/2-时间同步服务.html":{"url":"20-加密和安全/2-时间同步服务.html","title":"第2节 时间同步服务","keywords":"","body":"第2节. 时间同步服务 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"21-运维自动化系统部署/21-运维自动化系统部署.html":{"url":"21-运维自动化系统部署/21-运维自动化系统部署.html","title":"第二十一章 运维自动化系统部署","keywords":"","body":"第二十一章 运维自动化系统部署 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"21-运维自动化系统部署/1-系统自动化安装.html":{"url":"21-运维自动化系统部署/1-系统自动化安装.html","title":"第1节 系统自动化安装","keywords":"","body":"第1节. 系统自动化安装 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"21-运维自动化系统部署/2-DHCDP服务实现.html":{"url":"21-运维自动化系统部署/2-DHCDP服务实现.html","title":"第2节 DHCDP服务实现","keywords":"","body":"第2节. DHCDP服务实现 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"21-运维自动化系统部署/3-实现基于PXE安装centos7系统.html":{"url":"21-运维自动化系统部署/3-实现基于PXE安装centos7系统.html","title":"第3节 实现基于PXE安装centos7系统","keywords":"","body":"第3节. 实现基于PXE安装centos7系统 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"21-运维自动化系统部署/4-实现基于cobbler的自动安装.html":{"url":"21-运维自动化系统部署/4-实现基于cobbler的自动安装.html","title":"第4节 实现基于cobbler的自动安装","keywords":"","body":"第4节. 实现基于cobbler的自动安装 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"21-运维自动化系统部署/5-实现基于cobblerweb的管理.html":{"url":"21-运维自动化系统部署/5-实现基于cobblerweb的管理.html","title":"第5节 实现基于cobblerweb的管理","keywords":"","body":"第5节. 实现基于cobblerweb的管理 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"22-DNS服务和BIND/22-DNS服务和BIND.html":{"url":"22-DNS服务和BIND/22-DNS服务和BIND.html","title":"第二十二章 DNS服务和BIND","keywords":"","body":"第二十二章 DNS服务和BIND Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"22-DNS服务和BIND/1-DNS服务简介.html":{"url":"22-DNS服务和BIND/1-DNS服务简介.html","title":"第1节 DNS服务简介","keywords":"","body":"第1节. DNS服务简介 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"22-DNS服务和BIND/2-DNS只缓存服务器实现.html":{"url":"22-DNS服务和BIND/2-DNS只缓存服务器实现.html","title":"第2节 DNS只缓存服务器实现","keywords":"","body":"第2节. DNS只缓存服务器实现 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"22-DNS服务和BIND/3-DNS主服务器实现.html":{"url":"22-DNS服务和BIND/3-DNS主服务器实现.html","title":"第3节 DNS主服务器实现","keywords":"","body":"第3节. DNS主服务器实现 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"22-DNS服务和BIND/4-实现反向区域和主从复制服务.html":{"url":"22-DNS服务和BIND/4-实现反向区域和主从复制服务.html","title":"第4节 实现反向区域和主从复制服务","keywords":"","body":"第4节. 实现反向区域和主从复制服务 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"22-DNS服务和BIND/5-实现DNS子域委派和转发.html":{"url":"22-DNS服务和BIND/5-实现DNS子域委派和转发.html","title":"第5节 实现DNS子域委派和转发","keywords":"","body":"第5节. 实现DNS子域委派和转发 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"22-DNS服务和BIND/6-CDN和GSLB工作原理及智能DNS实现.html":{"url":"22-DNS服务和BIND/6-CDN和GSLB工作原理及智能DNS实现.html","title":"第6节 CDN和GSLB工作原理及智能DNS实现","keywords":"","body":"第6节. CDN和GSLB工作原理及智能DNS实现 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"22-DNS服务和BIND/7-实现internet架构和DNS服务.html":{"url":"22-DNS服务和BIND/7-实现internet架构和DNS服务.html","title":"第7节 实现internet架构和DNS服务","keywords":"","body":"第7节. 实现internet架构和DNS服务 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"23-MYSQL数据01/23-MYSQL数据01.html":{"url":"23-MYSQL数据01/23-MYSQL数据01.html","title":"第二十三章 MYSQL数据01","keywords":"","body":"第二十三章 MYSQL数据01 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"23-MYSQL数据01/1-数据库基础原理1.html":{"url":"23-MYSQL数据01/1-数据库基础原理1.html","title":"第1节 数据库基础原理1","keywords":"","body":"第1节. 数据库基础原理1 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"23-MYSQL数据01/2-数据库基础原理2.html":{"url":"23-MYSQL数据01/2-数据库基础原理2.html","title":"第2节 数据库基础原理2","keywords":"","body":"第2节. 数据库基础原理2 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"23-MYSQL数据01/3-mysql安装和基本使用.html":{"url":"23-MYSQL数据01/3-mysql安装和基本使用.html","title":"第3节 mysql安装和基本使用","keywords":"","body":"第3节. mysql安装和基本使用 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"23-MYSQL数据01/4-mysql基本使用.html":{"url":"23-MYSQL数据01/4-mysql基本使用.html","title":"第4节 mysql基本使用","keywords":"","body":"第4节. mysql基本使用 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"23-MYSQL数据01/5-mysql二进制和源码编译安装及多实例.html":{"url":"23-MYSQL数据01/5-mysql二进制和源码编译安装及多实例.html","title":"第5节 mysql二进制和源码编译安装及多实例","keywords":"","body":"第5节. mysql二进制和源码编译安装及多实例 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"23-MYSQL数据01/6-sql各种语句1.html":{"url":"23-MYSQL数据01/6-sql各种语句1.html","title":"第6节 sql各种语句1","keywords":"","body":"第6节. sql各种语句1 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"23-MYSQL数据01/7-sql各种语句2.html":{"url":"23-MYSQL数据01/7-sql各种语句2.html","title":"第7节 sql各种语句2","keywords":"","body":"第7节. sql各种语句2 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"24-MYSQL数据02/24-MYSQL数据02.html":{"url":"24-MYSQL数据02/24-MYSQL数据02.html","title":"第二十四章 MYSQL数据02","keywords":"","body":"第二十四章 MYSQL数据02 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"24-MYSQL数据02/1-sql语句DQL单表查询.html":{"url":"24-MYSQL数据02/1-sql语句DQL单表查询.html","title":"第1节 sql语句DQL单表查询","keywords":"","body":"第1节. sql语句DQL单表查询 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"24-MYSQL数据02/2-sql语句DQL多表查询和视图.html":{"url":"24-MYSQL数据02/2-sql语句DQL多表查询和视图.html","title":"第2节 sql语句DQL多表查询和视图","keywords":"","body":"第2节. sql语句DQL多表查询和视图 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"24-MYSQL数据02/3-函数存储过程和触发器和用户管理.html":{"url":"24-MYSQL数据02/3-函数存储过程和触发器和用户管理.html","title":"第3节 函数存储过程和触发器和用户管理","keywords":"","body":"第3节. 函数存储过程和触发器和用户管理 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"24-MYSQL数据02/4-mysql架构和存储引擎详解.html":{"url":"24-MYSQL数据02/4-mysql架构和存储引擎详解.html","title":"第4节 mysql架构和存储引擎详解","keywords":"","body":"第4节. mysql架构和存储引擎详解 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"24-MYSQL数据02/5-mysql服务器选项变量和性能优化.html":{"url":"24-MYSQL数据02/5-mysql服务器选项变量和性能优化.html","title":"第5节 mysql服务器选项变量和性能优化","keywords":"","body":"第5节. mysql服务器选项变量和性能优化 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"25-MYSQL数据03/25-MYSQL数据03.html":{"url":"25-MYSQL数据03/25-MYSQL数据03.html","title":"第二十五章 MYSQL数据03","keywords":"","body":"第二十五章 MYSQL数据03 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"25-MYSQL数据03/1-索引类型和结构原理.html":{"url":"25-MYSQL数据03/1-索引类型和结构原理.html","title":"第1节 索引类型和结构原理","keywords":"","body":"第1节. 索引类型和结构原理 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"25-MYSQL数据03/2-索引管理和并发访问的锁机制.html":{"url":"25-MYSQL数据03/2-索引管理和并发访问的锁机制.html","title":"第2节 索引管理和并发访问的锁机制","keywords":"","body":"第2节. 索引管理和并发访问的锁机制 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"25-MYSQL数据03/3-事务特性和四种隔离级别.html":{"url":"25-MYSQL数据03/3-事务特性和四种隔离级别.html","title":"第3节 事务特性和四种隔离级别","keywords":"","body":"第3节. 事务特性和四种隔离级别 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"25-MYSQL数据03/4-各种日志管理.html":{"url":"25-MYSQL数据03/4-各种日志管理.html","title":"第4节 各种日志管理","keywords":"","body":"第4节. 各种日志管理 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"25-MYSQL数据03/5-二进制日志管理.html":{"url":"25-MYSQL数据03/5-二进制日志管理.html","title":"第5节 二进制日志管理","keywords":"","body":"第5节. 二进制日志管理 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"26-MYSQL数据04/26-MYSQL数据04.html":{"url":"26-MYSQL数据04/26-MYSQL数据04.html","title":"第二十六章 MYSQL数据04","keywords":"","body":"第二十六章 MYSQL数据04 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"26-MYSQL数据04/1-数据库备份和还原原理详解.html":{"url":"26-MYSQL数据04/1-数据库备份和还原原理详解.html","title":"第1节 数据库备份和还原原理详解","keywords":"","body":"第1节. 数据库备份和还原原理详解 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"26-MYSQL数据04/2-mysql备份还原mysqldump使用.html":{"url":"26-MYSQL数据04/2-mysql备份还原mysqldump使用.html","title":"第2节 mysql备份还原mysqldump使用","keywords":"","body":"第2节. mysql备份还原mysqldump使用 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"26-MYSQL数据04/3-mysqldump实战和xtrabackup介绍.html":{"url":"26-MYSQL数据04/3-mysqldump实战和xtrabackup介绍.html","title":"第3节 mysqldump实战和xtrabackup介绍","keywords":"","body":"第3节. mysqldump实战和xtrabackup介绍 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"26-MYSQL数据04/4-mysql主从复制原理和实现.html":{"url":"26-MYSQL数据04/4-mysql主从复制原理和实现.html","title":"第4节 mysql主从复制原理和实现","keywords":"","body":"第4节. mysql主从复制原理和实现 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"27-MYSQL数据05/27-MYSQL数据05.html":{"url":"27-MYSQL数据05/27-MYSQL数据05.html","title":"第二十七章 MYSQL数据05","keywords":"","body":"第二十七章 MYSQL数据05 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"27-MYSQL数据05/1-主从服务故障恢复和级联复制.html":{"url":"27-MYSQL数据05/1-主从服务故障恢复和级联复制.html","title":"第1节 主从服务故障恢复和级联复制","keywords":"","body":"第1节. 主从服务故障恢复和级联复制 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"27-MYSQL数据05/2-mysql主主和半同步复制.html":{"url":"27-MYSQL数据05/2-mysql主主和半同步复制.html","title":"第2节 mysql主主和半同步复制","keywords":"","body":"第2节. mysql主主和半同步复制 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"27-MYSQL数据05/3-mysql复制过滤器和基于SSL的复制加密.html":{"url":"27-MYSQL数据05/3-mysql复制过滤器和基于SSL的复制加密.html","title":"第3节 mysql复制过滤器和基于SSL的复制加密","keywords":"","body":"第3节. mysql复制过滤器和基于SSL的复制加密 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"27-MYSQL数据05/4-基于mysql5.html":{"url":"27-MYSQL数据05/4-基于mysql5.html","title":"第4节 基于mysql5","keywords":"","body":"第4节. 基于mysql5 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"27-MYSQL数据05/5-基于proxy实现mysql的读写分离.html":{"url":"27-MYSQL数据05/5-基于proxy实现mysql的读写分离.html","title":"第5节 基于proxy实现mysql的读写分离","keywords":"","body":"第5节. 基于proxy实现mysql的读写分离 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"27-MYSQL数据05/6-mysql的主从复制高可用性解决方案MHA.html":{"url":"27-MYSQL数据05/6-mysql的主从复制高可用性解决方案MHA.html","title":"第6节 mysql的主从复制高可用性解决方案MHA","keywords":"","body":"第6节. mysql的主从复制高可用性解决方案MHA Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"27-MYSQL数据05/7-实现galaracluster和性能测试.html":{"url":"27-MYSQL数据05/7-实现galaracluster和性能测试.html","title":"第7节 实现galaracluster和性能测试","keywords":"","body":"第7节. 实现galaracluster和性能测试 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"28-运维自动化之ansible/28-运维自动化之ansible.html":{"url":"28-运维自动化之ansible/28-运维自动化之ansible.html","title":"第二十八章 运维自动化之ansible","keywords":"","body":"第二十八章 运维自动化之ansible Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"28-运维自动化之ansible/1-自动化运维介绍.html":{"url":"28-运维自动化之ansible/1-自动化运维介绍.html","title":"第1节 自动化运维介绍","keywords":"","body":"第1节. 自动化运维介绍 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"28-运维自动化之ansible/2-ansible安装和架构介绍.html":{"url":"28-运维自动化之ansible/2-ansible安装和架构介绍.html","title":"第2节 ansible安装和架构介绍","keywords":"","body":"第2节. ansible安装和架构介绍 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"28-运维自动化之ansible/3-ansible常见模块.html":{"url":"28-运维自动化之ansible/3-ansible常见模块.html","title":"第3节 ansible常见模块","keywords":"","body":"第3节. ansible常见模块 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"28-运维自动化之ansible/4-ansible相关常见工具.html":{"url":"28-运维自动化之ansible/4-ansible相关常见工具.html","title":"第4节 ansible相关常见工具","keywords":"","body":"第4节. ansible相关常见工具 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"28-运维自动化之ansible/5-playbook的实现软件配置和部署.html":{"url":"28-运维自动化之ansible/5-playbook的实现软件配置和部署.html","title":"第5节 playbook的实现软件配置和部署","keywords":"","body":"第5节. playbook的实现软件配置和部署 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"28-运维自动化之ansible/6-playbook的高级用法模板template.html":{"url":"28-运维自动化之ansible/6-playbook的高级用法模板template.html","title":"第6节 playbook的高级用法模板template","keywords":"","body":"第6节. playbook的高级用法模板template Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"28-运维自动化之ansible/7-ansible的高级用法role1.html":{"url":"28-运维自动化之ansible/7-ansible的高级用法role1.html","title":"第7节 ansible的高级用法role1","keywords":"","body":"第7节. ansible的高级用法role1 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"28-运维自动化之ansible/8-ansible的高级用法role2.html":{"url":"28-运维自动化之ansible/8-ansible的高级用法role2.html","title":"第8节 ansible的高级用法role2","keywords":"","body":"第8节. ansible的高级用法role2 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"29-HTTP协议和APACHE/29-HTTP协议和APACHE.html":{"url":"29-HTTP协议和APACHE/29-HTTP协议和APACHE.html","title":"第二十九章 HTTP协议和APACHE","keywords":"","body":"第二十九章 HTTP协议和APACHE Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"29-HTTP协议和APACHE/1-httpd基础知识.html":{"url":"29-HTTP协议和APACHE/1-httpd基础知识.html","title":"第1节 httpd基础知识","keywords":"","body":"第1节. httpd基础知识 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"29-HTTP协议和APACHE/2-http协议各种版本详解.html":{"url":"29-HTTP协议和APACHE/2-http协议各种版本详解.html","title":"第2节 http协议各种版本详解","keywords":"","body":"第2节. http协议各种版本详解 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"29-HTTP协议和APACHE/3-httpd软件工作模型.html":{"url":"29-HTTP协议和APACHE/3-httpd软件工作模型.html","title":"第3节 httpd软件工作模型","keywords":"","body":"第3节. httpd软件工作模型 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"29-HTTP协议和APACHE/4-httpd2.html":{"url":"29-HTTP协议和APACHE/4-httpd2.html","title":"第4节 httpd2","keywords":"","body":"第4节. httpd2 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"29-HTTP协议和APACHE/5-httpd2.html":{"url":"29-HTTP协议和APACHE/5-httpd2.html","title":"第5节 httpd2","keywords":"","body":"第5节. httpd2 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"29-HTTP协议和APACHE/6-多虚拟主机实现.html":{"url":"29-HTTP协议和APACHE/6-多虚拟主机实现.html","title":"第6节 多虚拟主机实现","keywords":"","body":"第6节. 多虚拟主机实现 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"29-HTTP协议和APACHE/7-基于主机头的多虚拟主机和实现HTTPS加密.html":{"url":"29-HTTP协议和APACHE/7-基于主机头的多虚拟主机和实现HTTPS加密.html","title":"第7节 基于主机头的多虚拟主机和实现HTTPS加密","keywords":"","body":"第7节. 基于主机头的多虚拟主机和实现HTTPS加密 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"29-HTTP协议和APACHE/8-http的安全加固和重定向.html":{"url":"29-HTTP协议和APACHE/8-http的安全加固和重定向.html","title":"第8节 http的安全加固和重定向","keywords":"","body":"第8节. http的安全加固和重定向 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"29-HTTP协议和APACHE/9-http协议详解和相关工具.html":{"url":"29-HTTP协议和APACHE/9-http协议详解和相关工具.html","title":"第9节 http协议详解和相关工具","keywords":"","body":"第9节. http协议详解和相关工具 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"29-HTTP协议和APACHE/10-httpd源码编译安装.html":{"url":"29-HTTP协议和APACHE/10-httpd源码编译安装.html","title":"第10节 httpd源码编译安装","keywords":"","body":"第10节. httpd源码编译安装 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:37 "},"30-实现LAMP架构/30-实现LAMP架构.html":{"url":"30-实现LAMP架构/30-实现LAMP架构.html","title":"第三十章 实现LAMP架构","keywords":"","body":"第三十章 实现LAMP架构 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:38 "},"30-实现LAMP架构/1-实现LAMP应用phpmyadmin.html":{"url":"30-实现LAMP架构/1-实现LAMP应用phpmyadmin.html","title":"第1节 实现LAMP应用phpmyadmin","keywords":"","body":"第1节. 实现LAMP应用phpmyadmin Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:38 "},"30-实现LAMP架构/2-LAMP应用部署.html":{"url":"30-实现LAMP架构/2-LAMP应用部署.html","title":"第2节 LAMP应用部署","keywords":"","body":"第2节. LAMP应用部署 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:38 "},"30-实现LAMP架构/3-实现FCGI的LAMP架构.html":{"url":"30-实现LAMP架构/3-实现FCGI的LAMP架构.html","title":"第3节 实现FCGI的LAMP架构","keywords":"","body":"第3节. 实现FCGI的LAMP架构 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:38 "},"30-实现LAMP架构/4-编译安装LAMP环境部署应用01.html":{"url":"30-实现LAMP架构/4-编译安装LAMP环境部署应用01.html","title":"第4节 编译安装LAMP环境部署应用01","keywords":"","body":"第4节. 编译安装LAMP环境部署应用01 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:38 "},"30-实现LAMP架构/5-编译安装LAMP环境部署应用02.html":{"url":"30-实现LAMP架构/5-编译安装LAMP环境部署应用02.html","title":"第5节 编译安装LAMP环境部署应用02","keywords":"","body":"第5节. 编译安装LAMP环境部署应用02 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:38 "},"31-日志管理rsyslog/31-日志管理rsyslog.html":{"url":"31-日志管理rsyslog/31-日志管理rsyslog.html","title":"第三十一章 日志管理rsyslog","keywords":"","body":"第三十一章 日志管理rsyslog Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:38 "},"31-日志管理rsyslog/1-日志管理实现远程日志.html":{"url":"31-日志管理rsyslog/1-日志管理实现远程日志.html","title":"第1节 日志管理实现远程日志","keywords":"","body":"第1节. 日志管理实现远程日志 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:38 "},"31-日志管理rsyslog/2-通过loganalyzer展示数据库中的日志.html":{"url":"31-日志管理rsyslog/2-通过loganalyzer展示数据库中的日志.html","title":"第2节 通过loganalyzer展示数据库中的日志","keywords":"","body":"第2节. 通过loganalyzer展示数据库中的日志 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:38 "},"32-网络文件共享服务/32-网络文件共享服务.html":{"url":"32-网络文件共享服务/32-网络文件共享服务.html","title":"第三十二章 网络文件共享服务","keywords":"","body":"第三十二章 网络文件共享服务 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:38 "},"32-网络文件共享服务/1-文件共享服务FTP01.html":{"url":"32-网络文件共享服务/1-文件共享服务FTP01.html","title":"第1节 文件共享服务FTP01","keywords":"","body":"第1节. 文件共享服务FTP01 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:38 "},"32-网络文件共享服务/2-文件共享服务FTP02.html":{"url":"32-网络文件共享服务/2-文件共享服务FTP02.html","title":"第2节 文件共享服务FTP02","keywords":"","body":"第2节. 文件共享服务FTP02 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:38 "},"32-网络文件共享服务/3-FTP常见配置和基于DB文件的虚拟用户.html":{"url":"32-网络文件共享服务/3-FTP常见配置和基于DB文件的虚拟用户.html","title":"第3节 FTP常见配置和基于DB文件的虚拟用户","keywords":"","body":"第3节. FTP常见配置和基于DB文件的虚拟用户 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:38 "},"32-网络文件共享服务/4-基于mysql的FTP的虚拟用户和NFS服务介绍.html":{"url":"32-网络文件共享服务/4-基于mysql的FTP的虚拟用户和NFS服务介绍.html","title":"第4节 基于mysql的FTP的虚拟用户和NFS服务介绍","keywords":"","body":"第4节. 基于mysql的FTP的虚拟用户和NFS服务介绍 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:38 "},"32-网络文件共享服务/5-基于NFS共享服务器.html":{"url":"32-网络文件共享服务/5-基于NFS共享服务器.html","title":"第5节 基于NFS共享服务器","keywords":"","body":"第5节. 基于NFS共享服务器 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"32-网络文件共享服务/6-NFS网络共享和自动挂载.html":{"url":"32-网络文件共享服务/6-NFS网络共享和自动挂载.html","title":"第6节 NFS网络共享和自动挂载","keywords":"","body":"第6节. NFS网络共享和自动挂载 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"32-网络文件共享服务/7-SAMBA共享服务实现01.html":{"url":"32-网络文件共享服务/7-SAMBA共享服务实现01.html","title":"第7节 SAMBA共享服务实现01","keywords":"","body":"第7节. SAMBA共享服务实现01 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"32-网络文件共享服务/8-SAMBA共享服务实现02.html":{"url":"32-网络文件共享服务/8-SAMBA共享服务实现02.html","title":"第8节 SAMBA共享服务实现02","keywords":"","body":"第8节. SAMBA共享服务实现02 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"32-网络文件共享服务/9-利用infotify和rsync服务实现实时同步.html":{"url":"32-网络文件共享服务/9-利用infotify和rsync服务实现实时同步.html","title":"第9节 利用infotify和rsync服务实现实时同步","keywords":"","body":"第9节. 利用infotify和rsync服务实现实时同步 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"33-linux防火墙/33-linux防火墙.html":{"url":"33-linux防火墙/33-linux防火墙.html","title":"第三十三章 linux防火墙","keywords":"","body":"第三十三章 linux防火墙 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"33-linux防火墙/1-linux防火墙基础.html":{"url":"33-linux防火墙/1-linux防火墙基础.html","title":"第1节 linux防火墙基础","keywords":"","body":"第1节. linux防火墙基础 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"33-linux防火墙/2-iptables防火墙实战.html":{"url":"33-linux防火墙/2-iptables防火墙实战.html","title":"第2节 iptables防火墙实战","keywords":"","body":"第2节. iptables防火墙实战 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"33-linux防火墙/3-iptables防火墙扩展模块实战.html":{"url":"33-linux防火墙/3-iptables防火墙扩展模块实战.html","title":"第3节 iptables防火墙扩展模块实战","keywords":"","body":"第3节. iptables防火墙扩展模块实战 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"33-linux防火墙/4-iptables防火墙扩展模块实战和策略优化.html":{"url":"33-linux防火墙/4-iptables防火墙扩展模块实战和策略优化.html","title":"第4节 iptables防火墙扩展模块实战和策略优化","keywords":"","body":"第4节. iptables防火墙扩展模块实战和策略优化 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"33-linux防火墙/5-网络防火墙和SNAT原理.html":{"url":"33-linux防火墙/5-网络防火墙和SNAT原理.html","title":"第5节 网络防火墙和SNAT原理","keywords":"","body":"第5节. 网络防火墙和SNAT原理 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"33-linux防火墙/6-网络防火墙DNAT实战和端口重定向.html":{"url":"33-linux防火墙/6-网络防火墙DNAT实战和端口重定向.html","title":"第6节 网络防火墙DNAT实战和端口重定向","keywords":"","body":"第6节. 网络防火墙DNAT实战和端口重定向 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"33-linux防火墙/7-firewalld新式防火墙实现.html":{"url":"33-linux防火墙/7-firewalld新式防火墙实现.html","title":"第7节 firewalld新式防火墙实现","keywords":"","body":"第7节. firewalld新式防火墙实现 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"33-linux防火墙/8-firewalld实现防火墙功能.html":{"url":"33-linux防火墙/8-firewalld实现防火墙功能.html","title":"第8节 firewalld实现防火墙功能","keywords":"","body":"第8节. firewalld实现防火墙功能 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"34-LinuxVirtualServer/34-LinuxVirtualServer.html":{"url":"34-LinuxVirtualServer/34-LinuxVirtualServer.html","title":"第三十四章 LinuxVirtualServer","keywords":"","body":"第三十四章 LinuxVirtualServer Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"34-LinuxVirtualServer/1-LVS工作原理和NAT模型.html":{"url":"34-LinuxVirtualServer/1-LVS工作原理和NAT模型.html","title":"第1节 LVS工作原理和NAT模型","keywords":"","body":"第1节. LVS工作原理和NAT模型 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"34-LinuxVirtualServer/2-LVS工作原理DR等三种模型.html":{"url":"34-LinuxVirtualServer/2-LVS工作原理DR等三种模型.html","title":"第2节 LVS工作原理DR等三种模型","keywords":"","body":"第2节. LVS工作原理DR等三种模型 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"34-LinuxVirtualServer/3-LVS和NAT模型实现.html":{"url":"34-LinuxVirtualServer/3-LVS和NAT模型实现.html","title":"第3节 LVS和NAT模型实现","keywords":"","body":"第3节. LVS和NAT模型实现 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"34-LinuxVirtualServer/4-LVS的DR模型实现.html":{"url":"34-LinuxVirtualServer/4-LVS的DR模型实现.html","title":"第4节 LVS的DR模型实现","keywords":"","body":"第4节. LVS的DR模型实现 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"34-LinuxVirtualServer/5-LVS跨网段DR模型和FWM多服务绑定.html":{"url":"34-LinuxVirtualServer/5-LVS跨网段DR模型和FWM多服务绑定.html","title":"第5节 LVS跨网段DR模型和FWM多服务绑定","keywords":"","body":"第5节. LVS跨网段DR模型和FWM多服务绑定 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"34-LinuxVirtualServer/6-LVS实现健康性检查功能.html":{"url":"34-LinuxVirtualServer/6-LVS实现健康性检查功能.html","title":"第6节 LVS实现健康性检查功能","keywords":"","body":"第6节. LVS实现健康性检查功能 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"34-LinuxVirtualServer/7-keepalived实现高可用性原理介绍.html":{"url":"34-LinuxVirtualServer/7-keepalived实现高可用性原理介绍.html","title":"第7节 keepalived实现高可用性原理介绍","keywords":"","body":"第7节. keepalived实现高可用性原理介绍 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"35-高可用集群keepalived/35-高可用集群keepalived.html":{"url":"35-高可用集群keepalived/35-高可用集群keepalived.html","title":"第三十五章 高可用集群keepalived","keywords":"","body":"第三十五章 高可用集群keepalived Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"35-高可用集群keepalived/1-keepalived实现浮动的VIP.html":{"url":"35-高可用集群keepalived/1-keepalived实现浮动的VIP.html","title":"第1节 keepalived实现浮动的VIP","keywords":"","body":"第1节. keepalived实现浮动的VIP Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"35-高可用集群keepalived/2-keepalive实现LVS的高可用性.html":{"url":"35-高可用集群keepalived/2-keepalive实现LVS的高可用性.html","title":"第2节 keepalive实现LVS的高可用性","keywords":"","body":"第2节. keepalive实现LVS的高可用性 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"36-高性能WEB服务nginx01/36-高性能WEB服务nginx01.html":{"url":"36-高性能WEB服务nginx01/36-高性能WEB服务nginx01.html","title":"第三十六章 高性能WEB服务nginx01","keywords":"","body":"第三十六章 高性能WEB服务nginx01 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"36-高性能WEB服务nginx01/1-IO五种模型和select与epoll工作原理.html":{"url":"36-高性能WEB服务nginx01/1-IO五种模型和select与epoll工作原理.html","title":"第1节 IO五种模型和select与epoll工作原理","keywords":"","body":"第1节. IO五种模型和select与epoll工作原理 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"36-高性能WEB服务nginx01/2-nginx编译安装和功能介绍.html":{"url":"36-高性能WEB服务nginx01/2-nginx编译安装和功能介绍.html","title":"第2节 nginx编译安装和功能介绍","keywords":"","body":"第2节. nginx编译安装和功能介绍 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"36-高性能WEB服务nginx01/3-nginx全局配置和性能优化.html":{"url":"36-高性能WEB服务nginx01/3-nginx全局配置和性能优化.html","title":"第3节 nginx全局配置和性能优化","keywords":"","body":"第3节. nginx全局配置和性能优化 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"36-高性能WEB服务nginx01/4-nginx实现web服务器01.html":{"url":"36-高性能WEB服务nginx01/4-nginx实现web服务器01.html","title":"第4节 nginx实现web服务器01","keywords":"","body":"第4节. nginx实现web服务器01 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"36-高性能WEB服务nginx01/5-nginx实现web服务器02.html":{"url":"36-高性能WEB服务nginx01/5-nginx实现web服务器02.html","title":"第5节 nginx实现web服务器02","keywords":"","body":"第5节. nginx实现web服务器02 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"37-高性能WEB服务nginx02/37-高性能WEB服务nginx02.html":{"url":"37-高性能WEB服务nginx02/37-高性能WEB服务nginx02.html","title":"第三十七章 高性能WEB服务nginx02","keywords":"","body":"第三十七章 高性能WEB服务nginx02 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"37-高性能WEB服务nginx02/1-nginx常见配置.html":{"url":"37-高性能WEB服务nginx02/1-nginx常见配置.html","title":"第1节 nginx常见配置","keywords":"","body":"第1节. nginx常见配置 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"37-高性能WEB服务nginx02/2-nginx第三方模块echo和自定义json.html":{"url":"37-高性能WEB服务nginx02/2-nginx第三方模块echo和自定义json.html","title":"第2节 nginx第三方模块echo和自定义json","keywords":"","body":"第2节. nginx第三方模块echo和自定义json Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"37-高性能WEB服务nginx02/3-nginx的压缩和https加密实现.html":{"url":"37-高性能WEB服务nginx02/3-nginx的压缩和https加密实现.html","title":"第3节 nginx的压缩和https加密实现","keywords":"","body":"第3节. nginx的压缩和https加密实现 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"37-高性能WEB服务nginx02/4-nginx的rewrite模块实现.html":{"url":"37-高性能WEB服务nginx02/4-nginx的rewrite模块实现.html","title":"第4节 nginx的rewrite模块实现","keywords":"","body":"第4节. nginx的rewrite模块实现 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"37-高性能WEB服务nginx02/5-nginx反向代理实现.html":{"url":"37-高性能WEB服务nginx02/5-nginx反向代理实现.html","title":"第5节 nginx反向代理实现","keywords":"","body":"第5节. nginx反向代理实现 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"38-高性能WEB服务nginx03/38-高性能WEB服务nginx03.html":{"url":"38-高性能WEB服务nginx03/38-高性能WEB服务nginx03.html","title":"第三十八章 高性能WEB服务nginx03","keywords":"","body":"第三十八章 高性能WEB服务nginx03 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"38-高性能WEB服务nginx03/1-nginx反向代理缓存和IP透传等功能.html":{"url":"38-高性能WEB服务nginx03/1-nginx反向代理缓存和IP透传等功能.html","title":"第1节 nginx反向代理缓存和IP透传等功能","keywords":"","body":"第1节. nginx反向代理缓存和IP透传等功能 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"38-高性能WEB服务nginx03/2-nginx实现fastcgi反向代理.html":{"url":"38-高性能WEB服务nginx03/2-nginx实现fastcgi反向代理.html","title":"第2节 nginx实现fastcgi反向代理","keywords":"","body":"第2节. nginx实现fastcgi反向代理 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"38-高性能WEB服务nginx03/3-nginx反向代理实现负载均衡及调度方法.html":{"url":"38-高性能WEB服务nginx03/3-nginx反向代理实现负载均衡及调度方法.html","title":"第3节 nginx反向代理实现负载均衡及调度方法","keywords":"","body":"第3节. nginx反向代理实现负载均衡及调度方法 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"38-高性能WEB服务nginx03/4-nginx四层代理功能和tengine编译安装.html":{"url":"38-高性能WEB服务nginx03/4-nginx四层代理功能和tengine编译安装.html","title":"第4节 nginx四层代理功能和tengine编译安装","keywords":"","body":"第4节. nginx四层代理功能和tengine编译安装 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "},"38-高性能WEB服务nginx03/5-keepalived实现反向代理的高可用.html":{"url":"38-高性能WEB服务nginx03/5-keepalived实现反向代理的高可用.html","title":"第5节 keepalived实现反向代理的高可用","keywords":"","body":"第5节. keepalived实现反向代理的高可用 Copyright 🌹 © oneyearice@126.com 2022 all right reserved，powered by Gitbook文档更新时间： 2022-01-16 23:43:39 "}}