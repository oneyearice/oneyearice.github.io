# 第3节. 函数存储过程和触发器和用户管理



## 函数-例1

### 创建函数

![image-20230526134652185](3-函数存储过程和触发器和用户管理.assets/image-20230526134652185.png)



### 查看函数列表

![image-20230526141610376](3-函数存储过程和触发器和用户管理.assets/image-20230526141610376.png)



![image-20230526141933726](3-函数存储过程和触发器和用户管理.assets/image-20230526141933726.png)



### 函数是保存在mysql.proc表中的

![image-20230526142241519](3-函数存储过程和触发器和用户管理.assets/image-20230526142241519.png)

排版换一下

![image-20230526142306722](3-函数存储过程和触发器和用户管理.assets/image-20230526142306722.png)



### 删除函数

![image-20230526142546221](3-函数存储过程和触发器和用户管理.assets/image-20230526142546221.png)





## 函数-例2

<img src="3-函数存储过程和触发器和用户管理.assets/image-20230526142833301.png" alt="image-20230526142833301" style="zoom:50%;" /> 

上图的注意点：改变以往;分号作为一个命令去断句执行的行为。而//才是断句。

然后最后结尾又改回去了，所以DELIMITER是一个全局命令。类似交换机的user-interface里的screen-length

![image-20230526143623778](3-函数存储过程和触发器和用户管理.assets/image-20230526143623778.png)

创建函数deleteByid，并传递参数uid，类型是SMALLINT 正数， RETRUNS返回的是字符串

BEGIN和END是标明函数体，如果简单的一句话搞定就不用写BEGIN和END，但是多句就不行了。



对比，跑函数之前的students里的行数是21

<img src="3-函数存储过程和触发器和用户管理.assets/image-20230526150224757.png" alt="image-20230526150224757" style="zoom:50%;" /> 



![image-20230526150424810](3-函数存储过程和触发器和用户管理.assets/image-20230526150424810.png)



跑一下函数后的行数是

![image-20230526150401407](3-函数存储过程和触发器和用户管理.assets/image-20230526150401407.png)

第10行没了

![image-20230526150447030](3-函数存储过程和触发器和用户管理.assets/image-20230526150447030.png)



### 函数里 赋值的方法①：set a =x 👇

![image-20230526152343782](3-函数存储过程和触发器和用户管理.assets/image-20230526152343782.png)

注意

END// DELIMITER; 其实是错误的写法，它表示已“END // DELIMITER;”结束的，而不是以//结束。

![image-20230526153120382](3-函数存储过程和触发器和用户管理.assets/image-20230526153120382.png)

![image-20230526154124496](3-函数存储过程和触发器和用户管理.assets/image-20230526154124496.png)



### 函数里赋值方法②：select into xxx

```
DELIMITER //
CREATE FUNCTION deleteById(uid SMALLINT UNSIGNED) RETURNS  VARCHAR(20)
BEGIN
DELETE FROM students WHERE stuid = uid;  
RETURN (SELECT COUNT(stuid) FROM students);  
END//
DELIMITER ;

可以改成

DELIMITER //
CREATE FUNCTION deleteById2(uid SMALLINT UNSIGNED) RETURNS  VARCHAR(20)
BEGIN
DECLARE x int;
DELETE FROM students WHERE stuid = uid;  
SELECT COUNT(stuid) FROM students INTO x;  # 这里是将select的结果放到了x变量里，这也是一种赋值。
RETURN x;
END//
DELIMITER ;
```

![image-20230526155908985](3-函数存储过程和触发器和用户管理.assets/image-20230526155908985.png)

👆DECLARE申明看来要放在函数体的最前面，紧跟着BEGIN才行。





## 存储过程，更似shell里的函数

调用的时候比上面的讲的函数更像shell里的函数。

![image-20230601180453125](3-函数存储过程和触发器和用户管理.assets/image-20230601180453125.png)

IN是给存储过程找个函数功能传递参数，是传进去

OUT是传出来

INOUT是双向的。



### 存储过程的案例

create创建、call执行 存储过程

<img src="3-函数存储过程和触发器和用户管理.assets/image-20230601181931136.png" alt="image-20230601181931136" style="zoom:50%;" /> 



![image-20230601182146782](3-函数存储过程和触发器和用户管理.assets/image-20230601182146782.png)





show procedure status;查看👇

![image-20230601182927590](3-函数存储过程和触发器和用户管理.assets/image-20230601182927590.png)

<img src="3-函数存储过程和触发器和用户管理.assets/image-20230601191633464.png" alt="image-20230601191633464" style="zoom:50%;" /> 



![image-20230601191932747](3-函数存储过程和触发器和用户管理.assets/image-20230601191932747.png)

![image-20230601191944372](3-函数存储过程和触发器和用户管理.assets/image-20230601191944372.png)

注意对比函数的type

![image-20230601192047360](3-函数存储过程和触发器和用户管理.assets/image-20230601192047360.png)



mysql库里也是存放了很多重要信息的：比如用户账号、还这里看到myql.proc里的函数、存储过程。

<img src="3-函数存储过程和触发器和用户管理.assets/image-20230601192249208.png" alt="image-20230601192249208" style="zoom:50%;" /> 

所以备份一定是要备份的。



### 存储过程参数的传递

![image-20230601192745939](3-函数存储过程和触发器和用户管理.assets/image-20230601192745939.png)



![image-20230601192826247](3-函数存储过程和触发器和用户管理.assets/image-20230601192826247.png)

注意如果换一个数据库就会报错，需要指定找个存储过程在哪个库里执行

![image-20230601193106588](3-函数存储过程和触发器和用户管理.assets/image-20230601193106588.png)



### 自定义变量在FUNCTION和PRODECURE里的类型

1、局部变量：var 这种

2、全局变量：@var  这种

![image-20230601193902122](3-函数存储过程和触发器和用户管理.assets/image-20230601193902122.png)

理解一下上面的mysql里的脚本，哈哈

<img src="3-函数存储过程和触发器和用户管理.assets/image-20230601193956602.png" alt="image-20230601193956602" style="zoom:50%;" /> 

变量是会话级别的变量，就是说 退出mysql的当前交互，变量就没了

![image-20230601194408215](3-函数存储过程和触发器和用户管理.assets/image-20230601194408215.png)





### 看下out参数的效果，从函数里传出来给到了全局变量。

![image-20230601194757281](3-函数存储过程和触发器和用户管理.assets/image-20230601194757281.png)

上图中的row_count()函数是上一次命令更改了多少行的意思。

![image-20230601200014417](3-函数存储过程和触发器和用户管理.assets/image-20230601200014417.png)

本例中就是 select row_count() into num;上一条cli，也就是DELETE xxx 更改了18行。

![image-20230601200338027](3-函数存储过程和触发器和用户管理.assets/image-20230601200338027.png)



同样测一下

![image-20230601200717202](3-函数存储过程和触发器和用户管理.assets/image-20230601200717202.png)



### 流程控制--存储过程和函数中可以使用IF CASE这些语句，这些专业叫法叫做“流程控制”

![image-20230601202137385](3-函数存储过程和触发器和用户管理.assets/image-20230601202137385.png)

LEAVE相当于break

ITERATE相当于continue





### 触发器--准确来讲应该较事件触发器

举例：比如你在jd购买了100个手机，下单了，那么库存里就要去掉100个手机，所以事件就是下单100个，触发就是库存里自动减去100个。



![image-20230601204841697](3-函数存储过程和触发器和用户管理.assets/image-20230601204841697.png)

DEFINER 是以什么身份来执行

TRIGGER就是定义触发器的名称

BEFORE 在 INSERT|UPDATE|DELETE之前进行的动作，换句话说就是在你增、改、删之前触发了某个动作，实际上就是不会去执行增、改、删了。就是说BEFORE就是用自定义的动作来代替trigger_event事件了。



### 触发器示例



附带主键的定义写法补充

<img src="3-函数存储过程和触发器和用户管理.assets/image-20230601205433887.png" alt="image-20230601205433887" style="zoom:33%;" /> 

一般是在定义字段的时候 比如 stu_id INT(11) NOT NULL AUTO_INCREMENT PRIMARY KEY，这样后跟一个主键来定义。

也可以单独PRIMARY KEY(stuid)去定义主键，那么这种是一般用来定义复合主键的。

